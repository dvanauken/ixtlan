+-- .editorconfig
+-- .gitignore
+-- .npmrc
+-- LICENSE
+-- README.md
+-- TiltedPerspective.gif
+-- TiltedPerspective.jpg
+-- TiltedPerspective.png
+-- angular.json
+-- error.txt
+-- generate-app-support-classes.ps1
+-- generate-components.ps1
+-- ng-package.json
+-- package-lock.json
+-- package.json
+-- src
|   +-- app
|   |   +-- accordion
|   |   |   -- accordion.data.ts: import { Injectable } from '@angular/core'; import { AccordionPanel } from '../../components/ixt-accordian/ixt-accordian.component';  @Injectable({   providedIn: 'root' }) export class AccordianDataService {   getAccordianPanels(): AccordionPanel[] {     return [       {         title: 'Section 1',         content: 'Content for section 1',         isOpen: false       },       {         title: 'Section 2',         content: 'Content for section 2',         isOpen: false       },       {         title: 'Section 3',         content: 'Content for section 3',         isOpen: false       }     ];   } }
|   |   +-- app.component.html: <main>   <nav>     <ixt-tabset title="Employee Form">       <ixt-tab title="Tab 1">         <ixt-tree [nodes]="treeProvider.treeData" (nodeExpanded)="treeHandler.onNodeExpanded($event)"           (nodeCollapsed)="treeHandler.onNodeCollapsed($event)" (nodeSelected)="treeHandler.onNodeSelected($event)">         </ixt-tree>       </ixt-tab>       <ixt-tab title="Tab 2">         <ixt-accordian [panels]="accordionPanels" [allowMultiple]="true">         </ixt-accordian>       </ixt-tab>     </ixt-tabset>   </nav>    <header>     <ixt-menu        src="./../assets/menu.json"       brandName="Your Brand"       brandLogo="./../assets/logo.png"       brandLink="/"       variant="default"       [showSearch]="true"       searchPlaceholder="Search products..."       (searchSubmitted)="onSearch($event)">     </ixt-menu>   </header>    <section>     <ixt-tabset>       <ixt-tab title="D3 Geo">         <ixt-map [width]="'100%'" [height]="'80%'" scale="1" translate="0,0">           <ixt-layer src="./../assets/countries.geojson" stroke="black" fill="gray"></ixt-layer>           <ixt-layer src="./../assets/flights.minified.geojson" stroke="red" fill="none" (click)="select($event)">             properties.airlineIata === 'F9'           </ixt-layer>           <ixt-layer src="./../assets/flights.minified.geojson" stroke="green" fill="none" (click)="select($event)">             properties.airlineIata === 'NK'           </ixt-layer>           <ixt-layer src="./../assets/lakes.geojson" stroke="black" fill="blue" (click)="select($event)"></ixt-layer>           <ixt-layer src="./../assets/rivers.geojson" stroke="purple" fill="none"             (hover)="highlight($event)"></ixt-layer>         </ixt-map>       </ixt-tab>        <!-- Dialog -->       <ixt-tab title="Dialog Example">         <div class="dialog-demo-container flex flex-col gap-4 p-4">           <!-- Service-based dialogs -->           <div class="flex flex-col gap-2">             <h3 class="text-lg font-semibold">Service-based Dialogs</h3>             <div class="flex flex-wrap gap-2">               <button (click)="showSuccessDialog()" class="px-4 py-2 bg-green-500 text-white rounded">                 Success Dialog               </button>                              <button (click)="showErrorDialog()" class="px-4 py-2 bg-red-500 text-white rounded">                 Error Dialog               </button>                              <button (click)="showConfirmDialog()" class="px-4 py-2 bg-blue-500 text-white rounded">                 Confirm Dialog               </button>                              <button (click)="showCustomDialog()" class="px-4 py-2 bg-purple-500 text-white rounded">                 Custom Dialog               </button>             </div>           </div>                  <!-- Template-based dialog example -->           <div class="flex flex-col gap-2 mt-4">             <h3 class="text-lg font-semibold">Template-based Dialog</h3>             <div class="flex flex-wrap gap-2">               <button (click)="templateDialog.open()" class="px-4 py-2 bg-gray-500 text-white rounded">                 Open Template Dialog               </button>             </div>                          <ixt-dialog #templateDialog>               <ng-template #dialogContent>                 <div class="p-4">                   <h2>Template Content</h2>                   <p>This dialog uses content projection and template reference.</p>                   <div class="form-group">                     <label for="exampleInput">Sample Input</label>                     <input type="text" id="exampleInput" [(ngModel)]="sampleInput" class="border p-2 mt-1 w-full">                   </div>                 </div>               </ng-template>                              <div ixtDialogFooter>                 <button (click)="templateDialog.close()" class="px-4 py-2 bg-gray-300 text-black rounded">                   Cancel                 </button>                 <button (click)="saveTemplateDialog()" class="px-4 py-2 bg-blue-500 text-white rounded ml-2">                   Save                 </button>               </div>             </ixt-dialog>           </div>                      <!-- Dynamic Component Dialog -->           <div class="flex flex-col gap-2 mt-4">             <h3 class="text-lg font-semibold">Dynamic Component Dialog</h3>             <div class="flex flex-wrap gap-2">               <button (click)="showDynamicComponentDialog()" class="px-4 py-2 bg-orange-500 text-white rounded">                 Open Dynamic Dialog               </button>             </div>           </div>         </div>       </ixt-tab>        <!-- Table --- soon to be removed  -->       <ixt-tab title="Tab 1">         <ixt-table [data]="tableProvider.employeeData" [config]="tableProvider.employeeConfig"></ixt-table>       </ixt-tab>       <ixt-tab title="Tab 2">         <ixt-table [data]="tableProvider.salesData" [config]="tableProvider.salesConfig"></ixt-table>       </ixt-tab>       <ixt-tab title="Tab 3">         <ixt-table [data]="tableProvider.inventoryData" [config]="tableProvider.inventoryConfig"></ixt-table>       </ixt-tab>        <ixt-tab title="Employee Form">         <form class="form-grid">           <h3>Personal Information</h3>           <div class="field">             <label>First Name</label>             <input type="text" [(ngModel)]="formData.firstName" name="firstName">           </div>           <div class="field">             <label>Last Name</label>             <input type="text" [(ngModel)]="formData.lastName" name="lastName">           </div>           <div class="field">             <label>Email</label>             <input type="email" [(ngModel)]="formData.email" name="email">           </div>           <h3>Employment Details</h3>           <div class="field">             <label>Department</label>             <input type="text" [(ngModel)]="formData.department" name="department">           </div>           <div class="field">             <label>Position</label>             <input type="text" [(ngModel)]="formData.position" name="position">           </div>           <div class="field">             <label>Start Date</label>             <input type="date" [(ngModel)]="formData.hireDate" name="hireDate">           </div>           <div class="actions">             <button type="button" (click)="employeeFormHandler.submitForm()">Save</button>             <button type="button" (click)="employeeFormHandler.resetForm()">Cancel</button>           </div>         </form>       </ixt-tab>          <ixt-tab title="Auto Complete">         <h2>Map Projection Selector</h2>         <ixt-auto-complete [options]="autocompleteProvider.projectionOptions" placeholder="Search projection..."           (valueChange)="autocompleteHandler.onValueChange($event)">         </ixt-auto-complete>       </ixt-tab>       <ixt-tab title="Calendar">         <ixt-calendar></ixt-calendar>       </ixt-tab>       <ixt-tab title="IxtMatrix">         <ixt-tabset>           <ixt-tab title="Standard Table">             <ixt-matrix [data]="matrixAirportData" [columnConfigs]="matrixColumnConfigs"               *ngIf="matrixAirportData.length">             </ixt-matrix>           </ixt-tab>           <ixt-tab title="Tree">             <ixt-matrix [data]="matrixTreeData"></ixt-matrix>           </ixt-tab>           <ixt-tab title="Table Tree">             <ixt-matrix [data]="matrixTableTreeData"></ixt-matrix>           </ixt-tab>         </ixt-tabset> </ixt-tab>       <ixt-tab title="IxtSplitPane">         <ixt-split-pane>           <div class="left-pane">             <h2>Left</h2>           </div>           <div class="right-pane">             <h2>Right</h2>           </div>         </ixt-split-pane>       </ixt-tab>       <ixt-tab title="Panels">         <h2>Examples</h2>         <div class="ixt-panel-container">           <div class="panel-grid">             <ixt-panel title="Basic Panel">               <div class="panel-content">                 This is a basic panel with default settings (bordered=true, elevated=false)               </div>             </ixt-panel>              <ixt-panel title="Elevated Panel" [elevated]="true" caption="With caption text">               <div class="panel-content">                 This panel has elevation enabled, creating a shadow effect               </div>             </ixt-panel>              <ixt-panel title="No Border Panel" [bordered]="false" [padding]="true">               <div class="panel-content">                 This panel has borders disabled but keeps padding               </div>             </ixt-panel>              <ixt-panel [bordered]="false" [padding]="false" [elevated]="false">               <div class="panel-content">                 A minimal panel without title, borders, elevation or padding               </div>             </ixt-panel>           </div>         </div>       </ixt-tab>     </ixt-tabset>   </section>    <aside>     <ixt-layer-manager [layers]="layerProvider.mapLayers" (layerChange)="layerManager.onLayerChange($event)"       (layerOrderChange)="layerManager.onLayerOrderChange($event)">     </ixt-layer-manager>     <!-- Layer manager commented out -->   </aside>    <footer>Footer</footer> </main>  <!-- Template for custom dialog content --> <ng-template #customDialogTemplate let-data>   <div class="p-4">     <p>Custom template with data: {{ data.message }}</p>     <div class="mt-2">       <input type="text" [(ngModel)]="data.input" class="border p-2 w-full">     </div>   </div> </ng-template>  
|   |   +-- app.component.scss: /* Component-specific styles */ nav, header, section, aside, footer {   padding: 1rem;   background: white;   box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
|   |   +-- app.component.ts: // app.component.ts import { Component, ViewChild, AfterViewInit, TemplateRef } from '@angular/core'; import { Layer } from '../components/ixt-layer-manager/ixt-layer-manager.component'; import { TreeNode } from '../components/ixt-tree/ixt-tree.component'; import { AccordionPanel } from '../components/ixt-accordian/ixt-accordian.component';  import { Expression, ExpressionGroup } from '../components/ixt-expression-builder/ixt-expression-builder.interfaces'; import { AutocompleteOption } from '../components/ixt-auto-complete/ixt-auto-complete.component';  import { IxtTableProvider } from './table/ixt-table.provider'; import { IxtTableHandler } from './table/ixt-table.handler'; import { IxtLayerProvider } from './layer/ixt-layer.provider'; import { IxtLayerManager } from './layer/ixt-layer.manager'; import { IxtTreeProvider } from './tree/ixt-tree.provider'; import { IxtTreeHandler } from './tree/ixt-tree.handler'; import { IxtExpressionProvider } from './expression/ixt-expression.provider'; import { IxtExpressionHelper } from './expression/ixt-expression.helper'; import { IxtAutocompleteProvider } from './autocomplete/ixt-autocomplete.provider'; import { IxtAutocompleteHandler } from './autocomplete/ixt-autocomplete.handler'; import { IxtEmployeeFormProvider } from './form/ixt-employee-form.provider'; import { IxtEmployeeFormHandler } from './form/ixt-employee-form.handler'; import { IxtMatrixProvider } from './matrix/ixt-matrix.provider'; import { IxtMenuProvider } from './menu/ixt-menu.provider'; import { AccordianDataService } from './accordion/accordion.data'; import { DynamicDialogContentComponent } from 'src/components/ixt-dialog/dynamic-dialog-content.component'; import { IxtDialogService } from 'src/components/ixt-dialog/ixt-dialog.service';   @Component({   selector: 'app-root',   templateUrl: './app.component.html',   styleUrls: ['./app.component.scss'],   providers: [     IxtTableProvider,     IxtTableHandler,     IxtLayerProvider,     IxtLayerManager,     IxtTreeProvider,     IxtTreeHandler,     IxtExpressionProvider,     IxtExpressionHelper,     IxtAutocompleteProvider,     IxtAutocompleteHandler,     IxtEmployeeFormProvider,     IxtEmployeeFormHandler,     IxtMatrixProvider,     IxtMenuProvider   ] }) export class AppComponent implements AfterViewInit {   [x: string]: any;   @ViewChild('customDialogTemplate') customDialogTemplate!: TemplateRef<any>;    sampleInput: string = '';    formData = this.employeeFormProvider.getCurrentForm();      matrixTableData = this.matrixProvider.getTableData();   matrixTreeData = this.matrixProvider.getTreeData();   matrixTableTreeData = this.matrixProvider.getTableTreeData();   matrixAirportData: any[] = [];   matrixColumnConfigs = this.matrixProvider.getAirportColumnConfigs();   accordionPanels = this.accordianDataService.getAccordianPanels();    constructor(     private dialogService: IxtDialogService,     public tableProvider: IxtTableProvider,     public tableHandler: IxtTableHandler,     public layerProvider: IxtLayerProvider,     public layerManager: IxtLayerManager,     public treeProvider: IxtTreeProvider,     public treeHandler: IxtTreeHandler,     public expressionProvider: IxtExpressionProvider,     public expressionHelper: IxtExpressionHelper,     public autocompleteProvider: IxtAutocompleteProvider,     public autocompleteHandler: IxtAutocompleteHandler,     public employeeFormProvider: IxtEmployeeFormProvider,     public employeeFormHandler: IxtEmployeeFormHandler,     public matrixProvider: IxtMatrixProvider,     public menuProvider: IxtMenuProvider,     private accordianDataService: AccordianDataService   ) { }    ngOnInit() {     this.matrixProvider.getAirportData().subscribe(data => {       this.matrixAirportData = data;     });   }      ngAfterViewInit() {   }    select(event: Event): void {     console.log('Selected:', event);   }    highlight(event: Event): void {     console.log('Highlighted:', event);   }     onSearch(searchTerm: string) {     // Handle the search term     console.log('Search term:', searchTerm);   }     //dialog -- start   showSuccessDialog() {     this.dialogService.alert({       title: 'Success',       content: 'Operation completed successfully!',       variant: 'success',       // buttons: [       //   {       //     text: 'OK',       //     variant: 'success',       //     close: true       //   }       // ]     });   }      showErrorDialog() {     this.dialogService.alert({       title: 'Error',       content: 'Something went wrong. Please try again.',       variant: 'danger',     });   }    showConfirmDialog() {     this.dialogService.confirm({       title: 'Confirm Action',       content: 'Are you sure you want to proceed with this action?',       variant: 'warning',       buttons: [         {           text: 'Cancel',           variant: 'light',           close: true         },         {           text: 'Confirm',           variant: 'warning',           callback: () => {             console.log('Confirmed');           },           close: true         }       ]     });   }    showCustomDialog() {     const dialogData = {       message: 'This is a custom dialog with dynamic data',       input: ''     };      const dialogRef = this.dialogService.open({       title: 'Custom Dialog',       content: this.customDialogTemplate,       contentContext: { data: dialogData },       variant: 'info',       buttons: [         {           text: 'Cancel',           variant: 'light',           close: true         },         {           text: 'Save',           variant: 'primary',           callback: () => {             console.log('Saved data:', dialogData.input);             return true;           },           close: true         }       ]     });   }    showDynamicComponentDialog() {     const dialogRef = this.dialogService.open({       title: 'Dynamic Component',       content: DynamicDialogContentComponent,       variant: 'primary',       contentContext: {         data: {           message: 'This content is from a dynamic component'         }       }     });   }    saveTemplateDialog() {     console.log('Saving template dialog data:', this.sampleInput);     // Implement save logic here   }   //dialog end  }
|   |   +-- app.module.ts: // app.module.ts import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { FormsModule } from '@angular/forms'; import { HttpClientModule } from '@angular/common/http';  // Component Modules (alphabetized) import { IxtAutoCompleteModule } from '../components/ixt-auto-complete/ixt-auto-complete.module'; import { IxtCalendarModule } from '../components/ixt-calendar/ixt-calendar.module'; import { IxtExpressionBuilderModule } from '../components/ixt-expression-builder/ixt-expression-builder.module'; import { IxtHolyGrailModule } from '../components/ixt-holy-grail/ixt-holy-grail.module'; import { IxtLayerManagerModule } from '../components/ixt-layer-manager/ixt-layer-manager.module'; import { IxtTableModule } from '../components/ixt-table/ixt-table.module'; import { IxtTabsetModule } from '../components/ixt-tabset/ixt-tabset.module'; import { IxtTreeModule } from '../components/ixt-tree/ixt-tree.module'; import { IxtMenuModule } from '../components/ixt-menu/ixt-menu.module';   // Components import { AppComponent } from './app.component';  // Providers, Handlers, and Helpers (alphabetized) import { IxtAutocompleteHandler } from './autocomplete/ixt-autocomplete.handler'; import { IxtAutocompleteProvider } from './autocomplete/ixt-autocomplete.provider'; import { IxtEmployeeFormHandler } from './form/ixt-employee-form.handler'; import { IxtEmployeeFormProvider } from './form/ixt-employee-form.provider'; import { IxtExpressionHelper } from './expression/ixt-expression.helper'; import { IxtExpressionProvider } from './expression/ixt-expression.provider'; import { IxtLayerManager } from './layer/ixt-layer.manager'; import { IxtLayerProvider } from './layer/ixt-layer.provider'; import { IxtMatrixProvider } from './matrix/ixt-matrix.provider'; import { IxtTableHandler } from './table/ixt-table.handler'; import { IxtTableProvider } from './table/ixt-table.provider'; import { IxtTreeHandler } from './tree/ixt-tree.handler'; import { IxtTreeProvider } from './tree/ixt-tree.provider'; import { IxtMatrixModule } from 'src/components/ixt-matrix/ixt-matrix.index'; import { IxtSplitPaneModule } from 'src/components/ixt-split-pane'; import { IxtPanelModule } from 'src/components/ixt-panel'; import { IxtAccordianModule } from 'src/components/ixt-accordian/accordian.module';  import { IxtMapModule } from 'src/components/ixt-map/ixt-map.module'; import { RouterModule } from '@angular/router'; import { IxtDialogModule } from 'src/components/ixt-dialog/ixt-dialog.module';   @NgModule({   declarations: [     AppComponent   ],   imports: [     RouterModule.forRoot([]),  // No routes defined, but RouterModule is configured     BrowserAnimationsModule,     BrowserModule,     FormsModule,     HttpClientModule,  // Add this line     IxtAccordianModule,       IxtAutoCompleteModule,     IxtCalendarModule,     IxtExpressionBuilderModule,     IxtHolyGrailModule,     IxtLayerManagerModule,     IxtMatrixModule,     IxtTableModule,     IxtTabsetModule,     IxtTreeModule,     IxtSplitPaneModule,     IxtPanelModule,     IxtMenuModule,     IxtMapModule,     IxtDialogModule   ],   providers: [     IxtAutocompleteHandler,     IxtAutocompleteProvider,     IxtEmployeeFormHandler,     IxtEmployeeFormProvider,     IxtExpressionHelper,     IxtExpressionProvider,     IxtLayerManager,     IxtLayerProvider,     IxtMatrixProvider,     IxtTableHandler,     IxtTableProvider,     IxtTreeHandler,     IxtTreeProvider,   ],   bootstrap: [     AppComponent   ] }) export class AppModule { }
|   |   +-- autocomplete
|   |   |   +-- ixt-autocomplete.handler.ts: // src/app/autocomplete/ixt-autocomplete.handler.ts import { Injectable } from '@angular/core'; import { AutocompleteOption } from '../../components/ixt-auto-complete/ixt-auto-complete.component';  @Injectable() export class IxtAutocompleteHandler {    onValueChange(selected: AutocompleteOption) {        console.log('Selected projection:', selected);    } }
|   |   |   -- ixt-autocomplete.provider.ts: // src/app/autocomplete/ixt-autocomplete.provider.ts import { Injectable } from '@angular/core'; import { AutocompleteOption } from '../../components/ixt-auto-complete/ixt-auto-complete.component';  @Injectable() export class IxtAutocompleteProvider {    projectionOptions: AutocompleteOption[] = [        { value: "geoAlbers", label: "Albers" },        { value: "geoAlbersUsa", label: "Albers USA" },        { value: "geoAzimuthalEqualArea", label: "Azimuthal Equal Area" },        { value: "geoAzimuthalEquidistant", label: "Azimuthal Equidistant" },        { value: "geoConicConformal", label: "Conic Conformal" },        { value: "geoConicEqualArea", label: "Conic Equal Area" },        { value: "geoConicEquidistant", label: "Conic Equidistant" },        { value: "geoMercator", label: "Mercator" },        { value: "geoOrthographic", label: "Orthographic" }    ]; }  
|   |   +-- dialog
|   |   |   -- ixt-dialog.handler.ts: 
|   |   +-- expression
|   |   |   +-- ixt-expression.helper.ts: // src/app/expression/ixt-expression.helper.ts import { Injectable } from '@angular/core';  // Add this import { Expression, ExpressionGroup } from '../../components/ixt-expression-builder/ixt-expression-builder.interfaces';  @Injectable() export class IxtExpressionHelper {     convertToJsonLogic(group: ExpressionGroup): any {         if (group.children.length === 0) return {};                  const logic: any = {             [group.operator]: group.children.map((child: Expression | ExpressionGroup) => {                 if (child.type === 'group') {                     return this.convertToJsonLogic(child);                 }                                  if (child.type === 'expression') {                     if (child.operator === 'in' || child.operator === 'not_in') {                         return {                             [child.operator === 'in' ? 'in' : '!in']: [                                 { var: child.field },                                 child.values || []                             ]                         };                     }                     return {                         [child.operator]: [                             { var: child.field },                             child.value                         ]                     };                 }                 return {};             })         };         return logic;     } }  
|   |   |   -- ixt-expression.provider.ts: // src/app/expression/ixt-expression.provider.ts import { Injectable } from '@angular/core';  // Add this import { Expression, ExpressionGroup } from '../../components/ixt-expression-builder/ixt-expression-builder.interfaces'; import { IxtExpressionHelper } from './ixt-expression.helper';  @Injectable()  // Add this export class IxtExpressionProvider {     expressionGroup: ExpressionGroup = {         type: 'group',         operator: 'and',         children: []     };      expressionJsonLogic: any = {};      constructor(private helper: IxtExpressionHelper) {}      onExpressionGroupChange(group: ExpressionGroup): void {         this.expressionGroup = group;         this.expressionJsonLogic = this.helper.convertToJsonLogic(group);     } }
|   |   +-- form
|   |   |   +-- ixt-employee-form.handler.ts: // src/app/form/ixt-employee-form.handler.ts import { Injectable } from '@angular/core'; import { IxtEmployeeFormProvider } from './ixt-employee-form.provider'; import { IxtDialogService } from '../../components/ixt-dialog/ixt-dialog.service'; import { DialogType } from '../../components/ixt-dialog/ixt-dialog.interfaces'; import { EmployeeForm } from './ixt-employee-form.provider';  @Injectable() export class IxtEmployeeFormHandler {   constructor(     private provider: IxtEmployeeFormProvider,     private dialogService: IxtDialogService   ) {}    async submitForm() {     const form = this.provider.getCurrentForm();          // Validate form     if (!this.validateForm(form)) {       this.dialogService.show({         title: 'Validation Error',         message: 'Please fill in all required fields.',         type: DialogType.Error,         okText: 'OK',         showCancel: false,         isModal: true       });       return;     }      try {       // Simulate API call       await this.saveEmployee(form);              this.dialogService.show({         title: 'Success',         message: 'Employee information saved successfully!',         type: DialogType.Success,         okText: 'OK',         showCancel: false,         isModal: true       });              this.provider.resetForm();     } catch (error) {       this.dialogService.show({         title: 'Error',         message: 'Failed to save employee information. Please try again.',         type: DialogType.Error,         okText: 'OK',         showCancel: false,         isModal: true       });     }   }    confirmDelete(employeeId: number) {     this.dialogService.show({       title: 'Confirm Delete',       message: 'Are you sure you want to delete this employee record?',       type: DialogType.Question,       okText: 'Yes',       cancelText: 'No',       showCancel: true,       isModal: true     });   }    updateField(field: keyof EmployeeForm, value: any) {     this.provider.updateForm({ [field]: value });   }    private validateForm(form: EmployeeForm): boolean {     return !!(       form.firstName &&       form.lastName &&       form.email &&       form.department &&       form.position &&       form.hireDate     );   }    private async saveEmployee(form: EmployeeForm): Promise<void> {     // Simulate API call     return new Promise((resolve, reject) => {       setTimeout(() => {         // Simulate 90% success rate         if (Math.random() > 0.1) {           resolve();         } else {           reject(new Error('Failed to save employee'));         }       }, 1000);     });   }    showUnsavedChangesDialog(): Promise<boolean> {     return new Promise((resolve) => {       this.dialogService.show({         title: 'Unsaved Changes',         message: 'You have unsaved changes. Do you want to continue?',         type: DialogType.Warning,         okText: 'Yes',         cancelText: 'No',         showCancel: true,         isModal: true       });     });   }    resetForm() {     this.dialogService.show({       title: 'Confirm Reset',       message: 'Are you sure you want to reset the form? All unsaved changes will be lost.',       type: DialogType.Warning,       okText: 'Yes',       cancelText: 'No',       showCancel: true,       isModal: true     });   } }
|   |   |   -- ixt-employee-form.provider.ts: // src/app/form/ixt-employee-form.provider.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs';  export interface EmployeeForm {   id?: number;   firstName: string;   lastName: string;   email: string;   phone: string;   department: string;   position: string;   hireDate: Date;   // Add any other employee fields you need }  @Injectable() export class IxtEmployeeFormProvider {   private formState = new BehaviorSubject<EmployeeForm>({     firstName: '',     lastName: '',     email: '',     phone: '',     department: '',     position: '',     hireDate: new Date()   });    formState$ = this.formState.asObservable();    updateForm(form: Partial<EmployeeForm>) {     this.formState.next({       ...this.formState.value,       ...form     });   }    resetForm() {     this.formState.next({       firstName: '',       lastName: '',       email: '',       phone: '',       department: '',       position: '',       hireDate: new Date()     });   }    getCurrentForm(): EmployeeForm {     return this.formState.value;   } }
|   |   +-- layer
|   |   |   +-- ixt-layer.manager.ts:  // src/app/layer/ixt-layer.manager.ts import { Injectable } from '@angular/core'; import { Layer } from '../../components/ixt-layer-manager/ixt-layer-manager.component';  @Injectable({     providedIn: 'root'  // Makes it a singleton service available app-wide }) export class IxtLayerManager {     onLayerChange(layers: any[]) {         console.log('Layers updated:', layers);         // Implement your layer update logic here     }      onLayerOrderChange(layers: any[]) {         console.log('Layer order changed:', layers);         // Implement your layer order update logic here     } }
|   |   |   -- ixt-layer.provider.ts: // src/app/layer/ixt-layer.provider.ts import { Injectable } from '@angular/core'; import { Layer } from '../../components/ixt-layer-manager/ixt-layer-manager.component';  @Injectable({     providedIn: 'root'  // Makes it a singleton service available app-wide }) export class IxtLayerProvider {     mapLayers: Layer[] = [         {             id: 'layer1',             name: 'Base Map',             visible: true,             fillColor: '#e3e3e3',             strokeColor: '#666666',             strokeStyle: 'solid' as const,             order: 0         },         {             id: 'layer2',             name: 'Roads',             visible: true,             fillColor: '#ffffff',             strokeColor: '#333333',             strokeStyle: 'solid' as const,             order: 1         },         {             id: 'layer3',             name: 'Points of Interest',             visible: true,             fillColor: '#ff4444',             strokeColor: '#cc0000',             strokeStyle: 'dotted' as const,             order: 2         }     ]; } 
|   |   +-- matrix
|   |   |   -- ixt-matrix.provider.ts: // src/app/matrix/ixt-matrix.provider.ts import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { Observable } from 'rxjs'; import { IxtDialogService } from 'src/components/ixt-dialog/ixt-dialog.service'; import { AirportCodeEditorComponent } from 'src/components/ixt-matrix/ixt-matrix.index'; import { ColumnConfig, ColumnConfigs } from 'src/components/ixt-matrix/ixt-matrix.interfaces'; import { CoordinateEditorComponent } from 'src/components/ixt-matrix/matrix-editors/coordinate/coordinate-editor.component';  interface MatrixNode {   id?: number;   name: string;   department?: string;   position?: string;   salary?: number;   type?: string;   size?: string;   modified?: string;   children?: MatrixNode[]; }  @Injectable({   providedIn: 'root' }) export class IxtMatrixProvider {   constructor(     private http: HttpClient,     private dialogService: IxtDialogService   ) {}    getColumnConfigs(): ColumnConfigs {     return {       code: {         type: AirportCodeEditorComponent as any,         field: 'code',         editable: true,         label: 'IATA Code'        },       region: {         type: 'text',         field: 'region',         label: 'Region',          editable: true       },       name: {         type: 'text',         field: 'name',         label: 'Name',          editable: true       },       city: {         type: 'text',         field: 'city',         label: 'City',          editable: true       },       country: {         type: 'text',         field: 'country',         label: 'Country',          editable: true       },       lat: {         type: CoordinateEditorComponent,         field: 'lat',         label: 'LAT',          editable: true       },       lon: {         type: CoordinateEditorComponent,         field: 'lon',         label: 'LON',          editable: true       }     };   }    getTableData(): MatrixNode[] {     return [       { id: 1, name: 'John Smith', department: 'Engineering', position: 'Senior Developer', salary: 95000 },       { id: 2, name: 'Sarah Johnson', department: 'Design', position: 'UX Designer', salary: 85000 },       { id: 3, name: 'Michael Brown', department: 'Engineering', position: 'DevOps Engineer', salary: 90000 },       { id: 4, name: 'Emily Davis', department: 'Marketing', position: 'Marketing Manager', salary: 82000 },       { id: 5, name: 'David Wilson', department: 'Engineering', position: 'Software Engineer', salary: 88000 }     ];   }    getTreeData(): MatrixNode[] {     return [       {         name: 'Documents',         children: [           {              name: 'Work',             children: [               { name: 'Reports' },               { name: 'Presentations' }             ]           },           {              name: 'Personal',             children: [               { name: 'Photos' },               { name: 'Videos' }             ]           }         ]       },       {         name: 'Downloads',         children: [           { name: 'Software' },           { name: 'Music' }         ]       }     ];   }    getTableTreeData(): MatrixNode[] {     return [       {         name: 'Documents',         type: 'Folder',         size: '-- KB',         modified: '2024-01-15',         children: [           {             name: 'Work',             type: 'Folder',             size: '-- KB',             modified: '2024-01-20',             children: [               { name: 'Q4_Report.pdf', type: 'PDF', size: '2.5 MB', modified: '2024-01-22' },               { name: 'Budget_2024.xlsx', type: 'Excel', size: '1.8 MB', modified: '2024-01-23' }             ]           },           {             name: 'Personal',             type: 'Folder',             size: '-- KB',             modified: '2024-01-18',             children: [               { name: 'vacation.jpg', type: 'Image', size: '3.2 MB', modified: '2024-01-19' },               { name: 'notes.txt', type: 'Text', size: '12 KB', modified: '2024-01-21' }             ]           }         ]       },       {         name: 'Projects',         type: 'Folder',         size: '-- KB',         modified: '2024-01-16',         children: [           { name: 'project_plan.doc', type: 'Word', size: '850 KB', modified: '2024-01-17' },           { name: 'design_mockup.psd', type: 'Photoshop', size: '5.6 MB', modified: '2024-01-18' }         ]       }     ];   }    getAirportData(): Observable<any[]> {     return this.http.get<any[]>('assets/Airport.json');   }    getAirportColumnConfigs(): ColumnConfigs {     return this.getColumnConfigs();   } }
|   |   +-- menu
|   |   |   -- ixt-menu.provider.ts: // ixt-menu.provider.ts import { Injectable } from '@angular/core'; //import { MenuNode } from 'src/components/ixt-menu';  @Injectable({   providedIn: 'root' }) export class IxtMenuProvider { }
|   |   +-- table
|   |   |   +-- ixt-table.handler.ts: // src/app/table/ixt-table.handler.ts import { Injectable } from '@angular/core'; import { TableConfig } from '../../components/ixt-table/ixt-table.interfaces';  @Injectable({     providedIn: 'root' }) export class IxtTableHandler {     onSort(event: any) {         console.log('Sort event:', event);     }      onFilter(event: any) {         console.log('Filter event:', event);     }      onRowSelect(event: any) {         console.log('Row select:', event);     }      onEdit(event: any) {         console.log('Edit event:', event);     }      onDelete(event: any) {         console.log('Delete event:', event);     } }
|   |   |   -- ixt-table.provider.ts: // src/app/table/ixt-table.provider.ts import { Injectable } from '@angular/core'; import { TableConfig } from '../../components/ixt-table/ixt-table.interfaces';  @Injectable({     providedIn: 'root' }) export class IxtTableProvider {     // Employee table     employeeData = [         { empId: 'E001', name: 'John Smith', department: 'IT', projects: 3, rating: 4.5 },         { empId: 'E002', name: 'Sarah Johnson', department: 'HR', projects: 2, rating: 4.8 },         { empId: 'E003', name: 'Mike Williams', department: 'IT', projects: 4, rating: 4.2 },         { empId: 'E004', name: 'Lisa Brown', department: 'Marketing', projects: 3, rating: 4.6 }     ];      employeeConfig: TableConfig<any> = {         columns: [             { key: 'empId', header: 'Employee ID', sortable: true },             { key: 'name', header: 'Name', sortable: true, filterable: true },             { key: 'department', header: 'Department', filterable: true },             { key: 'projects', header: 'Projects', sortable: true },             { key: 'rating', header: 'Rating', sortable: true }         ],         selectionMode: 'single',         allowEdit: true     };      // Sales table     salesData = [         { id: 1, product: 'Laptop', quantity: 50, revenue: 75000, date: '2024-02-01' },         { id: 2, product: 'Mouse', quantity: 150, revenue: 4500, date: '2024-02-01' },         { id: 3, product: 'Keyboard', quantity: 100, revenue: 8000, date: '2024-02-02' }     ];      salesConfig: TableConfig<any> = {         columns: [             { key: 'id', header: 'ID', sortable: true },             { key: 'product', header: 'Product', sortable: true, filterable: true },             { key: 'quantity', header: 'Quantity', sortable: true },             { key: 'revenue', header: 'Revenue', sortable: true,             formatter: (val) => `$${val.toLocaleString()}` },             { key: 'date', header: 'Date', sortable: true }         ],         selectionMode: 'multiple',         allowEdit: false     };      // Inventory table     inventoryData = [         { sku: 'INV001', item: 'Widget A', stock: 150, status: 'In Stock', lastUpdated: '2024-02-15' },         { sku: 'INV002', item: 'Widget B', stock: 75, status: 'Low Stock', lastUpdated: '2024-02-14' },         { sku: 'INV003', item: 'Widget C', stock: 0, status: 'Out of Stock', lastUpdated: '2024-02-13' }     ];      inventoryConfig: TableConfig<any> = {         columns: [             { key: 'sku', header: 'SKU', sortable: true },             { key: 'item', header: 'Item', sortable: true, filterable: true },             { key: 'stock', header: 'Stock', sortable: true },             { key: 'status', header: 'Status', filterable: true },             { key: 'lastUpdated', header: 'Last Updated', sortable: true }         ],         selectionMode: 'none',         allowEdit: true,         allowDelete: true     }; }
|   |   -- tree
|   |      +-- ixt-tree.handler.ts: // src/app/tree/ixt-tree.handler.ts import { Injectable } from '@angular/core'; import { TreeNode } from '../../components/ixt-tree/ixt-tree.component';  @Injectable({     providedIn: 'root' }) export class IxtTreeHandler {     onNodeExpanded(node: TreeNode): void {         console.log('Node expanded:', node);     }      onNodeCollapsed(node: TreeNode): void {         console.log('Node collapsed:', node);     }      onNodeSelected(node: TreeNode): void {         console.log('Node selected:', node);     } }
|   |      -- ixt-tree.provider.ts: // src/app/tree/ixt-tree.provider.ts import { Injectable } from '@angular/core'; import { TreeNode } from '../../components/ixt-tree/ixt-tree.component';  @Injectable({     providedIn: 'root' }) export class IxtTreeProvider {     treeData: TreeNode[] = [         {             id: '1',             label: 'Project Files',             children: [                 {                     id: '1.1',                     label: 'src',                     children: [                         {                             id: '1.1.1',                             label: 'app',                             children: [                                 { id: '1.1.1.1', label: 'components' },                                 { id: '1.1.1.2', label: 'services' }                             ]                         },                         { id: '1.1.2', label: 'assets' }                     ]                 },                 {                     id: '1.2',                     label: 'config',                     children: [                         { id: '1.2.1', label: 'tsconfig.json' },                         { id: '1.2.2', label: 'package.json' }                     ]                 }             ]         }     ]; }
|   +-- assets
|   |   +-- .gitkeep
|   |   +-- Airport.json
|   |   +-- countries.geojson
|   |   +-- flights.minified.geojson
|   |   +-- lakes.geojson
|   |   +-- land-10m.json
|   |   +-- land-110m.json
|   |   +-- land-50m.json
|   |   +-- logo.png
|   |   +-- logo2.png
|   |   +-- menu.json
|   |   +-- moscow.geojson
|   |   -- rivers.geojson
|   +-- components
|   |   +-- ixt-accordian
|   |   |   +-- accordian.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { IxtAccordianComponent } from './ixt-accordian.component';  @NgModule({   declarations: [     IxtAccordianComponent   ],   imports: [     CommonModule,     BrowserAnimationsModule   ],   exports: [     IxtAccordianComponent   ] }) export class IxtAccordianModule { }
|   |   |   +-- index.ts: // src/components/ixt-accordion/index.ts export * from './ixt-accordian.component'; export * from './ixt-accordian.module';
|   |   |   +-- ixt-accordian.component.html: <!-- ixt-accordian.component.html --> <div class="ixt-accordion">     <div class="accordion-panel" *ngFor="let panel of panels; let i = index">       <div class="panel-header" (click)="togglePanel(i)">         <span class="panel-title">{{panel.title}}</span>         <span class="material-icons" [class.open]="panel.isOpen">           expand_more         </span>       </div>       <div class="panel-content" [@slideInOut]="panel.isOpen ? 'open' : 'closed'">         {{panel.content}}       </div>     </div>   </div>
|   |   |   +-- ixt-accordian.component.scss: // ixt-accordian.component.scss .ixt-accordion {     width: 100%;     border: 1px solid #e0e0e0;     border-radius: 4px;     overflow: hidden;   }      .accordion-panel {     border-bottom: 1px solid #e0e0e0;     &:last-child {       border-bottom: none;     }   }      .panel-header {     display: flex;     justify-content: space-between;     align-items: center;     padding: 16px;     background-color: #fff;     cursor: pointer;     transition: background-color 0.2s ease;        &:hover {       background-color: #f5f5f5;     }   }      .panel-title {     font-size: 16px;     font-weight: 500;   }      .material-icons {     color: #4169E1;     transition: transform 0.2s ease;          &.open {       transform: rotate(180deg);     }   }      .panel-content {     padding: 0 16px;     background-color: #fff;     overflow: hidden;   }
|   |   |   -- ixt-accordian.component.ts: // ixt-accordian.component.ts import { Component, Input } from '@angular/core'; import { animate, state, style, transition, trigger } from '@angular/animations';  export interface AccordionPanel {   title: string;   content: string;   isOpen?: boolean; }  @Component({   selector: 'ixt-accordian',   templateUrl: './ixt-accordian.component.html',   styleUrls: ['./ixt-accordian.component.scss'],   animations: [     trigger('slideInOut', [       state('open', style({         height: '*',         opacity: 1       })),       state('closed', style({         height: '0',         opacity: 0       })),       transition('closed <=> open', [         animate('200ms ease-in-out')       ])     ])   ] }) export class IxtAccordianComponent {   @Input() panels: AccordionPanel[] = [];   @Input() allowMultiple = false;    togglePanel(index: number): void {     if (!this.allowMultiple) {       this.panels.forEach((panel, i) => {         if (i !== index) panel.isOpen = false;       });     }     this.panels[index].isOpen = !this.panels[index].isOpen;   } }
|   |   +-- ixt-auto-complete
|   |   |   +-- ixt-auto-complete.component.html: <div class="ixt-autocomplete-container">     <input       [formControl]="inputControl"       [placeholder]="placeholder"       (blur)="onBlur()"       class="ixt-autocomplete-input"       type="text"       autocomplete="off"     >          <div        *ngIf="showDropdown && filteredOptions.length > 0"        class="ixt-autocomplete-dropdown"     >       <div         *ngFor="let option of filteredOptions"         (mousedown)="selectOption(option)"         class="ixt-autocomplete-option"       >         {{ option.label }}       </div>     </div>   </div>
|   |   |   +-- ixt-auto-complete.component.scss: .ixt-autocomplete-input {     width: 100%;   }      .ixt-autocomplete-dropdown {     margin-top: 4px;     border: 1px solid #ddd;   }      .ixt-autocomplete-option {     padding: 8px;     cursor: pointer;          &:hover {       background: #f8f9fa;     }   }
|   |   |   +-- ixt-auto-complete.component.ts: import { Component, Input, Output, EventEmitter, OnInit } from '@angular/core'; import { FormControl } from '@angular/forms'; import { debounceTime, distinctUntilChanged } from 'rxjs/operators';  export interface AutocompleteOption {   value: string;   label: string; }  @Component({   selector: 'ixt-auto-complete',   templateUrl: './ixt-auto-complete.component.html',   styleUrls: ['./ixt-auto-complete.component.scss'] }) export class IxtAutoCompleteComponent implements OnInit {   @Input() options: AutocompleteOption[] = [];   @Input() placeholder = 'Search...';   @Output() valueChange = new EventEmitter<AutocompleteOption>();    inputControl = new FormControl('');   filteredOptions: AutocompleteOption[] = [];   showDropdown = false;    ngOnInit() {     this.inputControl.valueChanges.pipe(       debounceTime(300),       distinctUntilChanged()     ).subscribe(value => {       this.filterOptions(value || '');     });   }    private filterOptions(value: string) {     const filterValue = value.toLowerCase();     this.filteredOptions = this.options.filter(option =>       option.label.toLowerCase().includes(filterValue)     );     this.showDropdown = true;   }    selectOption(option: AutocompleteOption) {     this.inputControl.setValue(option.label);     this.showDropdown = false;     this.valueChange.emit(option);   }    onBlur() {     setTimeout(() => {       this.showDropdown = false;     }, 200);   } }
|   |   |   -- ixt-auto-complete.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { ReactiveFormsModule } from '@angular/forms'; import { IxtAutoCompleteComponent } from './ixt-auto-complete.component';  @NgModule({   declarations: [IxtAutoCompleteComponent],   imports: [     CommonModule,     ReactiveFormsModule   ],   exports: [IxtAutoCompleteComponent] }) export class IxtAutoCompleteModule { }
|   |   +-- ixt-bread-crumb
|   |   |   +-- index.ts: export * from './ixt-bread-crumb.component'; export * from './ixt-bread-crumb.interfaces'; export * from './ixt-bread-crumb.service'; export * from './ixt-bread-crumb.module';
|   |   |   +-- ixt-bread-crumb.component.html: <nav aria-label="breadcrumb">     <ol class="breadcrumb">       <li class="breadcrumb-item">         <a [routerLink]="'/'">Home</a>       </li>       <li class="breadcrumb-item" *ngFor="let breadcrumb of breadcrumbs; let last = last" [class.active]="last">         <a *ngIf="!last" [routerLink]="breadcrumb.path">{{breadcrumb.label}}</a>         <span *ngIf="last">{{breadcrumb.label}}</span>       </li>     </ol>   </nav>
|   |   |   +-- ixt-bread-crumb.component.scss: // components/ixt-bread-crumb/ixt-bread-crumb.component.scss .breadcrumb {     display: flex;     flex-wrap: wrap;     padding: 0.75rem 1rem;     margin-bottom: 1rem;     list-style: none;     background-color: #f8f9fa;     border-radius: 0.25rem;   }      .breadcrumb-item {     & + .breadcrumb-item {       padding-left: 0.5rem;              &::before {         content: "/";         padding-right: 0.5rem;         color: #6c757d;       }     }          &.active {       color: #6c757d;     }   }
|   |   |   +-- ixt-bread-crumb.component.ts: // components/ixt-bread-crumb/ixt-bread-crumb.component.ts import { Component, OnInit, OnDestroy } from '@angular/core'; import { Subscription } from 'rxjs'; import { BreadcrumbService } from './ixt-bread-crumb.service'; import { Breadcrumb } from './ixt-bread-crumb.interfaces';  @Component({   selector: 'ixt-bread-crumb',   templateUrl: './ixt-bread-crumb.component.html',   styleUrls: ['./ixt-bread-crumb.component.scss'] }) export class IxtBreadCrumbComponent implements OnInit, OnDestroy {   breadcrumbs: Breadcrumb[] = [];   private subscription: Subscription;    constructor(private breadcrumbService: BreadcrumbService) {}    ngOnInit() {     this.subscription = this.breadcrumbService.breadcrumbs$       .subscribe(breadcrumbs => this.breadcrumbs = breadcrumbs);   }    ngOnDestroy() {     this.subscription?.unsubscribe();   } }
|   |   |   +-- ixt-bread-crumb.interfaces.ts: export interface Breadcrumb {     label: string;     path: string;     icon?: string;     params?: { [key: string]: string };   }   
|   |   |   +-- ixt-bread-crumb.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { RouterModule } from '@angular/router'; import { IxtBreadCrumbComponent } from './ixt-bread-crumb.component'; import { BreadcrumbService } from './ixt-bread-crumb.service';  @NgModule({   declarations: [IxtBreadCrumbComponent],   imports: [CommonModule, RouterModule],   exports: [IxtBreadCrumbComponent],   providers: [BreadcrumbService] }) export class IxtBreadCrumbModule { }
|   |   |   -- ixt-bread-crumb.service.ts: import { Injectable } from '@angular/core'; import { Router, NavigationEnd, ActivatedRoute } from '@angular/router'; import { BehaviorSubject, filter } from 'rxjs'; import { Breadcrumb } from './ixt-bread-crumb.interfaces';  @Injectable() export class BreadcrumbService {   private breadcrumbs = new BehaviorSubject<Breadcrumb[]>([]);   breadcrumbs$ = this.breadcrumbs.asObservable();    constructor(private router: Router, private activatedRoute: ActivatedRoute) {     this.router.events.pipe(       filter(event => event instanceof NavigationEnd)     ).subscribe(() => {       const breadcrumbs = this.createBreadcrumbs(this.activatedRoute.root);       this.breadcrumbs.next(breadcrumbs);     });   }    private createBreadcrumbs(route: ActivatedRoute, url: string = '', breadcrumbs: Breadcrumb[] = []): Breadcrumb[] {     const children: ActivatedRoute[] = route.children;      if (children.length === 0) {       return breadcrumbs;     }      for (const child of children) {         const routeURL: string = child.snapshot.url.map(segment => segment.path).join('/');         if (routeURL !== '') {           url += `/${routeURL}`;         }                const label = child.snapshot.data['breadcrumb'];         if (label) {           breadcrumbs.push({             label,             path: url,             params: child.snapshot.params           });         }         // Recursively process child routes         this.createBreadcrumbs(child, url, breadcrumbs);       }       return breadcrumbs;   } }
|   |   +-- ixt-breadcrumb
|   |   |   +-- breakcrumb.component.html: 
|   |   |   +-- breakcrumb.component.scss: 
|   |   |   -- breakcrumb.component.ts: import { Component, OnInit } from '@angular/core'; import { BreadcrumbService, Breadcrumb } from './breadcrumb.service';  @Component({   selector: 'app-breadcrumb',   template: `     <nav *ngIf="breadcrumbs.length > 0">       <ul>         <li *ngFor="let breadcrumb of breadcrumbs">           <a [routerLink]="breadcrumb.url">{{ breadcrumb.label }}</a>         </li>       </ul>     </nav>   `,   styles: [] }) export class BreadcrumbComponent implements OnInit {   breadcrumbs: Breadcrumb[] = [];    constructor(private breadcrumbService: BreadcrumbService) {}    ngOnInit() {     this.breadcrumbService.breadcrumbs$.subscribe(breadcrumbs => {       this.breadcrumbs = breadcrumbs;     });   } } 
|   |   +-- ixt-button
|   |   |   +-- index.ts: export * from './ixt-button.component';  // Export any additional types or interfaces export type {   ButtonVariant,   ButtonSize,   ButtonType } from './ixt-button.component';
|   |   |   +-- ixt-button.component.html: <button    [type]="type"   [disabled]="disabled"   [attr.aria-disabled]="disabled"   [attr.aria-busy]="loading">      <!-- Loading Spinner -->   <span *ngIf="loading" class="ixt-button__spinner" aria-hidden="true">     <svg class="animate-spin h-5 w-5" viewBox="0 0 24 24">       <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none"/>       <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"/>     </svg>   </span>    <!-- Button Content -->   <span class="ixt-button__content" [class.invisible]="loading">     <ng-content></ng-content>   </span> </button>
|   |   |   +-- ixt-button.component.scss: // Base variables :root {     // Base colors     --ixt-primary: rgb(13, 110, 253);     --ixt-secondary: rgb(108, 117, 125);     --ixt-success: rgb(25, 135, 84);     --ixt-danger: rgb(220, 53, 69);     --ixt-warning: rgb(255, 193, 7);     --ixt-info: rgb(13, 202, 240);     --ixt-light: rgb(248, 249, 250);     --ixt-dark: rgb(33, 37, 41);        // Button specific variables     --ixt-button-border-radius: 4px;     --ixt-button-transition: all 0.15s ease-in-out;     --ixt-button-font-weight: 500;     --ixt-button-focus-width: 0.25rem;     --ixt-button-focus-opacity: 0.25;     --ixt-button-disabled-opacity: 0.65;   }      // Base button styles   .ixt-button {     display: inline-flex;     align-items: center;     justify-content: center;     position: relative;     padding: 0.375rem 0.75rem;     border-radius: var(--ixt-button-border-radius);     border: 1px solid transparent;     font-weight: var(--ixt-button-font-weight);     line-height: 1.5;     text-align: center;     vertical-align: middle;     cursor: pointer;     user-select: none;     transition: var(--ixt-button-transition);        &:focus {       outline: 0;       box-shadow: 0 0 0 var(--ixt-button-focus-width) rgba(var(--ixt-button-focus-color), var(--ixt-button-focus-opacity));     }        &--disabled,     &[disabled] {       opacity: var(--ixt-button-disabled-opacity);       pointer-events: none;     }        // Loading state     &--loading {       position: relative;       cursor: wait;          .button-content {         opacity: 0;       }          &::after {         content: '';         position: absolute;         width: 1rem;         height: 1rem;         border: 2px solid currentColor;         border-right-color: transparent;         border-radius: 50%;         animation: button-loading-spinner 0.75s linear infinite;       }     }   }      // Size variants   .ixt-button {     &--sm {       padding: 0.25rem 0.5rem;       font-size: 0.875rem;     }        &--md {       padding: 0.375rem 0.75rem;       font-size: 1rem;     }        &--lg {       padding: 0.5rem 1rem;       font-size: 1.25rem;     }   }      // Color variants   @mixin button-variant($background, $color: white) {     --ixt-button-focus-color: #{$background};          background-color: var(--ixt-#{$background});     color: $color;     border-color: var(--ixt-#{$background});        &:hover:not([disabled]) {       background-color: darken(var(--ixt-#{$background}), 7.5%);       border-color: darken(var(--ixt-#{$background}), 10%);     }        &:active:not([disabled]) {       background-color: darken(var(--ixt-#{$background}), 10%);       border-color: darken(var(--ixt-#{$background}), 12.5%);     }        // Outline variant     &.ixt-button--outline {       background-color: transparent;       color: var(--ixt-#{$background});          &:hover:not([disabled]) {         background-color: var(--ixt-#{$background});         color: $color;       }     }   }      // Generate variants   .ixt-button {     &--primary {       @include button-variant('primary');     }        &--secondary {       @include button-variant('secondary');     }        &--success {       @include button-variant('success');     }        &--danger {       @include button-variant('danger');     }        &--warning {       @include button-variant('warning', #212529);  // Dark text for warning     }        &--info {       @include button-variant('info');     }        &--light {       @include button-variant('light', #212529);     }        &--dark {       @include button-variant('dark');     }   }      // Loading spinner animation   @keyframes button-loading-spinner {     from {       transform: rotate(0deg);     }     to {       transform: rotate(360deg);     }   }
|   |   |   +-- ixt-button.component.ts: import { Component, Input, Output, EventEmitter, HostBinding, ElementRef } from '@angular/core'; import { coerceBooleanProperty } from '@angular/cdk/coercion';  export type ButtonVariant = 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark'; export type ButtonSize = 'sm' | 'md' | 'lg'; export type ButtonType = 'button' | 'submit' | 'reset';  @Component({   selector: 'ixt-button',   template: `     <span class="button-content">       <ng-content></ng-content>     </span>   `,   styleUrls: ['./ixt-button.component.scss'],   host: {     '[class.ixt-button]': 'true',     '[attr.disabled]': 'disabled || null',     '(click)': '_onClick($event)'   } }) export class IxtButtonComponent {   private _disabled = false;   private _loading = false;   private _outline = false;    @Input() variant: ButtonVariant = 'primary';   @Input() size: ButtonSize = 'md';   @Input() type: ButtonType = 'button';      @Input()   get disabled(): boolean {     return this._disabled;   }   set disabled(value: boolean) {     this._disabled = coerceBooleanProperty(value);   }    @Input()   get loading(): boolean {     return this._loading;   }   set loading(value: boolean) {     this._loading = coerceBooleanProperty(value);     this._disabled = this._loading;   }    @Input()   get outline(): boolean {     return this._outline;   }   set outline(value: boolean) {     this._outline = coerceBooleanProperty(value);   }    @Output() clicked = new EventEmitter<MouseEvent>();    @HostBinding('class')   get hostClasses(): string {     return [       `ixt-button--${this.variant}`,       `ixt-button--${this.size}`,       this.outline ? 'ixt-button--outline' : '',       this.loading ? 'ixt-button--loading' : '',       this.disabled ? 'ixt-button--disabled' : ''     ].filter(Boolean).join(' ');   }    constructor(private elementRef: ElementRef) {}    /** Handles click events and emits the clicked output only if button is not disabled */   _onClick(event: MouseEvent): void {     if (this.disabled || this.loading) {       event.preventDefault();       event.stopPropagation();       return;     }      this.clicked.emit(event);   }    /** Programmatically focuses the button */   focus(): void {     this.elementRef.nativeElement.focus();   }    /** Programmatically blurs the button */   blur(): void {     this.elementRef.nativeElement.blur();   } }
|   |   |   -- ixt-button.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtButtonComponent } from './ixt-button.component';  @NgModule({   declarations: [     IxtButtonComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtButtonComponent   ] }) export class IxtButtonModule { } 
|   |   +-- ixt-calendar
|   |   |   +-- calculators
|   |   |   |   +-- indian-holidays.ts: import { Holiday } from "../models/holiday.interface"; import { HolidayCalculator } from '../models/holiday-calculator';  export class IndianHolidayCalculator extends HolidayCalculator {     getHolidays(year: number): Holiday[] {       return [         { name: "Diwali", date: this.calculateDiwali(year), type: 'cultural' },         { name: "Holi", date: this.calculateHoli(year), type: 'cultural' },         { name: "Republic Day", date: new Date(year, 0, 26), type: 'cultural' },         { name: "Independence Day", date: new Date(year, 7, 15), type: 'cultural' }       ];     }        private calculateDiwali(year: number): Date {       // Placeholder - needs proper lunar calendar calculation       return new Date(year, 9, 24);     }        private calculateHoli(year: number): Date {       // Placeholder - needs proper lunar calendar calculation       return new Date(year, 2, 8);     }   }
|   |   |   |   +-- islamic-holidays.ts: import { Holiday } from "../models/holiday.interface"; import { HolidayCalculator } from '../models/holiday-calculator';  export class IslamicHolidayCalculator extends HolidayCalculator {     getHolidays(year: number): Holiday[] {       // Note: Islamic holidays follow lunar calendar - this needs more complex calculation       return [         { name: "Eid al-Fitr", date: this.calculateEidAlFitr(year), type: 'religious' },         { name: "Eid al-Adha", date: this.calculateEidAlAdha(year), type: 'religious' },         { name: "Islamic New Year", date: this.calculateIslamicNewYear(year), type: 'religious' }       ];     }        private calculateEidAlFitr(year: number): Date {       // Placeholder - needs proper Islamic calendar calculation       return new Date(year, 5, 15);     }        private calculateEidAlAdha(year: number): Date {       // Placeholder - needs proper Islamic calendar calculation       return new Date(year, 7, 22);     }        private calculateIslamicNewYear(year: number): Date {       // Placeholder - needs proper Islamic calendar calculation       return new Date(year, 8, 1);     }   }    
|   |   |   |   -- usa-holidays.ts: import { Holiday } from '../models/holiday.interface'; import { HolidayCalculator } from '../models/holiday-calculator';  export class USAHolidayCalculator extends HolidayCalculator {   getHolidays(year: number): Holiday[] {     return [       { name: "New Year's Day", date: new Date(year, 0, 1), type: 'federal' },       { name: "Martin Luther King Jr. Day", date: this.nthWeekdayOfMonth(year, 0, 1, 3), type: 'federal' },       { name: "Presidents Day", date: this.nthWeekdayOfMonth(year, 1, 1, 3), type: 'federal' },       { name: "Easter", date: this.calculateEaster(year), type: 'federal' },       { name: "Memorial Day", date: this.lastWeekdayOfMonth(year, 4, 1), type: 'federal' },       { name: "Independence Day", date: new Date(year, 6, 4), type: 'federal' },       { name: "Labor Day", date: this.nthWeekdayOfMonth(year, 8, 1, 1), type: 'federal' },       { name: "Columbus Day", date: this.nthWeekdayOfMonth(year, 9, 1, 2), type: 'federal' },       { name: "Veterans Day", date: new Date(year, 10, 11), type: 'federal' },       { name: "Thanksgiving", date: this.nthWeekdayOfMonth(year, 10, 4, 4), type: 'federal' },       { name: "Christmas", date: new Date(year, 11, 25), type: 'federal' }     ];   }    private calculateEaster(year: number): Date {     const a = year % 19;     const b = Math.floor(year / 100);     const c = year % 100;     const d = Math.floor(b / 4);     const e = b % 4;     const f = Math.floor((b + 8) / 25);     const g = Math.floor((b - f + 1) / 3);     const h = (19 * a + b - d - g + 15) % 30;     const i = Math.floor(c / 4);     const k = c % 4;     const l = (32 + 2 * e + 2 * i - h - k) % 7;     const m = Math.floor((a + 11 * h + 22 * l) / 451);     const month = Math.floor((h + l - 7 * m + 114) / 31) - 1;     const day = ((h + l - 7 * m + 114) % 31) + 1;          return new Date(year, month, day);   } }
|   |   |   +-- ixt-calendar.component.html: <div class="calendar-container">     <div class="calendar-controls">       <button (click)="previousMonth()">&lt;</button>       <select [formControl]="monthControl">         <option *ngFor="let month of months; let i = index" [value]="i">           {{month}}         </option>       </select>       <input          type="number"          [formControl]="yearControl"         [min]="0"         [max]="2100"         (blur)="validateYear()"       >       <button (click)="nextMonth()">&gt;</button>     </div>        <div class="calendar-grid">       <div class="weekday-header" *ngFor="let day of weekDays">{{day}}</div>       <div          *ngFor="let day of calendarDays"          class="calendar-day"         [class.weekend]="day.isWeekend"         [class.holiday]="day.holidays.length > 0"       >         <div class="date">{{day.date.getDate()}}</div>         <div class="holiday-name" *ngFor="let holiday of day.holidays">           {{holiday.name}}         </div>       </div>     </div>   </div>   
|   |   |   +-- ixt-calendar.component.scss: .calendar-container {     max-width: 800px;     margin: 0 auto;   }    .calendar-controls {     display: flex;     gap: 1rem;     margin-bottom: 1rem;     align-items: center;   }    .calendar-grid {     display: grid;     grid-template-columns: repeat(7, 1fr);     gap: 4px;   }    .weekday-header {     padding: 0.5rem;     text-align: center;     font-weight: bold;   }    .calendar-day {     aspect-ratio: 1;     padding: 0.5rem;     border: 1px solid #ccc;     min-height: 80px;   }    .weekend {     background-color: #f5f5f5;   }    .holiday {     background-color: #e8f4f8;   }    .holiday-name {     font-size: 0.8rem;     color: #666;   }    .date {     font-weight: bold;   } 
|   |   |   +-- ixt-calendar.component.ts: import { Component, OnInit } from '@angular/core'; import { FormControl } from '@angular/forms'; import { CalendarDay } from './ixt-calendar.interfaces'; import { USAHolidayCalculator } from './calculators/usa-holidays'; import { IndianHolidayCalculator } from './calculators/indian-holidays'; import { IslamicHolidayCalculator } from './calculators/islamic-holidays'; import { Holiday } from './models/holiday.interface';  @Component({   selector: 'ixt-calendar',   templateUrl: './ixt-calendar.component.html',   styleUrls: ['./ixt-calendar.component.scss'] }) export class IxtCalendarComponent implements OnInit {   private holidayCalculators = [     new USAHolidayCalculator(),     new IslamicHolidayCalculator(),     new IndianHolidayCalculator()   ];    months = [     'January', 'February', 'March', 'April', 'May', 'June',     'July', 'August', 'September', 'October', 'November', 'December'   ];      weekDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];   calendarDays: CalendarDay[] = [];   monthControl = new FormControl(0);   yearControl = new FormControl(new Date().getFullYear());    private holidays: Holiday[] = [];    ngOnInit() {     this.monthControl.valueChanges.subscribe(() => this.generateCalendar());     this.yearControl.valueChanges.subscribe(() => {       this.updateHolidays();       this.generateCalendar();     });     this.updateHolidays();     this.generateCalendar();   }    private updateHolidays() {     this.holidays = this.holidayCalculators.flatMap(       calc => calc.getHolidays(this.yearControl.value!)     );   }    generateCalendar() {     const year = this.yearControl.value!;     const month = this.monthControl.value!;     const firstDay = new Date(year, month, 1);     const lastDay = new Date(year, month + 1, 0);          this.calendarDays = [];          // Add padding days from previous month     for (let i = 0; i < firstDay.getDay(); i++) {       const date = new Date(year, month, -i);       this.calendarDays.unshift(this.createCalendarDay(date));     }          // Add days of current month     for (let date = new Date(firstDay); date <= lastDay; date.setDate(date.getDate() + 1)) {       this.calendarDays.push(this.createCalendarDay(new Date(date)));     }          // Add padding days from next month     const remainingDays = 42 - this.calendarDays.length;     for (let i = 1; i <= remainingDays; i++) {       const date = new Date(year, month + 1, i);       this.calendarDays.push(this.createCalendarDay(date));     }   }    private createCalendarDay(date: Date): CalendarDay {     return {       date,       isWeekend: date.getDay() === 0 || date.getDay() === 6,       holidays: this.holidays.filter(h =>          h.date.getDate() === date.getDate() &&          h.date.getMonth() === date.getMonth()       )     };   }    previousMonth() {     if (this.monthControl.value === 0) {       this.monthControl.setValue(11);       this.yearControl.setValue(this.yearControl.value! - 1);     } else {       this.monthControl.setValue(this.monthControl.value! - 1);     }   }    nextMonth() {     if (this.monthControl.value === 11) {       this.monthControl.setValue(0);       this.yearControl.setValue(this.yearControl.value! + 1);     } else {       this.monthControl.setValue(this.monthControl.value! + 1);     }   }    validateYear() {     const year = this.yearControl.value!;     if (year < 0) this.yearControl.setValue(0);     if (year > 2100) this.yearControl.setValue(2100);   } }
|   |   |   +-- ixt-calendar.interfaces.ts: import { Holiday } from "./models/holiday.interface";  export interface CalendarDay {   date: Date;   isWeekend: boolean;   holidays: Holiday[]; } 
|   |   |   +-- ixt-calendar.module.ts: // ixt-calendar.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { ReactiveFormsModule } from '@angular/forms'; import { IxtCalendarComponent } from './ixt-calendar.component';  @NgModule({   declarations: [IxtCalendarComponent],   imports: [CommonModule, ReactiveFormsModule],   exports: [IxtCalendarComponent] }) export class IxtCalendarModule { }
|   |   |   -- models
|   |   |      +-- holiday-calculator.ts: import { Holiday } from "./holiday.interface";    export abstract class HolidayCalculator {     abstract getHolidays(year: number): Holiday[];          protected nthWeekdayOfMonth(year: number, month: number, weekday: number, n: number): Date {       const date = new Date(year, month, 1);       while (date.getDay() !== weekday) {         date.setDate(date.getDate() + 1);       }       date.setDate(date.getDate() + (n - 1) * 7);       return date;     }        protected lastWeekdayOfMonth(year: number, month: number, weekday: number): Date {       const date = new Date(year, month + 1, 0);       while (date.getDay() !== weekday) {         date.setDate(date.getDate() - 1);       }       return date;     }   }    
|   |   |      -- holiday.interface.ts: export interface Holiday {     name: string;     date: Date;     type: 'federal' | 'religious' | 'cultural';   }
|   |   +-- ixt-dialog
|   |   |   +-- dynamic-dialog-content.component.ts: import { Component, Inject } from '@angular/core';  @Component({   selector: 'app-dynamic-dialog-content',   template: `     <div class="p-4">       <h3>Dynamic Content</h3>       <p>{{ data.message }}</p>       <div class="mt-4">         <button            (click)="doSomething()"            class="px-4 py-2 bg-blue-500 text-white rounded">           Do Something         </button>       </div>     </div>   ` }) export class DynamicDialogContentComponent {   constructor(@Inject('dialogData') public data: any) {}    doSomething() {     console.log('Action from dynamic component');   } }
|   |   |   +-- ixt-dialog.component.html: <div    class="ixt-dialog-container"    [class.is-open]="isOpen"   [class.is-modal]="isModal"   (click)="onBackdropClick($event)"   (keydown)="onKeydown($event)">      <div      #dialogElement     class="ixt-dialog"      role="dialog"     [attr.aria-modal]="isModal"     aria-labelledby="dialog-title"     tabindex="-1">      <!-- Header -->     <div        class="ixt-dialog__header"       [class]="getHeaderClass()"       [ngStyle]="getHeaderStyle()">       <h2          *ngIf="title"         class="ixt-dialog__title"          id="dialog-title">         {{ title }}       </h2>       <button          *ngIf="showClose"         type="button"         class="ixt-dialog__close"         aria-label="Close dialog"         (click)="close()">         <span aria-hidden="true">&times;</span>       </button>     </div>      <!-- Content -->     <div class="ixt-dialog__content">       <!-- String content -->       <ng-container *ngIf="config.content && !isTemplateRef(config.content) && !isComponent(config.content)">         {{ config.content }}       </ng-container>        <!-- Template content -->       <ng-container *ngIf="isTemplateRef(config.content)">         <ng-container            [ngTemplateOutlet]="config.content"           [ngTemplateOutletContext]="config.contentContext">         </ng-container>       </ng-container>        <!-- Dynamic component content -->       <ng-container *ngIf="isComponent(config.content)">         <ng-container *ngComponentOutlet="config.content;                                          injector: createInjector(config.contentContext)">         </ng-container>       </ng-container>        <!-- Default content projection -->       <ng-content></ng-content>     </div>      <!-- Footer -->     <div class="ixt-dialog__footer">       <!-- Footer content projection -->       <ng-content select="[ixtDialogFooter]"></ng-content>              <!-- Default buttons if no footer content is projected -->       <ng-container *ngIf="!hasFooterContent">         <ng-container *ngIf="config.buttons && config.buttons.length">           <button              *ngFor="let button of config.buttons"             type="button"             class="ixt-dialog__button"             [ngStyle]="getButtonStyle(button.variant)"             (click)="handleButtonClick(button)">             {{ button.text }}           </button>         </ng-container>       </ng-container>     </div>   </div> </div>
|   |   |   +-- ixt-dialog.component.scss: // src/components/ixt-dialog/ixt-dialog.component.scss  // Dialog theme variables with defaults $dialog-primary-color: #4169E1 !default; $dialog-primary-text: #ffffff !default; $dialog-secondary-color: #6c757d !default; $dialog-secondary-text: #ffffff !default; $dialog-success-color: #28a745 !default; $dialog-success-text: #ffffff !default; $dialog-danger-color: #dc3545 !default; $dialog-danger-text: #ffffff !default; $dialog-warning-color: #ffc107 !default; $dialog-warning-text: #000000 !default; $dialog-info-color: #17a2b8 !default; $dialog-info-text: #ffffff !default; $dialog-light-color: #f8f9fa !default; $dialog-light-text: #000000 !default; $dialog-dark-color: #343a40 !default; $dialog-dark-text: #ffffff !default; $dialog-default-color: #ffffff !default; $dialog-default-text: #000000 !default;  // Container .ixt-dialog-container {   display: none;   position: fixed;   top: 0;   left: 0;   width: 100%;   height: 100%;   z-index: 1050;   overflow: hidden;   outline: 0;    &.is-open {     display: flex;     align-items: center;     justify-content: center;   }    &.is-modal {     background-color: rgba(0, 0, 0, 0.5);   } }  // Dialog .ixt-dialog {   position: relative;   width: 100%;   max-width: 500px;   margin: 1rem;   background-color: white;   border-radius: 0.3rem;   box-shadow: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.15);   transform: translate(0, 0);   transition: transform 0.3s ease-out;    &:focus {     outline: none;   } }  // Header variants using CSS classes .ixt-dialog__header {   display: flex;   align-items: center;   justify-content: space-between;   padding: 1rem;   border-bottom: 1px solid rgba(0, 0, 0, 0.1);   border-top-left-radius: 0.3rem;   border-top-right-radius: 0.3rem;    &.ixt-dialog__header--primary {     background-color: $dialog-primary-color;     color: $dialog-primary-text;   }    &.ixt-dialog__header--secondary {     background-color: $dialog-secondary-color;     color: $dialog-secondary-text;   }    &.ixt-dialog__header--success {     background-color: $dialog-success-color;     color: $dialog-success-text;   }    &.ixt-dialog__header--danger {     background-color: $dialog-danger-color;     color: $dialog-danger-text;   }    &.ixt-dialog__header--warning {     background-color: $dialog-warning-color;     color: $dialog-warning-text;   }    &.ixt-dialog__header--info {     background-color: $dialog-info-color;     color: $dialog-info-text;   }    &.ixt-dialog__header--light {     background-color: $dialog-light-color;     color: $dialog-light-text;   }    &.ixt-dialog__header--dark {     background-color: $dialog-dark-color;     color: $dialog-dark-text;   }    &.ixt-dialog__header--default {     background-color: $dialog-default-color;     color: $dialog-default-text;   } }  .ixt-dialog__title {   margin: 0;   font-size: 1.25rem;   line-height: 1.5; }  .ixt-dialog__close {   padding: 0.5rem;   margin: -0.5rem -0.5rem -0.5rem auto;   background: transparent;   border: 0;   font-size: 1.5rem;   line-height: 1;   color: inherit;   opacity: 0.7;   cursor: pointer;   transition: opacity 0.15s;    &:hover {     opacity: 1;   }    &:focus {     outline: none;     box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);   } }  // Content .ixt-dialog__content {   position: relative;   padding: 1rem;   flex: 1 1 auto;   max-height: calc(100vh - 210px);   overflow-y: auto; }  // Footer .ixt-dialog__footer {   display: flex;   align-items: center;   justify-content: flex-end;   padding: 1rem;   border-top: 1px solid rgba(0, 0, 0, 0.1);   border-bottom-left-radius: 0.3rem;   border-bottom-right-radius: 0.3rem;    > * + * {     margin-left: 0.5rem;   } }  // Animation states .ixt-dialog-container:not(.is-open) .ixt-dialog {   transform: translate(0, -25%);   opacity: 0; }  // Utility class for body :host-context(body.ixt-dialog-open) {   overflow: hidden; }  // Responsive adjustments @media (max-width: 576px) {   .ixt-dialog {     margin: 0.5rem;   }    .ixt-dialog__content {     max-height: calc(100vh - 180px);   } }
|   |   |   +-- ixt-dialog.component.ts: import {    Component,    Input,    Output,    EventEmitter,    TemplateRef,    Type,    ViewChild,    ElementRef,    OnInit,    OnDestroy  } from '@angular/core'; import { baseThemeColors } from '../theme/theme.colors'; import { ThemeVariant, ThemeColors } from '../theme/theme.types'; import { IxtDialogButton, IxtDialogConfig } from './ixt-dialog.interfaces';    @Component({   selector: 'ixt-dialog',   templateUrl: './ixt-dialog.component.html',   styleUrls: ['./ixt-dialog.component.scss'] }) export class IxtDialogComponent implements OnInit, OnDestroy {   @Input() config: IxtDialogConfig = {};   @Input() isOpen = false;   @Output() isOpenChange = new EventEmitter<boolean>();   @Output() closed = new EventEmitter<void>();      @ViewChild('dialogElement') dialogElement!: ElementRef;      // Default values   public variant: ThemeVariant = 'default';   public title: string = '';   public isModal: boolean = true;   public showClose: boolean = true;   public backdropClose: boolean = true;      // Theme-related properties   public themeColors = baseThemeColors;      private previouslyFocusedElement: HTMLElement | null = null;   private focusableElements: HTMLElement[] = [];    public hasFooterContent = false;      constructor() {}      ngOnInit() {     this.initializeConfig();   }      ngOnDestroy() {     this.restoreFocus();   }      private initializeConfig() {     if (this.config) {       this.variant = this.config.variant || 'default';       this.title = this.config.title || '';       this.isModal = this.config.isModal ?? true;       this.showClose = this.config.showClose ?? true;       this.backdropClose = this.config.backdropClose ?? true;     }   }      public open() {     this.isOpen = true;     this.isOpenChange.emit(true);          if (this.isModal) {       this.setupModal();     }   }      public close() {     this.isOpen = false;     this.isOpenChange.emit(false);     this.closed.emit();          if (this.isModal) {       this.cleanupModal();     }   }      private setupModal() {     // Store currently focused element     this.previouslyFocusedElement = document.activeElement as HTMLElement;          // Set up focus trap     setTimeout(() => {       this.focusableElements = Array.from(         this.dialogElement.nativeElement.querySelectorAll(           'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'         )       );              if (this.focusableElements.length) {         this.focusableElements[0].focus();       }     });          // Add body class to prevent scrolling     document.body.classList.add('ixt-dialog-open');   }      private cleanupModal() {     this.restoreFocus();     document.body.classList.remove('ixt-dialog-open');   }      private restoreFocus() {     if (this.previouslyFocusedElement) {       this.previouslyFocusedElement.focus();       this.previouslyFocusedElement = null;     }   }      public onBackdropClick(event: MouseEvent) {     if (       this.backdropClose &&       event.target === event.currentTarget     ) {       this.close();     }   }      public onKeydown(event: KeyboardEvent) {     if (!this.isModal) return;          if (event.key === 'Escape') {       this.close();       return;     }          if (event.key === 'Tab') {       if (!this.focusableElements.length) return;              const firstElement = this.focusableElements[0];       const lastElement = this.focusableElements[this.focusableElements.length - 1];              if (event.shiftKey && document.activeElement === firstElement) {         event.preventDefault();         lastElement.focus();       } else if (!event.shiftKey && document.activeElement === lastElement) {         event.preventDefault();         firstElement.focus();       }     }   }      public isTemplateRef(content: any): content is TemplateRef<any> {     return content instanceof TemplateRef;   }      public isComponent(content: any): content is Type<any> {     return content instanceof Type;   }    // Theme-related methods   public getHeaderClass(): string {     return `ixt-dialog__header--${this.variant}`;   }    public getHeaderStyle(): { [key: string]: string } {     const variantColors = this.themeColors[this.variant];     return {       backgroundColor: variantColors.base,       color: variantColors.text     };   }    public getButtonStyle(variant: ThemeVariant = this.variant): { [key: string]: string } {     const variantColors = this.themeColors[variant];     return {       backgroundColor: variantColors.base,       color: variantColors.text     };   }  // ixt-dialog.component.ts public handleButtonClick(button: IxtDialogButton): void {   // Support both action and callback   if (button.action) {     button.action();   }   if (button.callback) {     button.callback();   }      if (button.close !== false) {  // Close by default unless explicitly set to false     this.close();   } }    public createInjector(context: any): any {     // This is needed for dynamic component content     return {       provide: 'dialogData',       useValue: context     };   }  }
|   |   |   +-- ixt-dialog.index.ts: export * from './ixt-dialog.module'; export * from './dynamic-dialog-content.component'; export type { IxtDialogButton, IxtDialogConfig } from './ixt-dialog.interfaces'; export { IxtDialogComponent } from './ixt-dialog.component'; export { IxtDialogService } from './ixt-dialog.service';
|   |   |   +-- ixt-dialog.interfaces.ts: // ixt-dialog.interfaces.ts import { Type, TemplateRef } from '@angular/core'; import { ThemeVariant } from '../theme/theme.types';  export enum DialogButton {   OK = 1,   YES = 2,   NO = 4, }  export enum DialogType {   Info = 'info',   Warning = 'warning',   Error = 'error',   Success = 'success',   Confirm = 'confirm',   Custom = 'custom',   Question = 'question' }  // ixt-dialog.interfaces.ts export interface IxtDialogButton {   text: string;   variant?: ThemeVariant;  // Remove string type, only allow ThemeVariant   action?: () => void;   callback?: () => void;   type?: 'primary' | 'secondary' | 'danger';   close?: boolean; }  export interface IxtDialogRef {   close: () => void;   isOpen: boolean; }  // export interface IxtDialogConfig { //   title?: string; //   message?: string; //   content?: string | TemplateRef<any> | Type<any>; //   contentContext?: any; //   variant?: ThemeVariant; //   buttons?: IxtDialogButton[]; //   cancelText?: string; //   okText?: string; //   type?: DialogType; //   data?: any; //   isModal?: boolean; //   showClose?: boolean; //   backdropClose?: boolean; // }  // ixt-dialog.interfaces.ts export interface IxtDialogConfig {   title?: string;   message?: string;   content?: string | TemplateRef<any> | Type<any>;   contentContext?: any;   variant?: ThemeVariant;   buttons?: IxtDialogButton[];   cancelText?: string;   okText?: string;   type?: DialogType;   data?: any;   isModal?: boolean;   showClose?: boolean;   backdropClose?: boolean;   showCancel?: boolean;  // Added this }  export interface IxtDialogResult<T = any> {   confirmed: boolean;   data?: T; }
|   |   |   +-- ixt-dialog.module.ts: // ixt-dialog.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { MatButtonModule } from '@angular/material/button'; import { MatIconModule } from '@angular/material/icon'; import { IxtDialogComponent } from './ixt-dialog.component'; import { IxtDialogService } from './ixt-dialog.service';  // Add this import { DynamicDialogContentComponent } from './dynamic-dialog-content.component';  @NgModule({   declarations: [     IxtDialogComponent,     DynamicDialogContentComponent   ],   imports: [     CommonModule,     MatButtonModule,     MatIconModule   ],   exports: [IxtDialogComponent],   providers: [IxtDialogService]  // Add this }) export class IxtDialogModule { }
|   |   |   -- ixt-dialog.service.ts: // ixt-dialog.service.ts import {    Injectable,    ComponentRef,    ApplicationRef,    ComponentFactoryResolver,    Injector,    EmbeddedViewRef,    Type  } from '@angular/core'; import { IxtDialogComponent } from './ixt-dialog.component'; import {    IxtDialogConfig,    IxtDialogRef,    DialogType,    IxtDialogResult  } from './ixt-dialog.interfaces'; import { Observable, Subject } from 'rxjs'; import { IxtDialogButton } from 'dist/ixtlan/components/ixt-dialog/ixt-dialog.interfaces';  @Injectable({   providedIn: 'root' }) export class IxtDialogService {   private dialogComponentRef: ComponentRef<IxtDialogComponent> | null = null;    constructor(     private componentFactoryResolver: ComponentFactoryResolver,     private appRef: ApplicationRef,     private injector: Injector   ) {}    open(config: IxtDialogConfig): IxtDialogRef {     this.closeExisting();      const componentRef = this.componentFactoryResolver       .resolveComponentFactory(IxtDialogComponent)       .create(this.injector);      componentRef.instance.config = config;     componentRef.instance.isOpen = true;      componentRef.instance.closed.subscribe(() => {       this.close();     });      this.appRef.attachView(componentRef.hostView);     const domElem = (componentRef.hostView as EmbeddedViewRef<any>).rootNodes[0];     document.body.appendChild(domElem);      this.dialogComponentRef = componentRef;      return {       close: () => this.close(),       isOpen: true     };   }    close(): void {     if (this.dialogComponentRef) {       this.appRef.detachView(this.dialogComponentRef.hostView);       this.dialogComponentRef.destroy();       this.dialogComponentRef = null;     }   }    private closeExisting(): void {     if (this.dialogComponentRef) {       this.close();     }   }    confirm = (options: IxtDialogConfig): IxtDialogRef => {     const defaultButtons: IxtDialogButton[] = [       {         text: options.okText || 'Confirm',         variant: options.variant || 'primary',         callback: () => true,         close: true       }     ];        return this.open({       ...options,       buttons: options.buttons || defaultButtons     });   }    alert(options: Omit<IxtDialogConfig, 'buttons'>): IxtDialogRef {     return this.open({       ...options,       variant: options.variant || 'primary',       buttons: [         {           text: 'OK',           variant: options.variant || 'primary',           close: true         }       ]     });   }    show<T = any>(config: IxtDialogConfig): Observable<IxtDialogResult<T>> {     const result = new Subject<IxtDialogResult<T>>();          this.open({       title: config.title,       message: config.message,       variant: 'primary',       buttons: [         {           text: config.cancelText || 'Cancel',           variant: 'light',           close: true,           action: () => {             result.next({ confirmed: false });             result.complete();           }         },         {           text: config.okText || 'OK',           variant: 'primary',           close: true,           action: () => {             result.next({ confirmed: true, data: config.data });             result.complete();           }         }       ]     });      return result.asObservable();   } }
|   |   +-- ixt-expression-builder
|   |   |   +-- ixt-expression-builder.component.html: <!-- ixt-expression-builder.component.html --> <div class="expression-builder">   <div class="group-container">     <select [(ngModel)]="group.operator" class="group-operator">       <option value="and">AND</option>       <option value="or">OR</option>     </select>      <div class="expressions-list">       <div *ngFor="let node of rootGroup.children; let i = index" class="expression-row">         <div *ngIf="node.type === 'expression'" class="expression-container">           <select [(ngModel)]="node.field" class="field-select">             <option value="">Select Field</option>             <option *ngFor="let field of fields" [value]="field.id">               {{field.label}}             </option>           </select>            <select [(ngModel)]="node.operator" class="operator-select">             <option value="">Select Operator</option>             <option *ngFor="let op of getOperators(node.field)" [value]="op.id">               {{op.label}}             </option>           </select>            <ng-container [ngSwitch]="getOperatorType(node.operator)">             <input *ngSwitchCase="'single'"                     type="text"                     [(ngModel)]="node.value"                     class="value-input">                          <div *ngSwitchCase="'multiple'" class="multi-value-container">               <div *ngFor="let val of node.values; let j = index" class="multi-value-item">                 <input type="text" [(ngModel)]="node.values[j]">                 <button (click)="removeValue(node, j)" class="remove-btn">×</button>               </div>               <button (click)="addValue(node)" class="add-value">+ Add Value</button>             </div>           </ng-container>            <button (click)="removeExpression(i)" class="remove-btn">×</button>         </div>          <div *ngIf="node.type === 'group'" class="nested-group">           <ixt-expression-builder             [group]="node"             [level]="level + 1"             (groupChange)="onChildGroupChange(i, $event)">           </ixt-expression-builder>         </div>       </div>     </div>      <div class="action-buttons">       <button (click)="addExpression()" class="add-btn">Add Expression</button>       <button (click)="addGroup()" class="add-btn">Add Group</button>     </div>   </div> </div>
|   |   |   +-- ixt-expression-builder.component.scss: /* ixt-expression-builder.component.scss */ .expression-builder {   padding: 1rem;    .group-container {     border-left: 2px solid #ccc;     margin-left: 1rem;     padding-left: 1rem;      &:first-child {       border-left: none;       margin-left: 0;     }   }    .expression-row {     margin: 0.5rem 0;   }    .expression-container {     display: flex;     gap: 0.5rem;     align-items: center;      select, input {       padding: 0.25rem 0.5rem;       border: 1px solid #ccc;       border-radius: 4px;       min-width: 120px;     }      .field-select, .operator-select {       flex: 0 0 auto;     }      .value-input {       flex: 1 1 auto;     }   }    .multi-value-container {     display: flex;     flex-direction: column;     gap: 0.25rem;     flex: 1 1 auto;      .multi-value-item {       display: flex;       gap: 0.25rem;        input {         flex: 1 1 auto;       }     }   }    .action-buttons {     margin-top: 1rem;     display: flex;     gap: 0.5rem;   }    button {     padding: 0.25rem 0.5rem;     border: 1px solid #ccc;     border-radius: 4px;     background: white;     cursor: pointer;      &:hover {       background: #f0f0f0;     }      &.add-btn {       color: #0066cc;       border-color: #0066cc;     }   }    .remove-btn {     padding: 0.25rem 0.5rem;     color: red;     border: none;     background: transparent;   }    .group-operator {     margin-bottom: 0.5rem;     font-weight: 500;   } }
|   |   |   +-- ixt-expression-builder.component.ts: // ixt-expression-builder.component.ts import { Component, Input, Output, EventEmitter, OnInit } from '@angular/core'; import { Field, Operator, Expression, ExpressionGroup } from './ixt-expression-builder.interfaces';  @Component({   selector: 'ixt-expression-builder',   templateUrl: './ixt-expression-builder.component.html',   styleUrls: ['./ixt-expression-builder.component.scss'], }) export class IxtExpressionBuilderComponent implements OnInit {   @Input() group: ExpressionGroup = {     type: 'group',     operator: 'and',     children: []   };    @Input() level = 0;    @Output() groupChange = new EventEmitter<ExpressionGroup>();    fields: Field[] = [     { id: 'al', label: 'Airline', type: 'text' },     { id: 'base', label: 'Base', type: 'text' },     { id: 'ref', label: 'Reference', type: 'text' }   ];    operators: Record<string, Operator[]> = {     text: [       { id: 'eq', label: '=', type: 'single' },       { id: 'neq', label: '≠', type: 'single' },       { id: 'in', label: 'IN', type: 'multiple' },       { id: 'not_in', label: 'NOT IN', type: 'multiple' }     ]   };    get rootGroup(): ExpressionGroup {     return this.group;   }    ngOnInit(): void {     if (!this.group || this.group.children.length === 0) {       this.group = {         type: 'group',         operator: 'and',         children: [           {             type: 'expression',             field: 'al',             operator: 'eq',             value: 'AA',             values: []           },           {             type: 'group',             operator: 'or',             children: [               {                 type: 'expression',                 field: 'base',                 operator: 'in',                 value: '',                 values: ['DFW', 'ORD', 'MIA']               },               {                 type: 'expression',                 field: 'ref',                 operator: 'in',                 value: '',                 values: ['DFW', 'ORD', 'MIA']               }             ]           }         ]       };       this.emitChange(); // Notify parent of the initial value     }   }    // Rest of your code remains the same...   addExpression(): void {     const newExpression: Expression = {       type: 'expression',       field: '',       operator: '',       value: '',       values: []     };     this.group.children.push(newExpression);     this.emitChange();   }    addGroup(): void {     const newGroup: ExpressionGroup = {       type: 'group',       operator: 'and',       children: []     };     this.group.children.push(newGroup);     this.emitChange();   }    removeExpression(index: number): void {     this.group.children.splice(index, 1);     this.emitChange();   }    getOperators(fieldId: string): Operator[] {     const field = this.fields.find(f => f.id === fieldId);     return field ? this.operators[field.type] || [] : [];   }    getOperatorType(operatorId: string): 'single' | 'multiple' | null {     for (const operators of Object.values(this.operators)) {       const operator = operators.find(op => op.id === operatorId);       if (operator) {         return operator.type;       }     }     return null;   }    addValue(expression: Expression): void {     if (!expression.values) {       expression.values = [];     }     expression.values.push('');     this.emitChange();   }    removeValue(expression: Expression, index: number): void {     if (expression.values) {       expression.values.splice(index, 1);       this.emitChange();     }   }    onChildGroupChange(index: number, childGroup: ExpressionGroup): void {     this.group.children[index] = childGroup;     this.emitChange();   }    toJsonLogic(): any {     return this.convertToJsonLogic(this.group);   }    private convertToJsonLogic(node: Expression | ExpressionGroup): any {     if (node.type === 'expression') {       if (node.operator === 'in' || node.operator === 'not_in') {         return {           [node.operator === 'in' ? 'in' : '!in']: [             { var: node.field },             node.values || []           ]         };       }       return {         [node.operator]: [           { var: node.field },           node.value         ]       };     }      if (node.children.length === 0) return true;     if (node.children.length === 1) {       return this.convertToJsonLogic(node.children[0]);     }      return {       [node.operator]: node.children.map(child => this.convertToJsonLogic(child))     };   }    private emitChange(): void {     this.groupChange.emit(this.group);   }    updateValue(expression: Expression, index: number, value: string): void {     if (!expression.values) {       expression.values = [];     }     expression.values[index] = value;     this.emitChange();   } }
|   |   |   +-- ixt-expression-builder.interfaces.ts: // ixt-expression-builder.interfaces.ts export interface Field {     id: string;     label: string;     type: string;   }      export interface Operator {     id: string;     label: string;     type: 'single' | 'multiple';   }      // ixt-expression-builder.interfaces.ts - Update the Expression interface   export interface Expression {     type: 'expression';     field: string;     operator: string;     value: string;     values: string[];   }      export interface ExpressionGroup {     type: 'group';     operator: 'and' | 'or';     children: (Expression | ExpressionGroup)[];   }
|   |   |   -- ixt-expression-builder.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtExpressionBuilderComponent } from './ixt-expression-builder.component';  @NgModule({   declarations: [     IxtExpressionBuilderComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtExpressionBuilderComponent   ] }) export class IxtExpressionBuilderModule { } 
|   |   +-- ixt-form
|   |   |   +-- ixt-form.component.html: <p>ixt-form works!</p> 
|   |   |   +-- ixt-form.component.scss: 
|   |   |   +-- ixt-form.component.ts: import { Component } from '@angular/core';  @Component({   selector: 'ixt-ixt-form',   templateUrl: './ixt-form.component.html',   styleUrls: ['./ixt-form.component.scss'] }) export class IxtFormComponent {  } 
|   |   |   -- ixt-form.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtFormComponent } from './ixt-form.component';  @NgModule({   declarations: [     IxtFormComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtFormComponent   ] }) export class IxtFormModule { } 
|   |   +-- ixt-geo
|   |   |   +-- index.ts: 
|   |   |   +-- ixt-geo.component.html: 
|   |   |   +-- ixt-geo.component.ts: // ixt-geo.component.ts import {      Component,      Input,      Output,      EventEmitter,      OnInit,      OnDestroy,      ElementRef,      ViewChild,      NgZone,      ChangeDetectorRef,     ChangeDetectionStrategy   } from '@angular/core';   import { Subject, BehaviorSubject } from 'rxjs';   import { takeUntil, distinctUntilChanged, debounceTime } from 'rxjs/operators';   import { GeoService } from './geo.service';   import { ZoomHandler } from './zoom.handler';   import {      GeoState,      GeoOptions,      RenderContext,      GeoFeature    } from './types';      @Component({     selector: 'ixt-geo',     template: '<div #container class="geo-container"></div>',     changeDetection: ChangeDetectionStrategy.OnPush   })   export class IxtGeoComponent implements OnInit, OnDestroy {     @ViewChild('container', { static: true }) containerRef!: ElementRef;          @Input() set state(value: GeoState) {       this.stateSubject.next(value);     }          @Input() options: GeoOptions = {       projection: 'mercator',       interactive: true,       maxZoom: 8,       minZoom: 1,       fitPadding: 50     };        @Output() viewportChange = new EventEmitter<GeoState['viewport']>();     @Output() selectionChange = new EventEmitter<Set<string>>();     @Output() highlightChange = new EventEmitter<string | undefined>();        private context!: RenderContext;     private zoomHandler!: ZoomHandler;     private stateSubject = new BehaviorSubject<GeoState | null>(null);     private readonly destroy$ = new Subject<void>();     private featureGroup!: d3.Selection<SVGGElement, unknown, null, undefined>;        constructor(       private geoService: GeoService,       private zone: NgZone,       private cd: ChangeDetectorRef     ) {}        ngOnInit(): void {       this.initializeMap();       this.setupStateSubscription();     }        ngOnDestroy(): void {       this.destroy$.next();       this.destroy$.complete();     }        private initializeMap(): void {       const container = this.containerRef.nativeElement;              this.zone.runOutsideAngular(() => {         this.context = this.geoService.createRenderContext(container, this.options);                  this.featureGroup = this.context.svg           .append('g')           .attr('class', 'features');            this.zoomHandler = new ZoomHandler(           this.context,           transform => this.handleZoom(transform)         );       });     }        private setupStateSubscription(): void {       this.stateSubject.pipe(         takeUntil(this.destroy$),         distinctUntilChanged((prev, curr) => this.shouldSkipUpdate(prev, curr)),         debounceTime(16)       ).subscribe(state => {         if (state) this.render(state);       });     }        private render(state: GeoState): void {       this.zone.runOutsideAngular(() => {         this.renderFeatures(state.features);         this.updateSelection(state.selection);         this.updateHighlight(state.highlighted);       });     }        private renderFeatures(features: GeoFeature[]): void {       const path = this.context.path;              const featureElements = this.featureGroup         .selectAll<SVGPathElement, GeoFeature>('path')         .data(features, d => d.id);          // Enter       featureElements.enter()         .append('path')         .attr('class', 'feature')         .attr('d', d => path(d) || '')         .on('click', (event, d) => this.handleFeatureClick(d))         .on('mouseenter', (event, d) => this.handleFeatureHover(d.id))         .on('mouseleave', () => this.handleFeatureHover(undefined));          // Update       featureElements         .attr('d', d => path(d) || '');          // Exit       featureElements.exit().remove();     }        private updateSelection(selection: Set<string>): void {       this.featureGroup         .selectAll<SVGPathElement, GeoFeature>('path')         .classed('selected', d => selection.has(d.id));     }        private updateHighlight(highlighted?: string): void {       this.featureGroup         .selectAll<SVGPathElement, GeoFeature>('path')         .classed('highlighted', d => d.id === highlighted);     }        private handleZoom(transform: d3.ZoomTransform): void {       this.zoomHandler.applyZoom(this.featureGroup);              const viewport = {         center: this.context.projection.invert!([           this.context.width / 2,           this.context.height / 2         ]) as [number, number],         zoom: transform.k       };          this.zone.run(() => {         this.viewportChange.emit(viewport);       });     }        private handleFeatureClick(feature: GeoFeature): void {       this.zone.run(() => {         const currentState = this.stateSubject.getValue();         if (!currentState) return;            const newSelection = new Set(currentState.selection);         if (newSelection.has(feature.id)) {           newSelection.delete(feature.id);         } else {           newSelection.add(feature.id);         }            this.selectionChange.emit(newSelection);       });     }        private handleFeatureHover(featureId: string | undefined): void {       this.zone.run(() => {         this.highlightChange.emit(featureId);       });     }        private shouldSkipUpdate(prev: GeoState | null, curr: GeoState | null): boolean {       if (!prev || !curr) return false;              return (         prev.features === curr.features &&         prev.selection === curr.selection &&         prev.highlighted === curr.highlighted       );     }        // Public API methods     public fitFeatures(): void {       const state = this.stateSubject.getValue();       if (!state?.features.length) return;              this.zone.runOutsideAngular(() => {         this.geoService.fitFeatures(           state.features,           this.context,           this.options.fitPadding         );       });     }        public resetZoom(): void {       this.zone.runOutsideAngular(() => {         this.zoomHandler.reset();       });     }   }    
|   |   |   +-- ixt-geo.module.ts:   import { NgModule } from '@angular/core';   import { CommonModule } from '@angular/common';   import { IxtGeoComponent } from './ixt-geo.component';   import { GeoService } from './geo.service';      @NgModule({     declarations: [IxtGeoComponent],     imports: [CommonModule],     exports: [IxtGeoComponent],     providers: [GeoService]   })   export class IxtGeoModule {}
|   |   |   +-- ixt-geo.service.ts: // geo.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { GeoProjection, GeoPath } from 'd3-geo'; import { ProjectionType, Viewport, GeoFeature, RenderContext, GeoOptions } from './types';  @Injectable({   providedIn: 'root' }) export class GeoService {   createProjection(type: ProjectionType = 'mercator', width: number, height: number): GeoProjection {     let projection: GeoProjection;          switch (type) {       case 'equalArea':         projection = d3.geoAzimuthalEqualArea();         break;       case 'equalEarth':         projection = d3.geoEqualEarth();         break;       default:         projection = d3.geoMercator();     }      return projection       .scale((width / 2.5) / Math.PI)       .translate([width / 2, height / 2]);   }    createRenderContext(     container: HTMLElement,     options: GeoOptions   ): RenderContext {     const width = options.width || container.clientWidth;     const height = options.height || container.clientHeight;          const projection = this.createProjection(options.projection, width, height);     const path = d3.geoPath().projection(projection);          const svg = d3.select(container)       .append('svg')       .attr('width', width)       .attr('height', height);      return { svg, projection, path, width, height };   }    setupZoom(     context: RenderContext,     options: GeoOptions,     onZoom: (transform: d3.ZoomTransform) => void   ): d3.ZoomBehavior<Element, unknown> {     const zoom = d3.zoom()       .scaleExtent([options.minZoom || 1, options.maxZoom || 8])       .on('zoom', (event: d3.D3ZoomEvent<Element, unknown>) => {         onZoom(event.transform);       });      context.svg.call(zoom);     return zoom;   }    fitFeatures(     features: GeoFeature[],     context: RenderContext,     padding: number = 50   ): void {     const bounds = d3.geoBounds({ type: 'FeatureCollection', features });     const [[x0, y0], [x1, y1]] = bounds;          const dx = x1 - x0;     const dy = y1 - y0;     const x = (x0 + x1) / 2;     const y = (y0 + y1) / 2;     const scale = Math.min(       0.9 / Math.max(dx / context.width, dy / context.height),       8     );          const translate = [       context.width / 2 - scale * context.projection(([x, y] as [number, number]))[0],       context.height / 2 - scale * context.projection(([x, y] as [number, number]))[1]     ];      context.svg       .transition()       .duration(750)       .call(         d3.zoom().transform as any,         d3.zoomIdentity           .translate(translate[0], translate[1])           .scale(scale)       );   } } 
|   |   |   +-- ixt.geo.component.scss: // ixt-geo.component.scss :host {     display: block;     width: 100%;     height: 100%;   }      .geo-container {     position: relative;     width: 100%;     height: 100%;     overflow: hidden;        // SVG styles created by D3     svg {       width: 100%;       height: 100%;              // Feature group       g.features {         path {           fill: #e8e8e8;           stroke: #fff;           stroke-width: 0.5;           vector-effect: non-scaling-stroke;           cursor: pointer;           transition: fill 0.2s ease;              &:hover {             fill: #d0d0d0;           }              &.selected {             fill: #a8c8f0;                          &:hover {               fill: #90b8e8;             }           }              &.highlighted {             fill: #c0d8f8;                          &.selected {               fill: #78a8e0;             }           }         }       }     }   }
|   |   |   +-- types.ts: // types.ts import * as d3 from 'd3'; import { GeoProjection, GeoPath } from 'd3-geo'; import { Feature, FeatureCollection, Geometry } from 'geojson';  export interface GeoFeature extends Feature {   id: string;   geometry: Geometry;   properties: Record<string, unknown>; }  export interface GeoState {   viewport: Viewport;   features: GeoFeature[];   selection: Set<string>;   highlighted?: string; }  export interface Viewport {   center: [number, number];   zoom: number;   bounds?: BoundingBox; }  export type BoundingBox = [[number, number], [number, number]];  export interface GeoOptions {   projection?: ProjectionType;   interactive?: boolean;   maxZoom?: number;   minZoom?: number;   width?: number;   height?: number;   fitPadding?: number; }  export type ProjectionType = 'mercator' | 'equalArea' | 'equalEarth';  export interface RenderContext {   svg: d3.Selection<SVGElement, unknown, null, undefined>;   projection: GeoProjection;   path: GeoPath;   width: number;   height: number; } 
|   |   |   -- zoom.handler.ts: // zoom.handler.ts import { ZoomBehavior, ZoomTransform, select } from 'd3'; import { RenderContext } from './types';  export class ZoomHandler {   private transform: ZoomTransform = new ZoomTransform(1, 0, 0);   private zoomBehavior: ZoomBehavior<Element, unknown>;    constructor(     private context: RenderContext,     private onZoomChange: (transform: ZoomTransform) => void   ) {     this.zoomBehavior = this.setupZoom();   }    private setupZoom(): ZoomBehavior<Element, unknown> {     return d3.zoom()       .scaleExtent([1, 8])       .on('zoom', (event: d3.D3ZoomEvent<Element, unknown>) => {         this.transform = event.transform;         this.onZoomChange(this.transform);       });   }    applyZoom(selection: d3.Selection<SVGGElement, unknown, null, undefined>): void {     selection.attr('transform', this.transform.toString());   }    reset(): void {     this.context.svg       .transition()       .duration(750)       .call(         this.zoomBehavior.transform,         new ZoomTransform(1, 0, 0)       );   }    zoomTo(transform: ZoomTransform): void {     this.context.svg       .transition()       .duration(750)       .call(this.zoomBehavior.transform, transform);   } } 
|   |   +-- ixt-geo-map
|   |   |   +-- ixt-geo-map.component.html: <p>ixt-geo-map works!</p> 
|   |   |   +-- ixt-geo-map.component.scss: 
|   |   |   +-- ixt-geo-map.component.ts: import { Component } from '@angular/core';  @Component({   selector: 'ixt-ixt-geo-map',   templateUrl: './ixt-geo-map.component.html',   styleUrls: ['./ixt-geo-map.component.scss'] }) export class IxtGeoMapComponent {  } 
|   |   |   -- ixt-geo-map.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtGeoMapComponent } from './ixt-geo-map.component';  @NgModule({   declarations: [     IxtGeoMapComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtGeoMapComponent   ] }) export class IxtGeoMapModule { } 
|   |   +-- ixt-holy-grail
|   |   |   +-- index.ts: // src/components/ixt-holy-grail/index.ts  export * from './ixt-holy-grail.component'; export * from './ixt-holy-grail.interfaces'; export * from './ixt-holy-grail.module'; 
|   |   |   +-- ixt-holy-grail.component.html: <div class="holy-grail-container" [style.grid-template-areas]="templateAreas">   <div class="holy-grail-header">     <ng-content select="[H]"></ng-content>   </div>    <div class="holy-grail-left">     <ng-content select="[L]"></ng-content>   </div>    <div class="holy-grail-center">     <ng-content select="[C]"></ng-content>   </div>    <div class="holy-grail-right">     <ng-content select="[R]"></ng-content>   </div>    <div class="holy-grail-footer">     <ng-content select="[F]"></ng-content>   </div> </div> 
|   |   |   +-- ixt-holy-grail.component.scss: .holy-grail-container {   display: grid;   grid-template-columns: repeat(3, 1fr);   grid-template-rows: auto 1fr auto;   gap: 2px;   height: 100%;    > div {     padding: 8px;     background-color: #f5f5f5;   } }  .holy-grail-header { grid-area: H; } .holy-grail-left { grid-area: L; } .holy-grail-center { grid-area: C; } .holy-grail-right { grid-area: R; } .holy-grail-footer { grid-area: F; } 
|   |   |   +-- ixt-holy-grail.component.ts: // src/components/ixt-holy-grail/ixt-holy-grail.component.ts import { Component, Input, OnInit } from '@angular/core'; import { HolyGrailTemplate } from './ixt-holy-grail.interfaces';  @Component({   selector: 'ixt-holy-grail',   templateUrl: './ixt-holy-grail.component.html',   styleUrls: ['./ixt-holy-grail.component.scss'] }) export class IxtHolyGrailComponent implements OnInit {   @Input() template?: HolyGrailTemplate;    private defaultTemplate: HolyGrailTemplate = [     ['H', 'H', 'H'],     ['L', 'C', 'R'],     ['F', 'F', 'F']   ];    templateAreas: string = '';    ngOnInit() {     this.updateTemplateAreas(this.template || this.defaultTemplate);   }    private updateTemplateAreas(template: HolyGrailTemplate) {     this.validateTemplate(template);     this.templateAreas = this.convertToGridAreas(template);   }    private validateTemplate(template: HolyGrailTemplate) {     const validAreas = ['H', 'L', 'C', 'R', 'F'];     const flatTemplate = template.flat();      if (!flatTemplate.every((cell: string) => validAreas.includes(cell))) {       throw new Error('Invalid area name. Must be one of: H, L, C, R, F');     }   }    private convertToGridAreas(template: HolyGrailTemplate): string {     return template       .map((row: string[]) => `"${row.join(' ')}"`)       .join(' ');   } } 
|   |   |   +-- ixt-holy-grail.interfaces.ts: // src/components/ixt-holy-grail/ixt-holy-grail.interfaces.ts  export type HolyGrailArea = 'H' | 'L' | 'C' | 'R' | 'F'; export type HolyGrailRow = [HolyGrailArea, HolyGrailArea, HolyGrailArea]; export type HolyGrailTemplate = [HolyGrailRow, HolyGrailRow, HolyGrailRow];  export interface HolyGrailConfig {   template?: HolyGrailTemplate;   /* We can add more config options later like:    * - gap sizes    * - column/row proportions    * - responsive breakpoints    */ } 
|   |   |   -- ixt-holy-grail.module.ts: // src/components/ixt-holy-grail/ixt-holy-grail.module.ts  import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtHolyGrailComponent } from './ixt-holy-grail.component';  @NgModule({   declarations: [     IxtHolyGrailComponent   ],   imports: [     CommonModule   ],   exports: [     IxtHolyGrailComponent   ] }) export class IxtHolyGrailModule { } 
|   |   +-- ixt-image
|   |   |   +-- ixt-image.component.html: <p>ixt-image works!</p> 
|   |   |   +-- ixt-image.component.scss: 
|   |   |   +-- ixt-image.component.ts: import { Component } from '@angular/core';  @Component({   selector: 'ixt-ixt-image',   templateUrl: './ixt-image.component.html',   styleUrls: ['./ixt-image.component.scss'] }) export class IxtImageComponent {  } 
|   |   |   -- ixt-image.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtImageComponent } from './ixt-image.component';  @NgModule({   declarations: [     IxtImageComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtImageComponent   ] }) export class IxtImageModule { } 
|   |   +-- ixt-input
|   |   |   +-- ixt-input.component.html: <p>ixt-input works!</p> 
|   |   |   +-- ixt-input.component.scss: 
|   |   |   +-- ixt-input.component.ts: import { Component } from '@angular/core';  @Component({   selector: 'ixt-ixt-input',   templateUrl: './ixt-input.component.html',   styleUrls: ['./ixt-input.component.scss'] }) export class IxtInputComponent {  } 
|   |   |   -- ixt-input.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtInputComponent } from './ixt-input.component';  @NgModule({   declarations: [     IxtInputComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtInputComponent   ] }) export class IxtInputModule { } 
|   |   +-- ixt-layer-manager
|   |   |   +-- ixt-layer-manager.component.html: <!-- ixt-layer-manager.component.html --> <div class="layer-manager">   <div class="manager-header">     <div class="header-content">       <span class="header-icon">⟰</span>       <h2>Layers</h2>     </div>   </div>    <div class="layer-list" cdkDropList (cdkDropListDropped)="onDrop($event)">     <div class="layer-puck" *ngFor="let layer of layers" cdkDrag>       <div class="drag-handle">⋮</div>              <span class="layer-name">{{ layer.name }}</span>              <div class="layer-controls">         <button class="control-btn" (click)="openColorPicker(layer, 'fill')">           <span class="icon" [style.color]="layer.fillColor">●</span>         </button>         <button class="control-btn" (click)="openColorPicker(layer, 'stroke')">           <span class="icon" [style.color]="layer.strokeColor">○</span>         </button>         <button class="control-btn" (click)="openStrokeStylePicker(layer)">           <span class="icon" [ngClass]="layer.strokeStyle">─</span>         </button>         <button class="control-btn" (click)="toggleVisibility(layer)">           <span class="icon">{{ layer.visible ? '👁' : '👁‍🗨' }}</span>         </button>       </div>     </div>   </div> </div>
|   |   |   +-- ixt-layer-manager.component.scss: .layer-manager {   width: 100%;   height: 100%;   background: white;   border: 1px solid #e5e7eb;   display: flex;   flex-direction: column;   overflow: hidden;  }    .manager-header {   padding: 1rem;   border-bottom: 1px solid #e5e7eb;   background: #f9fafb;    .header-content {     display: flex;     align-items: center;     gap: 0.5rem;      .header-icon {       color: #3b82f6;     }      h2 {       font-size: 0.875rem;       font-weight: 500;       color: #111827;       margin: 0;     }   } }  .layer-list {   flex: 1;   overflow-y: auto;   padding: 0.5rem;   display: flex;   flex-direction: column;   gap: 0.25rem;  }  .layer-puck {   display: flex;   align-items: center;   gap: 0.75rem;   padding: 0.5rem;   background: white;   border: 1px solid #e5e7eb;   border-radius: 0.5rem;   cursor: move;    &:hover {     border-color: #3b82f6;   } }  .drag-handle {   color: #9ca3af;   cursor: move;   user-select: none;    &:hover {     color: #6b7280;   } }  .layer-name {   flex: 1;   font-size: 0.875rem;   font-weight: 500;   color: #374151; }  .layer-controls {   display: flex;   gap: 0.5rem; }  .control-btn {   padding: 0.25rem;   border: none;   background: transparent;   border-radius: 0.375rem;   cursor: pointer;    &:hover {     background: #f3f4f6;   } }  .icon {   display: inline-block;   font-size: 1rem;   line-height: 1;    &.solid { border-bottom: 2px solid currentColor; }   &.dashed { border-bottom: 2px dashed currentColor; }   &.dotted { border-bottom: 2px dotted currentColor; } }
|   |   |   +-- ixt-layer-manager.component.spec.ts: import { ComponentFixture, TestBed } from '@angular/core/testing';  import { IxtLayerManagerComponent } from './ixt-layer-manager.component';  describe('IxtLayerManagerComponent', () => {   let component: IxtLayerManagerComponent;   let fixture: ComponentFixture<IxtLayerManagerComponent>;    beforeEach(() => {     TestBed.configureTestingModule({       declarations: [IxtLayerManagerComponent]     });     fixture = TestBed.createComponent(IxtLayerManagerComponent);     component = fixture.componentInstance;     fixture.detectChanges();   });    it('should create', () => {     expect(component).toBeTruthy();   }); }); 
|   |   |   +-- ixt-layer-manager.component.ts: // ixt-layer-manager.component.ts import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core'; import { CdkDragDrop, moveItemInArray } from '@angular/cdk/drag-drop';  export interface Layer {   id: string;   name: string;   visible: boolean;   fillColor: string;   strokeColor: string;   strokeStyle: 'solid' | 'dashed' | 'dotted';   order: number; }  @Component({   selector: 'ixt-layer-manager',   templateUrl: './ixt-layer-manager.component.html',   styleUrls: ['./ixt-layer-manager.component.scss'] }) export class IxtLayerManagerComponent implements OnInit {   @Input() layers: Layer[] = [];   @Output() layerChange = new EventEmitter<Layer[]>();   @Output() layerOrderChange = new EventEmitter<Layer[]>();    selectedLayer: Layer | null = null;   showColorPicker = false;   activeProperty: 'fill' | 'stroke' | null = null;   showStrokeStylePicker = false;   strokeStyles: Array<Layer['strokeStyle']> = ['solid', 'dashed', 'dotted'];    ngOnInit(): void {     this.sortLayers();   }    sortLayers(): void {     this.layers.sort((a, b) => a.order - b.order);   }    onDrop(event: CdkDragDrop<Layer[]>): void {     moveItemInArray(this.layers, event.previousIndex, event.currentIndex);     this.layers.forEach((layer, index) => {       layer.order = index;     });     this.layerOrderChange.emit(this.layers);   }    toggleVisibility(layer: Layer): void {     layer.visible = !layer.visible;     this.layerChange.emit(this.layers);   }    openColorPicker(layer: Layer, property: 'fill' | 'stroke'): void {     this.selectedLayer = layer;     this.activeProperty = property;     this.showColorPicker = true;   }    openStrokeStylePicker(layer: Layer): void {     this.selectedLayer = layer;     this.showStrokeStylePicker = true;   }    onColorSelect(color: string): void {     if (this.selectedLayer && this.activeProperty) {       if (this.activeProperty === 'fill') {         this.selectedLayer.fillColor = color;       } else {         this.selectedLayer.strokeColor = color;       }       this.layerChange.emit(this.layers);     }   }    onStrokeStyleSelect(style: Layer['strokeStyle']): void {     if (this.selectedLayer) {       this.selectedLayer.strokeStyle = style;       this.layerChange.emit(this.layers);       this.closeStrokeStylePicker();     }   }    closeColorPicker(): void {     this.showColorPicker = false;     this.selectedLayer = null;     this.activeProperty = null;   }    closeStrokeStylePicker(): void {     this.showStrokeStylePicker = false;     this.selectedLayer = null;   } } 
|   |   |   -- ixt-layer-manager.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { DragDropModule } from '@angular/cdk/drag-drop'; import { IxtLayerManagerComponent } from './ixt-layer-manager.component';  @NgModule({   declarations: [IxtLayerManagerComponent],   imports: [     CommonModule,     DragDropModule   ],   exports: [IxtLayerManagerComponent] }) export class IxtLayerManagerModule { } 
|   |   +-- ixt-map
|   |   |   +-- geo-processing.service.ts: // Create the GeoJSON processing service (geo-processing.service.ts) import { Injectable } from '@angular/core'; import { Feature, LineString, GeoJsonProperties, Geometry } from 'geojson'; import * as d3 from 'd3'; import { GeoFeatureProperties, GeoProcessingOptions } from './geo.types';  @Injectable({   providedIn: 'root' }) export class GeoProcessingService {   processFeatures(features: Feature[], options: GeoProcessingOptions = {}): Feature[] {     let processedFeatures = [...features];      // Apply route interpolation if needed     if (options.interpolateRoutes) {       processedFeatures = this.interpolateRoutes(processedFeatures, {         pointsPerRoute: options.pointsPerRoute,         minPoints: options.minPointsPerRoute       });     }      // Apply filtering if expression provided     if (options.filterExpression) {       processedFeatures = this.filterFeatures(processedFeatures, options.filterExpression);     }      return processedFeatures;   }    private interpolateRoutes(     features: Feature[],     options: { pointsPerRoute?: number; minPoints?: number } = {}   ): Feature[] {     const minPoints = options.minPoints || 5;      return features.map(feature => {       if (feature.geometry.type !== 'LineString') {         return feature;       }        const line = feature.geometry as LineString;       const coordinates = line.coordinates;        if (coordinates.length !== 2) {         return feature;       }        const start = coordinates[0] as [number, number];       const end = coordinates[1] as [number, number];       const route = d3.geoInterpolate(start, end);        // Calculate distance and points       const distance = d3.geoDistance(start, end) * 3959; // Earth radius in miles       const pointsPer5Miles = Math.ceil(distance / 5);       const numPoints = Math.max(minPoints, options.pointsPerRoute || pointsPer5Miles);        const newCoordinates = Array.from({ length: numPoints }, (_, i) => {         const t = i / (numPoints - 1);         return route(t);       });        return {         ...feature,         geometry: {           ...line,           coordinates: newCoordinates         }       };     });   }    private filterFeatures(features: Feature[], expression: string): Feature[] {     const filterFn = this.createFilterFunction(expression);          return features.filter(feature => {       try {         return filterFn ? filterFn(feature) : true;       } catch (e) {         console.error('Error applying filter to feature:', e);         return true;       }     });   }    private createFilterFunction(expression: string): Function | null {     if (!expression) return null;          try {       return new Function('feature', `         try {           const properties = feature.properties;           return ${expression};         } catch (e) {           console.error('Filter expression error:', e);           return true;         }       `);     } catch (e) {       console.error('Error creating filter function:', e);       return null;     }   }    // private createFilterFunction(): Function | null {   //   if (!this.filterExpression) return null;    //   console.log('Creating filter with expression:', this.filterExpression);    //   return new Function('feature', `   //     try {   //       const properties = feature.properties;   //       //console.log('Evaluating:', properties);   //       return ${this.filterExpression};   //     } catch (e) {   //       console.error('Filter expression error:', e);   //       return true;  // If there's an error, include the feature   //     }   //   `);   // } }
|   |   |   +-- geo.types.ts: // First, let's create the interfaces (geo.types.ts) export interface GeoFeatureProperties {     [key: string]: any;   }      export interface GeoProcessingOptions {     interpolateRoutes?: boolean;     pointsPerRoute?: number;     minPointsPerRoute?: number;     filterExpression?: string;   }
|   |   |   +-- ixt-layer.component.html: 
|   |   |   +-- ixt-layer.component.scss: 
|   |   |   +-- ixt-layer.component.ts: import {   Component, Input, Output, EventEmitter, ElementRef, Host,   ChangeDetectionStrategy, ChangeDetectorRef, SimpleChanges } from '@angular/core'; import * as d3 from 'd3'; import { IxtMapComponent } from './ixt-map.component'; import { GeoProcessingService } from './geo-processing.service'; import { LayerRenderService } from './layer-render.service'; import { LayerEventHandlers, LayerEventService } from './layer-event.service'; import { LayerStateService } from './layer-state.service'; import { Feature } from 'geojson';  @Component({   selector: 'ixt-layer',   template: ` <svg:g> <ng-content></ng-content> </svg:g> `,   changeDetection: ChangeDetectionStrategy.OnPush }) export class IxtLayerComponent {   @Input() src: string = '';   @Input() stroke: string = 'black';   @Input() fill: string = 'none';   @Output() click = new EventEmitter<MouseEvent>();   @Output() hover = new EventEmitter<MouseEvent>();    private initialized = false;   private pathGenerator!: d3.GeoPath;   private filterExpression: string = '';    constructor(     @Host() private mapComponent: IxtMapComponent,     private elementRef: ElementRef,     private cdr: ChangeDetectorRef,     private geoProcessingService: GeoProcessingService,     private layerRenderService: LayerRenderService,     private layerEventService: LayerEventService,     private layerStateService: LayerStateService   ) { }    ngOnChanges(changes: SimpleChanges) {     if ((changes['src'] || changes['stroke'] || changes['fill']) && this.initialized) {       this.initializeLayer();     }   }     ngAfterContentInit() {     const content = this.elementRef.nativeElement.textContent?.trim();     if (content) {       this.filterExpression = content;     }   }    setProjection(pathGenerator: d3.GeoPath): void {     this.pathGenerator = pathGenerator;     this.initializeLayer();   }    async initializeLayer(): Promise<void> {     if (this.initialized) return;     if (!this.validateContainer()) return;      try {       const features = await this.loadGeoJsonData();       const handlers = this.createEventHandlers();       this.renderLayer(features, handlers);       this.initialized = true;     } catch (error) {       console.error('Layer initialization failed:', error);     }   }    private validateContainer(): boolean {     const container = this.mapComponent.getContainer();     if (!container || !this.pathGenerator) {       console.error('Map container or projection not ready');       return false;     }     return true;   }    private async loadGeoJsonData(): Promise<Feature[]> {     const data = await d3.json(this.src) as { features: Feature[] };     return this.geoProcessingService.processFeatures(data.features, {       interpolateRoutes: true,       filterExpression: this.filterExpression     });   }    private async renderLayer(features: any, handlers: any): Promise<void> {     const container = this.mapComponent.getContainer();     const selection = this.layerRenderService.createLayer(       d3.select(container.nativeElement),       features,       { stroke: this.stroke, fill: this.fill },       handlers     );        this.layerStateService.addSelection(selection);     this.cdr.markForCheck();   }    private createEventHandlers(): LayerEventHandlers {     return {       onClick: (event: MouseEvent, datum: any) => {         this.layerEventService.handleClick(event, this.mapComponent);         this.click.emit(event);       },       onMouseOver: (event: MouseEvent) => {         this.layerEventService.handleMouseOver(event, this.mapComponent);         this.hover.emit(event);       },       onMouseOut: () => this.layerEventService.handleMouseOut(),       onMouseMove: (event: MouseEvent) => event.stopPropagation()     };   }    ngOnDestroy(): void {     this.layerStateService.clearSelections();   } }
|   |   |   +-- ixt-map.component.html: 
|   |   |   +-- ixt-map.component.scss: 
|   |   |   +-- ixt-map.component.ts: import {    Component, Input, ViewChild, ElementRef, ContentChildren,    QueryList, AfterContentInit, OnDestroy, ChangeDetectionStrategy,    ChangeDetectorRef   } from '@angular/core';  import * as d3 from 'd3';  import { IxtLayerComponent } from './ixt-layer.component';  import { GeoProjection, GeoPath } from 'd3';  import { BehaviorSubject, Subscription } from 'rxjs';  import { MapService } from './map.service';  import { MapDimensions, MapSelection, PathSelection, MapContainer } from './map.types';    @Component({   selector: 'ixt-map',   template: `     <svg #mapSvg          [attr.width]="width"          [attr.height]="height"          [attr.viewBox]="getViewBox()"          style="display: block; background: lightgray;">       <g #mapGroup>         <ng-content></ng-content>       </g>     </svg>   `,   styles: [`     :host {       display: block;     }     svg {       display: block;     }   `],   changeDetection: ChangeDetectionStrategy.OnPush  })  export class IxtMapComponent implements AfterContentInit, OnDestroy {   @Input() width: string | number = 800;   @Input() height: string | number = 600;   @Input() scale: string | number = 1;   @Input() translate: string = '0,0';     @ViewChild('mapSvg') mapSvg!: ElementRef<SVGSVGElement>;   @ViewChild('mapGroup') mapGroup!: MapContainer;   @ContentChildren(IxtLayerComponent) layers!: QueryList<IxtLayerComponent>;     private projection!: GeoProjection;   private pathGenerator!: GeoPath;   private selectedElement: SVGPathElement | null = null;   private mapSubscriptions = new Subscription();    private projectionReady = new BehaviorSubject<boolean>(false);   projectionReady$ = this.projectionReady.asObservable();      constructor(     private cdr: ChangeDetectorRef,     private mapService: MapService   ) {}     private getDimensions(): MapDimensions {     return {       width: this.mapService.getBaseDimension(this.width),       height: this.mapService.getBaseDimension(this.height),       scale: Number(this.scale),       translate: this.translate     };   }     getViewBox(): string {     const { width, height } = this.getDimensions();     return `0 0 ${width} ${height}`;   }     private initializeMap(): void {     const dimensions = this.getDimensions();     const { projection, pathGenerator } = this.mapService.initializeProjection(       dimensions.width,       dimensions.height     );        this.projection = projection;     this.pathGenerator = pathGenerator;     this.projectionReady.next(true);       if (this.mapGroup) {       const mapSelection = d3.select<SVGGElement, unknown>(this.mapGroup.nativeElement);       mapSelection.on('click', () => this.clearSelection());     }       setTimeout(() => {       this.layers.forEach(layer => {         layer.setProjection(this.pathGenerator);       });     });   }     getContainer(): MapContainer {     return this.mapGroup;   }     getPathGenerator(): GeoPath {     return this.pathGenerator;   }     clearSelection(): void {     if (this.selectedElement) {       d3.select<SVGPathElement, unknown>(this.selectedElement)         .attr('stroke', function(this: SVGPathElement) {           return this.getAttribute('data-original-stroke') || '';         })         .attr('stroke-width', '1');       this.selectedElement = null;       this.cdr.markForCheck();     }   }     setSelection(element: SVGPathElement | null): void {     this.clearSelection();     if (element) {       this.selectedElement = element;       this.cdr.markForCheck();     }   }     ngAfterContentInit(): void {     this.initializeMap();          this.mapSubscriptions.add(       this.layers.changes.subscribe(() => {         this.initializeMap();         this.cdr.markForCheck();       })     );   }     ngOnDestroy(): void {     this.mapSubscriptions.unsubscribe();     this.selectedElement = null;     this.projection = null as any;     this.pathGenerator = null as any;   }  }
|   |   |   +-- ixt-map.index.ts: // Export all public components from the ixt-map module export * from './ixt-map.component'; export * from './ixt-layer.component'; // Include any additional exports, such as services or interfaces, if they are part of the module 
|   |   |   +-- ixt-map.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; // CommonModule is needed for common directives like NgIf, NgFor, etc. import { IxtMapComponent } from './ixt-map.component'; import { IxtLayerComponent } from './ixt-layer.component';  @NgModule({   declarations: [     IxtMapComponent,   // Declare IxtMapComponent     IxtLayerComponent  // Declare IxtLayerComponent   ],   imports: [     CommonModule       // Import CommonModule for basic Angular directives   ],   exports: [     IxtMapComponent,   // Export IxtMapComponent to be available for other modules     IxtLayerComponent  // Export IxtLayerComponent so it can be used in conjunction with IxtMapComponent   ] }) export class IxtMapModule {} 
|   |   |   +-- layer-event.service.ts: // layer-event.service.ts import { Injectable } from '@angular/core'; import { MapService } from './map.service'; import * as d3 from 'd3';  export interface LayerEventHandlers {   onClick: (event: MouseEvent, datum: any) => void;   onMouseOver: (event: MouseEvent) => void;   onMouseOut: () => void;   onMouseMove: (event: MouseEvent) => void; }   @Injectable({   providedIn: 'root' }) export class LayerEventService {   private hoveredElement: SVGPathElement | null = null;    constructor(private mapService: MapService) {}    handleClick(event: MouseEvent, mapRef: any): void {     event.stopPropagation();     const clickedPath = event.currentTarget as SVGPathElement;          if (clickedPath === mapRef['selectedElement']) {       mapRef.setSelection(null);       this.applyHoverEffect(clickedPath, false);     } else {       if (mapRef['selectedElement']) {         this.applyHoverEffect(mapRef['selectedElement'], false);       }       mapRef.setSelection(clickedPath);       this.applyHoverEffect(clickedPath, true);     }   }    handleMouseOver(event: MouseEvent, mapRef: any): void {     event.stopPropagation();     const currentPath = event.currentTarget as SVGPathElement;     if (currentPath !== mapRef['selectedElement']) {       this.applyHoverEffect(currentPath, true);       this.hoveredElement = currentPath;     }   }    handleMouseOut(): void {     if (this.hoveredElement) {       this.clearHoverState(this.hoveredElement);       this.hoveredElement = null;     }   }    private applyHoverEffect(element: SVGPathElement, isHover: boolean): void {     const d3Element = d3.select(element);     const currentFill = element.getAttribute('data-original-fill');          if (currentFill && currentFill !== 'none') {       d3Element         .attr('fill', currentFill)         .attr('stroke-width', isHover ? '2' : '1');     } else {       d3Element.attr('stroke-width', isHover ? '2' : '1');     }   }    private clearHoverState(element: SVGPathElement): void {     const d3Element = d3.select(element);     const originalFill = element.getAttribute('data-original-fill');          d3Element       .attr('fill', originalFill)       .attr('stroke-width', '1');   } }
|   |   |   +-- layer-render.service.ts: // layer-render.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { Feature, GeoJsonProperties, Geometry } from 'geojson'; import { MapService } from './map.service';  export interface LayerRenderOptions {   stroke: string;   fill: string; }  @Injectable({   providedIn: 'root' }) export class LayerRenderService {   constructor(private mapService: MapService) {}    createLayer(     container: d3.Selection<any, any, any, any>,     features: Feature[],     options: LayerRenderOptions,     eventHandlers: {       onClick: (event: MouseEvent, datum: any) => void;       onMouseOver: (event: MouseEvent) => void;       onMouseOut: (event: MouseEvent) => void;       onMouseMove: (event: MouseEvent) => void;     }   ): d3.Selection<any, any, any, any> {     const layerGroup = container       .append('g')       .attr('class', 'map-layer');      return layerGroup       .selectAll('path')       .data(features)       .enter()       .append('path')       .attr('d', (datum) => this.mapService.getPathGenerator()(datum) || '')       .attr('stroke', options.stroke)       .attr('fill', options.fill)       .attr('stroke-width', '1')       .attr('data-original-fill', options.fill)       .attr('data-original-stroke', options.stroke)       .attr('vector-effect', 'non-scaling-stroke')       .style('cursor', 'pointer')       .on('click', eventHandlers.onClick)       .on('mouseover', eventHandlers.onMouseOver)       .on('mouseout', eventHandlers.onMouseOut)       .on('mousemove', eventHandlers.onMouseMove);   } }
|   |   |   +-- layer-state.service.ts: // layer-state.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs';  export interface LayerState {   hoveredElement: SVGPathElement | null;   selections: d3.Selection<any, any, any, any>[]; }  @Injectable({   providedIn: 'root' }) export class LayerStateService {   private state = new BehaviorSubject<LayerState>({     hoveredElement: null,     selections: []   });    state$ = this.state.asObservable();    setHoveredElement(element: SVGPathElement | null): void {     this.updateState({ hoveredElement: element });   }    addSelection(selection: d3.Selection<any, any, any, any>): void {     const currentState = this.state.value;     this.updateState({       selections: [...currentState.selections, selection]     });   }    clearSelections(): void {     const currentState = this.state.value;     currentState.selections.forEach(selection => {       if (selection && !selection.empty()) {         selection.remove();       }     });     this.updateState({ selections: [] });   }    private updateState(partialState: Partial<LayerState>): void {     this.state.next({       ...this.state.value,       ...partialState     });   }    ngOnDestroy(): void {     this.clearSelections();     this.state.complete();   } }
|   |   |   +-- map-error.service.ts: // map-error.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs';  export interface MapError {   code: MapErrorCode;   message: string;   timestamp: Date;   context?: any; }  export enum MapErrorCode {   INITIALIZATION_FAILED = 'INIT_FAILED',   PROJECTION_FAILED = 'PROJ_FAILED',   DATA_LOAD_FAILED = 'DATA_LOAD_FAILED',   SELECTION_FAILED = 'SELECT_FAILED',   INVALID_DIMENSIONS = 'INVALID_DIMS' }  @Injectable({   providedIn: 'root' }) export class MapErrorService {   private errorSubject = new BehaviorSubject<MapError | null>(null);   private retryAttemptsMap = new Map<string, number>();      readonly maxRetryAttempts = 3;   readonly errors$ = this.errorSubject.asObservable();    reportError(code: MapErrorCode, message: string, context?: any): void {     const error: MapError = {       code,       message,       timestamp: new Date(),       context     };     this.errorSubject.next(error);     console.error(`Map Error [${code}]:`, message, context);   }    clearError(): void {     this.errorSubject.next(null);   }    shouldRetry(operationKey: string): boolean {     const attempts = this.retryAttemptsMap.get(operationKey) || 0;     if (attempts < this.maxRetryAttempts) {       this.retryAttemptsMap.set(operationKey, attempts + 1);       return true;     }     return false;   }    resetRetryCount(operationKey: string): void {     this.retryAttemptsMap.delete(operationKey);   } }  
|   |   |   +-- map.service.ts: // map.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { GeoProjection, GeoPath } from 'd3'; import { BehaviorSubject, Observable } from 'rxjs'; import { MapError, MapErrorCode, MapErrorService } from './map-error.service';  export interface MapDimensions {   width: number;   height: number; }  export interface MapState {   projection: GeoProjection;   pathGenerator: GeoPath;   dimensions: MapDimensions; }  @Injectable({   providedIn: 'root' }) export class MapService {   private projection!: GeoProjection;   private pathGenerator!: GeoPath;   private selectedElementSource = new BehaviorSubject<SVGPathElement | null>(null);   private dimensions = new BehaviorSubject<MapDimensions>({ width: 800, height: 600 });    readonly selectedElement$ = this.selectedElementSource.asObservable();   readonly dimensions$ = this.dimensions.asObservable();    private errorSubject = new BehaviorSubject<MapError | null>(null);   private retryAttemptsMap = new Map<string, number>();      readonly maxRetryAttempts = 3;   readonly errors$ = this.errorSubject.asObservable();    constructor(private errorService: MapErrorService) {}     initializeProjection(width: number, height: number): { projection: GeoProjection; pathGenerator: d3.GeoPath } {     try {       if (width <= 0 || height <= 0) {         throw new Error('Invalid dimensions');       }        this.projection = d3.geoMercator()         .fitSize([width, height], {           type: 'Sphere'         });        this.pathGenerator = d3.geoPath().projection(this.projection);        return {         projection: this.projection,         pathGenerator: this.pathGenerator       };     } catch (error) {       this.errorService.reportError(         MapErrorCode.INITIALIZATION_FAILED,         'Failed to initialize map projection',         { width, height, error }       );       throw error;     }   }      getProjection(): GeoProjection {     return this.projection;   }    getPathGenerator(): GeoPath {     return this.pathGenerator;   }    getDimensions(): MapDimensions {     return this.dimensions.value;   }    setSelection(element: SVGPathElement | null): void {     const previousElement = this.selectedElementSource.value;          if (previousElement) {       d3.select(previousElement)         .attr('stroke', d3.select(previousElement).attr('data-original-stroke'))         .attr('stroke-width', '1');     }      this.selectedElementSource.next(element);   }    clearSelection(): void {     this.setSelection(null);   }    getBaseDimension(value: string | number): number {     if (typeof value === 'number') return value;     const num = parseFloat(value);     return isNaN(num) ? 800 : num;   }    reportError(code: MapErrorCode, message: string, context?: any): void {     const error: MapError = {       code,       message,       timestamp: new Date(),       context     };     this.errorSubject.next(error);     console.error(`Map Error [${code}]:`, message, context);   }    clearError(): void {     this.errorSubject.next(null);   }    shouldRetry(operationKey: string): boolean {     const attempts = this.retryAttemptsMap.get(operationKey) || 0;     if (attempts < this.maxRetryAttempts) {       this.retryAttemptsMap.set(operationKey, attempts + 1);       return true;     }     return false;   }    resetRetryCount(operationKey: string): void {     this.retryAttemptsMap.delete(operationKey);   } }
|   |   |   +-- map.types.ts: // map.types.ts import { GeoProjection, GeoPath } from 'd3'; import { ElementRef } from '@angular/core';  export interface MapDimensions {   width: number;   height: number;   scale: number;   translate: string; }  export interface MapState {   projection: GeoProjection;   pathGenerator: GeoPath;   dimensions: MapDimensions; }  export interface MapSelection extends d3.Selection<SVGGElement, unknown, null, undefined> {}  export interface PathSelection extends d3.Selection<SVGPathElement, unknown, null, undefined> {}  export interface MapContainer extends ElementRef<SVGGElement> {}
|   |   |   -- route-processor.service.ts: // route-processor.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { Feature, LineString, GeoJsonProperties } from 'geojson';  export interface RouteProcessingConfig {   pointsPerMile?: number;   minPoints?: number;   earthRadiusMiles?: number; }  const DEFAULT_CONFIG: RouteProcessingConfig = {   pointsPerMile: 0.2,  // 1 point every 5 miles   minPoints: 5,   earthRadiusMiles: 3959 };  @Injectable({   providedIn: 'root' }) export class RouteProcessorService {   private config: RouteProcessingConfig;    constructor() {     this.config = DEFAULT_CONFIG;   }    setConfig(config: Partial<RouteProcessingConfig>): void {     this.config = { ...DEFAULT_CONFIG, ...config };   }    interpolateRoute(feature: Feature<LineString, GeoJsonProperties>): Feature<LineString, GeoJsonProperties> {     const line = feature.geometry;     const coordinates = line.coordinates;      if (coordinates.length !== 2) {       return feature;     }      const start = coordinates[0] as [number, number];     const end = coordinates[1] as [number, number];     const route = d3.geoInterpolate(start, end);     const distance = d3.geoDistance(start, end) * this.config.earthRadiusMiles!;      const numPoints = Math.max(       this.config.minPoints!,       Math.ceil(distance * this.config.pointsPerMile!)     );      const newCoordinates = Array.from({ length: numPoints }, (_, i) => {       const t = i / (numPoints - 1);       return route(t);     });      return {       ...feature,       geometry: {         ...line,         coordinates: newCoordinates       }     };   }    calculateRouteDistance(coordinates: [number, number][]): number {     if (coordinates.length < 2) return 0;      return coordinates.reduce((total, coord, i) => {       if (i === 0) return 0;       const distance = d3.geoDistance(coordinates[i - 1], coord) * this.config.earthRadiusMiles!;       return total + distance;     }, 0);   } }
|   |   +-- ixt-matrix
|   |   |   +-- ixt-matrix.component.html: <div class="ixt-matrix__toolbar">   <button class="ixt-matrix__action-button" (click)="addNewRow()">     <span class="material-icons">add</span>   </button>   <button class="ixt-matrix__action-button" [disabled]="!hasChanges && newRowsLength === 0" (click)="saveChanges()">     <span class="material-icons">save</span>   </button> </div>  <ng-container *ngIf="hasData; else noData">   <div class="ixt-matrix">     <!-- Header -->     <div class="ixt-matrix__header">       <div class="ixt-matrix__cell">         <binary-editor           [config]="{ rowIndex: -1 }"           [(ngModel)]="allSelected"           (selectionChange)="toggleAllRows($event.selected)">         </binary-editor>       </div>       <div class="ixt-matrix__cell" *ngFor="let col of columns" [class.ixt-matrix__cell--first]="col === columns[0]">         <div class="ixt-matrix__cell-content">           {{columnConfigs?.[col]?.label || col}}           <div class="ixt-matrix__cell-actions">             <button class="ixt-matrix__sort-toggle" (click)="toggleSort(col)">               <span class="material-icons">{{getSortIcon(col)}}</span>             </button>             <button class="ixt-matrix__filter-toggle" (click)="toggleFilters(col)">               <span class="material-icons">filter_alt</span>             </button>           </div>         </div>       </div>       <div class="ixt-matrix__cell">Actions</div>     </div>      <!-- Filter Row -->     <div class="ixt-matrix__header" *ngIf="showFilters">       <div class="ixt-matrix__cell"></div>       <div class="ixt-matrix__cell" *ngFor="let col of columns" [class.ixt-matrix__cell--first]="col === columns[0]">         <ng-container *ngIf="activeFilterColumn === col && columnConfigs?.[col]">           <ng-container [ngSwitch]="getEditorType(columnConfigs?.[col]?.type)">             <!-- Text Filter -->             <input *ngSwitchCase="'text'" [formControl]="getFilterControl(col)"               [placeholder]="columnConfigs?.[col]?.placeholder || ''" class="ixt-matrix__filter-input">              <!-- Number Filter -->             <div *ngSwitchCase="'number'" class="ixt-matrix__number-filter">               <select [formControl]="getOperatorControl(col)" (change)="onOperatorChange(col)">                 <option value="=">=</option>                 <option value=">">&gt;</option>                 <option value="<">&lt;</option>                 <option value=">=">&gt;=</option>                 <option value="<=">&lt;=</option>                 <option value="!=">!=</option>               </select>               <input type="number" [formControl]="getFilterControl(col)"                 [placeholder]="columnConfigs?.[col]?.placeholder || ''" class="ixt-matrix__filter-input">             </div>              <!-- Enum Filter -->             <div *ngSwitchCase="'enum'">               <select [formControl]="getFilterControl(col)" class="ixt-matrix__filter-input">                 <option value="">All</option>                 <option *ngFor="let opt of columnConfigs?.[col]?.enumValues" [value]="opt.value">                   {{opt.label}}                 </option>               </select>             </div>           </ng-container>         </ng-container>       </div>       <div class="ixt-matrix__cell"></div>     </div>      <!-- Data Rows -->     <div class="ixt-matrix__row" *ngFor="let row of paginatedData; let i = index"           [class.ixt-matrix__row--selected]="isRowSelected(getRowIndex(i))">       <div class="ixt-matrix__cell">         <binary-editor           [config]="{ rowIndex: getRowIndex(i), rowData: row }"           [ngModel]="isRowSelected(getRowIndex(i))"           (selectionChange)="selectRow(getRowIndex(i), $event.selected)">         </binary-editor>       </div>       <div class="ixt-matrix__cell" *ngFor="let col of columns" [class.ixt-matrix__cell--first]="col === columns[0]">         <ng-container *ngIf="isNewRow(i) || isEditing(getRowIndex(i)); else displayValue">           <ng-container [ngSwitch]="getEditorType(columnConfigs?.[col]?.type)">             <!-- Text Input -->             <input *ngSwitchCase="'text'" type="text" [ngModel]="row[col]"               (ngModelChange)="onValueChange(getRowIndex(i), col, $event)">              <!-- Number Input -->             <input *ngSwitchCase="'number'" type="number" [ngModel]="row[col]"               (ngModelChange)="onValueChange(getRowIndex(i), col, $event)">              <!-- Enum Select -->             <select *ngSwitchCase="'enum'" [ngModel]="row[col]"               (ngModelChange)="onValueChange(getRowIndex(i), col, $event)">               <option *ngFor="let opt of columnConfigs?.[col]?.enumValues" [ngValue]="opt.value">                 {{opt.label}}               </option>             </select>              <!-- Custom Editor -->             <ng-container *ngSwitchCase="'custom'">               <ng-container *ngTemplateOutlet="customEditorTpl; context: {                  $implicit: getEditorComponent(columnConfigs?.[col]?.type),                  row: row,                  col: col,                  index: i,                  control: getEditControl(getRowIndex(i), col)                }">               </ng-container>             </ng-container>           </ng-container>         </ng-container>                    <ng-template #displayValue>           <ng-container [ngSwitch]="columnConfigs?.[col]?.type">             <ng-container *ngSwitchCase="CoordinateEditorComponent">               {{formatCoordinate(row[col])}}             </ng-container>             <ng-container *ngSwitchDefault>               {{row[col]}}             </ng-container>           </ng-container>         </ng-template>       </div>               <div class="ixt-matrix__cell">         <ng-container *ngIf="!isNewRow(i) && !isEditing(getRowIndex(i))">           <button class="ixt-matrix__action-button" (click)="startEditing(getRowIndex(i))">             <span class="material-icons">edit</span>           </button>         </ng-container>         <ng-container *ngIf="isNewRow(i) || isEditing(getRowIndex(i))">           <button class="ixt-matrix__action-button" (click)="cancelEditing(getRowIndex(i))">             <span class="material-icons">close</span>           </button>         </ng-container>       </div>     </div>      <!-- Pagination -->     <div class="ixt-matrix__footer" *ngIf="showPagination">       <div class="ixt-matrix__pagination">         <div class="ixt-matrix__page-size">           <select [formControl]="pageSizeControl">             <option *ngFor="let size of pageSizes" [value]="size.value">               {{size.label}}             </option>           </select>           rows per page         </div>         <div class="ixt-matrix__controls">           <button (click)="onPageChange(1)" [disabled]="currentPage === 1">             <span class="material-icons">first_page</span>           </button>           <button (click)="onPageChange(currentPage - 1)" [disabled]="currentPage === 1">             <span class="material-icons">chevron_left</span>           </button>           <button *ngFor="let page of visiblePages" [class.active]="page === currentPage"                    [class.ellipsis]="page === -1" [disabled]="page === -1"                    (click)="onPageChange(page)">             {{page === -1 ? '...' : page}}           </button>           <button (click)="onPageChange(currentPage + 1)" [disabled]="currentPage === totalPages">             <span class="material-icons">chevron_right</span>           </button>           <button (click)="onPageChange(totalPages)" [disabled]="currentPage === totalPages">             <span class="material-icons">last_page</span>           </button>         </div>       </div>     </div>   </div> </ng-container>  <!-- Custom Editor Template --> <ng-template #customEditorTpl let-editor let-row="row" let-col="col" let-index="index" let-control="control">   <coordinate-editor     *ngIf="editor?.component === CoordinateEditorComponent"     [formControl]="control"     [config]="{       type: col === 'lat' ? 'lat' : 'lon'     }">   </coordinate-editor>    <airport-code-editor     *ngIf="editor?.component === AirportCodeEditorComponent"     [formControl]="control"     [config]="editor.getEditConfig()"     [existingCodes]="getCodes(data)">   </airport-code-editor> </ng-template>  <!-- No Data Template --> <ng-template #noData>   <div class="ixt-matrix__empty">     No data available   </div> </ng-template>
|   |   |   +-- ixt-matrix.component.scss: .ixt-matrix {   border: 1px solid #e2e8f0;   border-radius: 0.5rem;   overflow: auto;   max-height: calc(100vh - 600px); // Adjust based on your layout     &__header {     display: flex;     background: #f7fafc;     border-bottom: 1px solid #e2e8f0;     font-weight: 500;   }     &__row {     display: flex;     border-bottom: 1px solid #e2e8f0;          &:hover {       background: #f7fafc;     }   }     &__cell {     padding: 0.5rem;     width: 150px;     min-width: 150px;     box-sizing: border-box;     border-right: 1px solid #e2e8f0;     overflow: hidden;     text-overflow: ellipsis;     white-space: nowrap;       &:first-child {       width: 40px;       min-width: 40px;     }       &--first {       width: 200px;       min-width: 200px;     }       &--actions {       width: 80px;       min-width: 80px;     }       &-content {       display: flex;       align-items: center;       gap: 8px;       width: 100%;     }       input, select {       width: 100%;       padding: 4px 24px 4px 8px;       border: 1px solid #e2e8f0;       border-radius: 4px;     }       coordinate-editor input {       padding-right: 24px;     }   }     &__empty {     padding: 1rem;     text-align: center;     color: #718096;   }     &__footer {     display: flex;     justify-content: space-between;     align-items: center;     padding: 0.75rem;     border-top: 1px solid #e2e8f0;   }     &__pagination {     display: flex;     justify-content: space-between;     align-items: center;     width: 100%;   }     &__page-size {     select {       padding: 0.25rem 0.5rem;       border: 1px solid #e2e8f0;       border-radius: 0.25rem;       margin-right: 1rem;     }   }     &__controls {     display: flex;     align-items: center;     gap: 0.25rem;       button {       padding: 0.25rem;       min-width: 2rem;       height: 2rem;       border: none;       background: none;       cursor: pointer;       border-radius: 0.25rem;       color: #4169E1;       display: flex;       align-items: center;       justify-content: center;         &:disabled {         color: #808080;         cursor: not-allowed;       }         &:not(:disabled):hover {         background-color: #f7fafc;       }         &.active {         background-color: #4169E1;         color: white;       }         &.ellipsis {         cursor: default;         &:hover {           background: none;         }       }     }   }     &__filter-toggle {     background: none;     border: none;     cursor: pointer;     padding: 4px;     color: #4169E1;     display: flex;     align-items: center;   }     &__filter-input {     width: 100%;     padding: 0.25rem;     border: 1px solid #e2e8f0;     border-radius: 0.25rem;     font-size: 0.875rem;       &:focus {       outline: none;       border-color: #4169E1;     }   }     &__number-filter {     display: flex;     gap: 0.25rem;       select {       padding: 0.25rem;       border: 1px solid #e2e8f0;       border-radius: 0.25rem;     }   }     .material-icons {     font-family: 'Material Icons';     font-weight: normal;     font-style: normal;     display: inline-block;     line-height: 1;     text-transform: none;     letter-spacing: normal;     word-wrap: normal;     white-space: nowrap;     direction: ltr;   }    &__cell-content {     display: flex;     align-items: center;     gap: 8px;   }     &__cell-actions {     display: flex;     align-items: center;     gap: 4px;   }     &__sort-toggle,   &__filter-toggle {     background: none;     border: none;     padding: 4px;     cursor: pointer;     display: flex;     align-items: center;     justify-content: center;       &:hover {       background-color: rgba(0, 0, 0, 0.04);       border-radius: 4px;     }       .material-icons {       font-size: 18px;       color: rgba(0, 0, 0, 0.54);     }   }    &__toolbar {     display: flex;     justify-content: flex-end;     padding: 8px;   }     &__save-button,   &__action-button {     background: none;     border: none;     padding: 4px;     cursor: pointer;          &:disabled {       opacity: 0.5;       cursor: not-allowed;     }       .material-icons {       font-size: 18px;     }   }     input, select {     width: 100%;     padding: 4px;     border: 1px solid #ddd;     border-radius: 4px;          &:focus {       outline: none;       border-color: #007bff;     }   } }
|   |   |   +-- ixt-matrix.component.ts: import { ChangeDetectorRef, Component, Input, OnInit, TemplateRef, ViewChild, Type } from '@angular/core'; import { FormControl } from '@angular/forms'; import { ColumnConfig, FilterOperator, FilterState, MatrixNode, PageSize, RowChanges } from './ixt-matrix.interfaces'; import { debounceTime, distinctUntilChanged } from 'rxjs/operators'; import { MatrixEditor } from './matrix-editors/editor.interface'; import { IxtDialogService } from '../ixt-dialog/ixt-dialog.index'; import { AirportCodeEditorComponent } from './matrix-editors/airport-code/airport-code-editor.component'; import { CoordinateEditorComponent } from './matrix-editors/coordinate/coordinate-editor.component'; import { PaginationService } from './services/pagination.service'; import { FilterService } from './services/filter/filter.service'; import { SortService } from './services/sort/sort.service'; import { SelectionService } from './services/selection/selection.service'; import { EditService } from './services/edit/edit.service';  export type SortDirection = 'asc' | 'desc' | null;  @Component({   selector: 'ixt-matrix',   templateUrl: './ixt-matrix.component.html',   styleUrls: ['./ixt-matrix.component.scss'] }) export class IxtMatrixComponent implements OnInit {   @Input() data: MatrixNode[] = [];   @Input() columnConfigs?: Record<string, ColumnConfig>;   @ViewChild('noData') noDataTemplate!: TemplateRef<any>;   @ViewChild('customEditorTpl') customEditorTpl!: TemplateRef<any>;    columns: string[] = [];   pageSizeControl = new FormControl<number | 'all'>(10);   readonly AirportCodeEditorComponent = AirportCodeEditorComponent;   readonly CoordinateEditorComponent = CoordinateEditorComponent;    constructor(     private dialogService: IxtDialogService,     private changeDetectorRef: ChangeDetectorRef,     private paginationService: PaginationService,     private filterService: FilterService,     private sortService: SortService,     private selectionService: SelectionService,     private editService: EditService     ) { }    ngOnInit() {     this.columns = this.getColumns(this.data);      // Initialize pagination     this.paginationService.initialize(this.data.length);      // Initialize filters     if (this.columnConfigs) {       Object.entries(this.columnConfigs).forEach(([field, config]) => {         this.filterService.initializeFilter(field, config);          // Get the control from service and subscribe to changes         const control = this.filterService.getFilterControl(field);         if (control) {           control.valueChanges.pipe(             debounceTime(config.debounceTime || 300),             distinctUntilChanged()           ).subscribe(value => {             this.filterService.onFilterChange(field, value, config);           });         }       });     }      // Subscribe to filter changes     this.filterService.filtersChanged$.subscribe(() => {       this.changeDetectorRef.markForCheck();     });      // Subscribe to pagination changes     this.paginationService.state$.subscribe(() => {       this.changeDetectorRef.markForCheck();     });      // Subscribe to page size changes     this.pageSizeControl.valueChanges.subscribe(value => {       if (value) {         this.paginationService.onPageSizeChange(value);       }     });   }    // edit logic start   addNewRow(): void {     this.editService.addNewRow(this.columnConfigs || {});   }    cancelEditing(rowIndex: number): void {     this.editService.cancelEditing(rowIndex);   }    getEditorComponent(type: any): MatrixEditor | null {     console.log('getEditorComponent called with:', {       type,       isCoordinate: type === CoordinateEditorComponent,       isAirport: type === AirportCodeEditorComponent     });      if (type === AirportCodeEditorComponent) {       return new AirportCodeEditorComponent(this.dialogService);     }     if (type === CoordinateEditorComponent) {       return new CoordinateEditorComponent(this.dialogService);     }     return null;   }    getEditorType(type: any): string {     console.log('getEditorType called with:', {       type,       isString: typeof type === 'string',       isCoordinate: type === CoordinateEditorComponent,       isAirport: type === AirportCodeEditorComponent     });      if (typeof type === 'string') {       return type;     }     if (type === AirportCodeEditorComponent || type === CoordinateEditorComponent) {       console.log('Returning custom for editor type');       return 'custom';     }     console.log('Falling back to text type');     return 'text';   }    getEditControl(rowIndex: number, field: string): FormControl {     return this.editService.getEditControl(rowIndex, field);   }    getRowIndex(displayIndex: number): number {     return this.editService.getRowIndex(displayIndex);   }    get hasChanges(): boolean {     return this.editService.hasChanges();   }    isEditing(index: number): boolean {     return this.editService.isEditing(index);   }    isNewRow(displayIndex: number): boolean {     return this.editService.isNewRow(displayIndex);   }    get newRowsLength(): number {     return this.editService.getNewRows().length;   }    onValueChange(rowIndex: number, field: string, value: any): void {     this.editService.onValueChange({ rowIndex, field, value });   }    saveChanges(): void {     this.data = this.editService.saveChanges(this.data);     this.changeDetectorRef.markForCheck();   }    startEditing(rowIndex: number): void {     this.editService.startEditing(rowIndex);   }   // edit logic end    // filter logic start   get activeFilterColumn(): string | undefined {     return this.filterService.activeColumn;   }    getFilterControl(col: string): FormControl<any> {     return this.filterService.getFilterControl(col)!;   }    getOperatorControl(col: string): FormControl<string> {     return this.filterService.getOperatorControl(col)!;   }    onOperatorChange(field: string): void {     this.filterService.onOperatorChange(field);   }    get showFilters(): boolean {     return this.filterService.isShowingFilters;   }    toggleFilters(col: string): void {     this.filterService.toggleFilters(col);   }   // filter logic end      // pagination logic start   get currentPage(): number {     return this.paginationService.getCurrentPage();   }    onPageChange(page: number): void {     this.paginationService.onPageChange(page);   }    onPageSizeChange(size: number | 'all'): void {     this.paginationService.onPageSizeChange(size);   }    get paginatedData(): MatrixNode[] {     // Start with combined data     let allData = [...this.editService.getNewRows(), ...this.data];        // Apply filters     if (this.filterService.hasActiveFilters()) {       const activeFilters = this.filterService.getActiveFilters();       const filteredExisting = this.data.filter(item =>         Array.from(activeFilters.values()).every(filter =>           this.filterService.matchesFilter(item[filter.field], filter)         )       );       allData = [...this.editService.getNewRows(), ...filteredExisting];     }        // Apply sorting     allData = this.sortService.sortData(allData);        // Apply pagination     return this.paginationService.getPaginatedData(allData);   }    get pageSizes(): PageSize[] {     return this.paginationService.getPageSizes();   }    get showPagination(): boolean {     return this.paginationService.shouldShowPagination();   }    get totalPages(): number {     return this.paginationService.getTotalPages();   }    get visiblePages(): number[] {     return this.paginationService.getVisiblePages();   }   // pagination logic end    // selection logic start   get allSelected(): boolean {     return this.selectionService.isAllSelected();   }    set allSelected(value: boolean) {     this.selectionService.toggleAllRows(value, this.data.length);   }    getSelectedRows(): MatrixNode[] {     return Array.from(this.selectionService.getSelectedRows())       .map(index => this.data[index])       .filter(row => row !== undefined);   }    get hasSelectedRows(): boolean {     return this.selectionService.getSelectedCount() > 0;   }    isRowSelected(index: number): boolean {     return this.selectionService.isSelected(index);   }    selectRow(index: number, selected = true): void {     this.selectionService.selectRow(index, selected);   }    setSelectedRows(indices: number[]): void {     this.selectionService.setSelectedRows(indices);   }    toggleAllRows(selected: boolean): void {     this.selectionService.toggleAllRows(selected, this.data.length);   }   // selection logic end    // sort logic start   getSortIcon(column: string): string {     return this.sortService.getSortIcon(column);   }    toggleSort(column: string): void {     this.sortService.toggleSort(column);   }   // sort logic end    // i/o logic start   formatCoordinate(value: number): string {     return value.toFixed(1);   }    getCodes(data: MatrixNode[]): string[] {     if (!data) return [];     return data.map(row => row['code']?.toString() || '');   }   // i/o logic end    // config logic start   getColumns(data: MatrixNode[]): string[] {     if (!data?.length) return [];     const firstRow = data[0];     return Object.keys(firstRow);   }    get hasData(): boolean {     return !!this.data?.length;   }   // config logic end }
|   |   |   +-- ixt-matrix.index.ts: // src/components/ixt-matrix/index.ts // Fix these import paths to match your folder structure export * from './ixt-matrix.component'; export * from './ixt-matrix.interfaces'; export * from './ixt-matrix.module'; export interface MatrixNode {     [key: string]: any;     children?: MatrixNode[]; } export * from './matrix-editors/airport-code/airport-code-editor.component'; export * from './matrix-editors/binary-editor/binary-editor.component'; export * from './matrix-editors/coordinate/coordinate-editor.component'; 
|   |   |   +-- ixt-matrix.interfaces.ts: import { Type } from "@angular/core"; import { MatrixEditor } from "./matrix-editors/editor.interface";  export interface MatrixNode {   code?: string;  // Add this property   [key: string]: any; }  export interface PageSize {   value: number | 'all';   label: string; }  export type FilterOperator = 'equals' | 'startsWith' | 'contains' | 'between' | '>' | '<' | '>=' | '<=' | '!=';  export interface FilterState {   field: string;   operator: FilterOperator;   value: any;   secondaryValue?: any; }  export interface ColumnConfig {   type: 'text' | 'number' | 'enum' | Type<MatrixEditor> | MatrixEditor;     field: string;   label?: string;   operator?: FilterOperator;   enumValues?: { value: any, label: string }[];   placeholder?: string;   debounceTime?: number;   editable?: boolean;   config?: any; }  export interface RowChanges {   [key: string]: any; }  export type ColumnConfigs = Record<string, ColumnConfig>;
|   |   |   +-- ixt-matrix.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { MatIconModule } from '@angular/material/icon'; import { MatAutocompleteModule } from '@angular/material/autocomplete'; import { IxtMatrixComponent } from './ixt-matrix.component'; import { AirportCodeEditorComponent } from './matrix-editors/airport-code/airport-code-editor.component'; import { CoordinateEditorComponent } from './matrix-editors/coordinate/coordinate-editor.component'; import { BinaryEditorComponent } from './matrix-editors/binary-editor/binary-editor.component';   @NgModule({   declarations: [     IxtMatrixComponent,     AirportCodeEditorComponent,     CoordinateEditorComponent,     BinaryEditorComponent   ],   imports: [     CommonModule,     FormsModule,           // Make sure this is here     ReactiveFormsModule,     MatIconModule,     MatAutocompleteModule   ],   exports: [IxtMatrixComponent] }) export class IxtMatrixModule { }
|   |   |   +-- matrix-base.type.ts: export interface MatrixRow {     [key: string]: any; }
|   |   |   +-- matrix-data.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject, combineLatest, Observable } from 'rxjs'; import { map } from 'rxjs/operators'; import { MatrixRow } from './matrix-base.type'; import { PageSize } from './ixt-matrix.interfaces';  export interface PaginationState {     currentPage: number;     pageSize: number | 'all';     totalPages: number; }  @Injectable({     providedIn: 'root' }) export class MatrixDataService {     private dataSubject = new BehaviorSubject<MatrixRow[]>([]);     private newRowsSubject = new BehaviorSubject<MatrixRow[]>([]);     private paginationStateSubject = new BehaviorSubject<PaginationState>({         currentPage: 1,         pageSize: 10,         totalPages: 1     });      readonly pageSizes: PageSize[] = [         { value: 10, label: '10' },         { value: 100, label: '100' },         { value: 'all', label: 'All' }     ];      constructor() { }      // Data operations     setData(data: MatrixRow[]): void {         this.dataSubject.next(data);         this.updateTotalPages();     }      getData(): Observable<MatrixRow[]> {         return this.dataSubject.asObservable();     }      // New rows operations     addNewRow(row: MatrixRow): void {         const currentNewRows = this.newRowsSubject.value;         this.newRowsSubject.next([row, ...currentNewRows]);     }      getNewRows(): Observable<MatrixRow[]> {         return this.newRowsSubject.asObservable();     }      commitNewRows(): void {         const currentData = this.dataSubject.value;         const newRows = this.newRowsSubject.value;         this.dataSubject.next([...newRows, ...currentData]);         this.newRowsSubject.next([]);         this.updateTotalPages();     }      // Pagination operations     setPaginationState(state: Partial<PaginationState>): void {         const currentState = this.paginationStateSubject.value;         this.paginationStateSubject.next({ ...currentState, ...state });         this.updateTotalPages();     }      getPaginationState(): Observable<PaginationState> {         return this.paginationStateSubject.asObservable();     }      getPaginatedData(): Observable<MatrixRow[]> {         return this.combineData().pipe(             map(allData => this.paginateData(allData))         );     }      private combineData(): Observable<MatrixRow[]> {         return combineLatest([             this.dataSubject,             this.newRowsSubject         ]).pipe(             map(([data, newRows]) => [...newRows, ...data])         );     }      private paginateData(data: MatrixRow[]): MatrixRow[] {         const state = this.paginationStateSubject.value;          if (state.pageSize === 'all' || data.length <= 50) {             return data;         }          const start = (state.currentPage - 1) * (+state.pageSize);         const end = start + (+state.pageSize);         return data.slice(start, end);     }      private updateTotalPages(): void {         const currentState = this.paginationStateSubject.value;         const totalItems = this.dataSubject.value.length + this.newRowsSubject.value.length;          const totalPages = currentState.pageSize === 'all' || totalItems <= 50             ? 1             : Math.ceil(totalItems / +currentState.pageSize);          this.paginationStateSubject.next({             ...currentState,             totalPages         });     } }
|   |   |   +-- matrix-editors
|   |   |   |   +-- DatePickerComponent.ts: // matrix-editors/date-picker.component.ts import { Component, Input, Output, EventEmitter } from '@angular/core';  @Component({   selector: 'ixt-date-picker',   template: `     <input        type="date"       [value]="value | date:'yyyy-MM-dd'"       (change)="onChange($event)"       class="ixt-date-picker__input">   `,   styles: [`     .ixt-date-picker__input {       width: 100%;       padding: 4px;       border: 1px solid #ddd;       border-radius: 4px;     }   `] }) export class DatePickerComponent {   @Input() value: Date | null = null;   @Output() valueChange = new EventEmitter<Date>();      onChange(event: Event) {     const value = (event.target as HTMLInputElement).value;     this.valueChange.emit(new Date(value));   } }
|   |   |   |   +-- airport-code
|   |   |   |   |   -- airport-code-editor.component.ts: // src/components/ixt-matrix/matrix-editors/airport-code/airport-code-editor.component.ts import { Component, Input, forwardRef, OnInit, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { IxtDialogService } from '../../../ixt-dialog/ixt-dialog.service'; import { MatrixEditor, MatrixEditorConfig } from '../editor.interface'; import { DialogType } from '../../../ixt-dialog/ixt-dialog.interfaces';  @Component({   selector: 'airport-code-editor',   template: `     <div class="editor-container">       <input         type="text"         [formControl]="inputControl"         class="w-24 px-2 py-1 border rounded"         [class.border-red-500]="hasError"         [attr.maxlength]="config?.['maxLength'] || 3"         (blur)="onBlur()"       />       <div *ngIf="hasError" class="text-red-500 text-sm mt-1">         {{ errorMessage }}       </div>     </div>   `,   styles: [`     .editor-container {       position: relative;     }   `],   providers: [     {       provide: NG_VALUE_ACCESSOR,       useExisting: forwardRef(() => AirportCodeEditorComponent),       multi: true     }   ] }) export class AirportCodeEditorComponent implements ControlValueAccessor, OnInit, MatrixEditor {   @Input() config?: MatrixEditorConfig;   @Input() existingCodes: string[] = [];    // airport-code-editor.component.ts   @Input() field: string = 'code';    inputControl = new FormControl('');   hasError = false;   errorMessage = '';    // MatrixEditor implementation   component: Type<any> = AirportCodeEditorComponent;    private onChange: (value: string) => void = () => { };   private onTouch: () => void = () => { };    constructor(private dialogService: IxtDialogService) { }    ngOnInit() {     this.setupValueChanges();   }    // MatrixEditor methods   getEditConfig(): MatrixEditorConfig {     return {       existingValues: this.existingCodes,       maxLength: 3,       pattern: /^[A-Z]+$/     };   }    getDefaultValue(): string {     return '';   }    validate(value: any): boolean {     if (!value) return false;     const code = String(value).toUpperCase();     if (code.length !== 3) return false;     if (!/^[A-Z]+$/.test(code)) return false;     if (this.existingCodes.includes(code)) return false;     return true;   }    format(value: any): string {     return value ? String(value).toUpperCase() : '';   }      // private setupValueChanges() {   //   debugger;   //   this.inputControl.valueChanges.subscribe(value => {   //     if (value !== null) {   //       const upperValue = value.toUpperCase();   //       if (this.validateValue(upperValue)) {   //         this.onChange(upperValue);   //       }   //     }   //   });   // }    private setupValueChanges() {     this.inputControl.valueChanges.subscribe(value => {       if (value !== null) {         const upperValue = value.toUpperCase();         if (upperValue !== value) {           this.inputControl.setValue(upperValue, { emitEvent: false });         }         if (this.validateValue(upperValue)) {           console.log('Editor emitting code change:', upperValue);           this.onChange(upperValue);  // This triggers the form control change         }       }     });   }    private validateValue(value: string): boolean {     this.hasError = false;     this.errorMessage = '';      if (!value) return false;      if (value.length !== (this.config?.['maxLength'] || 3)) {       this.hasError = true;       this.errorMessage = `Code must be exactly ${this.config?.['maxLength'] || 3} characters`;       return false;     }      const pattern = this.config?.['pattern'] || /^[A-Z]+$/;     if (!pattern.test(value)) {       this.hasError = true;       this.errorMessage = 'Only letters are allowed';       return false;     }      if (this.config?.existingValues?.includes(value)) {       this.hasError = true;       this.errorMessage = 'This code already exists';       this.dialogService.show({         title: 'Duplicate Code',         message: `The code "${value}" already exists. Please enter a different code.`,         type: DialogType.Warning       });       return false;     }      return true;   }    // // ControlValueAccessor methods   // writeValue(value: string): void {   //   this.inputControl.setValue(value, { emitEvent: false });   // }    // registerOnChange(fn: any): void {   //   this.onChange = fn;   // }     // These methods are already in your component at the bottom   writeValue(value: string): void {     console.log('AirportCodeEditor writeValue:', value);     this.inputControl.setValue(value, { emitEvent: false });   }    registerOnChange(fn: any): void {     console.log('AirportCodeEditor registerOnChange');     this.onChange = fn;   }    registerOnTouched(fn: any): void {     this.onTouch = fn;   }    onBlur(): void {     this.onTouch();   }    setDisabledState(isDisabled: boolean): void {     if (isDisabled) {       this.inputControl.disable();     } else {       this.inputControl.enable();     }   } }
|   |   |   |   +-- binary-editor
|   |   |   |   |   -- binary-editor.component.ts: // src/components/ixt-matrix/matrix-editors/binary-editor/binary-editor.component.ts import { Component, Input, forwardRef, Output, EventEmitter, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { MatrixEditor, MatrixEditorConfig } from '../editor.interface';  interface BinaryConfig extends MatrixEditorConfig {   trueValue?: any;   falseValue?: any;   trueDisplay?: string;   falseDisplay?: string;   rowData?: any;   rowIndex?: number; }  interface SelectionEvent {   selected: boolean;   rowData?: any;   rowIndex?: number; }  @Component({   selector: 'binary-editor',   template: `     <div class="editor-container">       <input         type="checkbox"         [formControl]="inputControl"         [checked]="isChecked"         (change)="onCheckboxChange($event)"         class="w-4 h-4 rounded border-gray-300"       />       <span *ngIf="showLabel" class="ml-2">         {{ isChecked ? config.trueDisplay : config.falseDisplay }}       </span>     </div>   `,   providers: [     {       provide: NG_VALUE_ACCESSOR,       useExisting: forwardRef(() => BinaryEditorComponent),       multi: true     }   ] }) export class BinaryEditorComponent implements ControlValueAccessor, MatrixEditor {   @Input() config: BinaryConfig = {};   @Output() selectionChange = new EventEmitter<SelectionEvent>();    inputControl = new FormControl<boolean | null>(false);   component: Type<any> = BinaryEditorComponent;   showLabel = false;   isChecked = false;    private onChange: (value: any) => void = () => { };   private onTouch: () => void = () => { };    constructor() {     this.setupDefaults();     this.isChecked = false;   }    ngOnInit() {     this.setupDefaults();     this.setupValueChanges();   }    private setupDefaults() {     this.config = {       trueValue: true,       falseValue: false,       trueDisplay: 'True',       falseDisplay: 'False',       ...this.config     };   }    private setupValueChanges(): void {     this.inputControl.valueChanges.subscribe((checked: boolean | null) => {       if (checked !== null) {         const value = checked ? this.config.trueValue : this.config.falseValue;         this.isChecked = checked;         this.onChange(value);          this.selectionChange.emit({           selected: checked,           rowData: this.config.rowData,           rowIndex: this.config.rowIndex         });       }     });   }    onCheckboxChange(event: Event) {     const checkbox = event.target as HTMLInputElement;     this.inputControl.setValue(checkbox.checked);     this.onTouch();   }    getEditConfig(): BinaryConfig {     return {       trueValue: this.config.trueValue || true,       falseValue: this.config.falseValue || false,       trueDisplay: this.config.trueDisplay || 'True',       falseDisplay: this.config.falseDisplay || 'False'     };   }    writeValue(value: any): void {     const checked = value === this.config.trueValue;     this.isChecked = checked;     this.inputControl.setValue(checked, { emitEvent: false });   }    registerOnChange(fn: any): void {     this.onChange = fn;   }    registerOnTouched(fn: any): void {     this.onTouch = fn;   }    setDisabledState(isDisabled: boolean): void {     if (isDisabled) {       this.inputControl.disable();     } else {       this.inputControl.enable();     }   } }
|   |   |   |   +-- color.editor.ts: 
|   |   |   |   +-- coordinate
|   |   |   |   |   -- coordinate-editor.component.ts: // src/components/ixt-matrix/matrix-editors/coordinate/coordinate-editor.component.ts import { Component, Input, forwardRef, OnInit, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { IxtDialogService } from '../../../ixt-dialog/ixt-dialog.service'; import { MatrixEditor, MatrixEditorConfig } from '../editor.interface'; import { DialogType } from '../../../ixt-dialog/ixt-dialog.interfaces';  @Component({     selector: 'coordinate-editor',     template: `    <div class="editor-container">      <input         type="number"         step="any"         [min]="config?.['type'] === 'lat' ? -90 : -180"         [max]="config?.['type'] === 'lat' ? 90 : 180"         [formControl]="inputControl"         class="w-24 px-2 py-1 border rounded"         [class.border-red-500]="hasError"         [placeholder]="config?.['type'] === 'lat' ? '(-90 to 90)' : '(-180 to 180)'"         (blur)="onBlur()"     />      <div *ngIf="hasError" class="text-red-500 text-sm mt-1">        {{ errorMessage }}      </div>    </div>`,     providers: [         {             provide: NG_VALUE_ACCESSOR,             useExisting: forwardRef(() => CoordinateEditorComponent),             multi: true         }     ] }) export class CoordinateEditorComponent implements ControlValueAccessor, OnInit, MatrixEditor {     @Input() config?: MatrixEditorConfig;      inputControl = new FormControl('');     hasError = false;     errorMessage = '';      // MatrixEditor implementation     component: Type<any> = CoordinateEditorComponent;      private onChange: (value: number) => void = () => { };     private onTouch: () => void = () => { };      constructor(private dialogService: IxtDialogService) { }      ngOnInit() {         this.setupValueChanges();     }      getEditConfig(): MatrixEditorConfig {         return {             type: this.config?.['type'] || 'lat'         };     }      validate(value: any): boolean {         const num = Number(value);         const isLat = this.config?.['type'] === 'lat';         return isLat ? (num >= -90 && num <= 90) : (num >= -180 && num <= 180);     }      // private setupValueChanges() {     //     this.inputControl.valueChanges.subscribe(value => {     //         if (value !== null) {     //             // Convert string to number for validation     //             const numValue = Number(value);     //             if (this.validateValue(numValue)) {     //                 this.onChange(numValue);     //             }     //         }     //     });     // }      setupValueChanges() {         this.inputControl.valueChanges.subscribe(value => {           if (value !== null) {             const numValue = Number(value);             if (!isNaN(numValue) && this.validateValue(numValue)) {               this.onChange(numValue);             } else {               // Reset to last valid value or empty               this.inputControl.setValue('', {emitEvent: false});             }           }         });       }      private validateValue(value: number): boolean {         this.hasError = false;         this.errorMessage = '';          if (isNaN(value)) {             this.hasError = true;             this.errorMessage = 'Must be a valid number';             return false;         }          const isLat = this.config?.['type'] === 'lat';         const min = isLat ? -90 : -180;         const max = isLat ? 90 : 180;          if (value < min || value > max) {             this.hasError = true;             this.errorMessage = `Must be between ${min} and ${max}`;             return false;         }          return true;     }      // ControlValueAccessor methods     writeValue(value: number): void {         this.inputControl.setValue(value?.toString() || '', { emitEvent: false });     }      registerOnChange(fn: any): void {         this.onChange = fn;     }      registerOnTouched(fn: any): void {         this.onTouch = fn;     }      onBlur(): void {         this.onTouch();     } }
|   |   |   |   +-- date.editor.ts: import { Injectable } from "@angular/core"; import { MatrixEditor } from "./editor.interface"; import { formatDate } from "@angular/common"; import { DatePickerComponent } from "./DatePickerComponent";  // matrix-editors/date.editor.ts @Injectable() export class DateEditor implements MatrixEditor {   component = DatePickerComponent;      getEditConfig() {     return {       format: 'yyyy-MM-dd',       showTimeSelect: false     };   }    format(value: Date): string {     return formatDate(value, 'shortDate', 'en-US');   } } 
|   |   |   |   -- editor.interface.ts: import { Type } from "@angular/core";  export interface MatrixEditorConfig {   existingValues?: any[];   validators?: any[];   field?: string;   [key: string]: any; }    export interface MatrixEditor {   component: Type<any>;   getEditConfig(): any;   validate?(value: any): boolean;   format?(value: any): string;   getDefaultValue?(): any; }  
|   |   |   -- services
|   |   |      +-- edit
|   |   |      |   +-- edit.model.ts: // src/components/ixt-matrix/services/edit/edit.model.ts import { FormControl } from '@angular/forms';  export interface RowChanges {   [key: string]: any; }  export interface EditState {   editingRows: Set<number>;   newRows: any[];   rowChanges: Map<number, RowChanges>;   editControls: Map<string, FormControl>; }  export interface EditEvent {   rowIndex: number;   field: string;   value: any; }
|   |   |      |   -- edit.service.ts: // src/components/ixt-matrix/services/edit/edit.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { FormControl } from '@angular/forms'; import { EditState, RowChanges, EditEvent } from './edit.model'; import { ColumnConfig } from '../../ixt-matrix.interfaces';  @Injectable({   providedIn: 'root' }) export class EditService {   private readonly initialState: EditState = {     editingRows: new Set<number>(),     newRows: [],     rowChanges: new Map<number, RowChanges>(),     editControls: new Map<string, FormControl>()   };    private state = new BehaviorSubject<EditState>(this.initialState);   public state$ = this.state.asObservable();    private getDefaultValueForType(type: string | any): any {     switch (type) {       case 'number':         return 0;       case 'enum':         return '';       case 'text':       default:         return '';     }   }    public addNewRow(columnConfigs: Record<string, ColumnConfig>): void {     const newRow: any = {};     if (columnConfigs) {       Object.entries(columnConfigs).forEach(([field, config]) => {         newRow[field] = this.getDefaultValueForType(config.type);       });     }      const currentState = this.state.getValue();     const newRows = [...currentState.newRows];     newRows.unshift(newRow);      // Start editing the new row     const editingRows = new Set(currentState.editingRows);     editingRows.add(-newRows.length);      this.state.next({       ...currentState,       newRows,       editingRows     });   }    public startEditing(rowIndex: number): void {     const currentState = this.state.getValue();     const editingRows = new Set(currentState.editingRows);     editingRows.add(rowIndex);      this.state.next({       ...currentState,       editingRows     });   }    public cancelEditing(rowIndex: number): void {     const currentState = this.state.getValue();     const editingRows = new Set(currentState.editingRows);     const rowChanges = new Map(currentState.rowChanges);      editingRows.delete(rowIndex);     rowChanges.delete(rowIndex);      this.state.next({       ...currentState,       editingRows,       rowChanges     });   }    public onValueChange(event: EditEvent): void {     const { rowIndex, field, value } = event;     const currentState = this.state.getValue();     const rowChanges = new Map(currentState.rowChanges);      let changes = rowChanges.get(rowIndex) || {};     changes = { ...changes, [field]: value };     rowChanges.set(rowIndex, changes);      this.state.next({       ...currentState,       rowChanges     });   }    public getEditControl(rowIndex: number, field: string): FormControl {     const key = `${rowIndex}-${field}`;     const currentState = this.state.getValue();     let control = currentState.editControls.get(key);      if (!control) {       control = new FormControl('');       const editControls = new Map(currentState.editControls);       editControls.set(key, control);        this.state.next({         ...currentState,         editControls       });     }      return control;   }    public saveChanges(data: any[]): any[] {     const currentState = this.state.getValue();     const updatedData = [...data];      // Apply changes to existing rows     currentState.rowChanges.forEach((changes, rowIndex) => {       if (rowIndex >= 0) {         updatedData[rowIndex] = {           ...updatedData[rowIndex],           ...changes         };       }     });      // Add new rows     if (currentState.newRows.length) {       // Apply any changes to new rows       const processedNewRows = currentState.newRows.map((row, index) => {         const changes = currentState.rowChanges.get(-index - 1);         return changes ? { ...row, ...changes } : row;       });        updatedData.unshift(...processedNewRows);     }      // Reset state     this.state.next(this.initialState);      return updatedData;   }    public isNewRow(index: number): boolean {     return index < this.state.getValue().newRows.length;   }    public isEditing(rowIndex: number): boolean {     return this.state.getValue().editingRows.has(rowIndex);   }    public hasChanges(): boolean {     const currentState = this.state.getValue();     return currentState.rowChanges.size > 0 || currentState.newRows.length > 0;   }    public getNewRows(): any[] {     return this.state.getValue().newRows;   }    public getRowChanges(rowIndex: number): RowChanges | undefined {     return this.state.getValue().rowChanges.get(rowIndex);   }    public getRowIndex(displayIndex: number): number {     return displayIndex - this.state.getValue().newRows.length;   }    public clearEditing(): void {     this.state.next(this.initialState);   } }
|   |   |      +-- filter
|   |   |      |   +-- filter.model.ts: // src/components/ixt-matrix/services/filter/filter.model.ts import { FormControl } from '@angular/forms';  export type FilterOperator = 'equals' | 'startsWith' | 'contains' | 'between' | '>' | '<' | '>=' | '<=' | '!=';  export interface FilterState {   field: string;   operator: FilterOperator;   value: any;   secondaryValue?: any; }  export interface FilterControls {   value: FormControl;   operator?: FormControl<string>; }
|   |   |      |   -- filter.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; import { FormControl } from '@angular/forms'; import { FilterState, FilterOperator, FilterControls } from './filter.model'; import { ColumnConfig } from '../../ixt-matrix.interfaces';  @Injectable({   providedIn: 'root' }) export class FilterService {   private activeFilters = new Map<string, FilterState>();   private filterControls = new Map<string, FilterControls>();   private activeFilterColumn?: string;   private showFilters = false;    private filtersChanged = new BehaviorSubject<Map<string, FilterState>>(new Map());   public filtersChanged$ = this.filtersChanged.asObservable();    public initializeFilter(field: string, config: ColumnConfig): void {     const controls: FilterControls = {       value: new FormControl('')     };      if (config.type === 'number') {       // Fix: Explicitly type the FormControl       controls.operator = new FormControl<string>('=', { nonNullable: true });     }      this.filterControls.set(field, controls);   }       public getFilterControl(field: string): FormControl | undefined {     return this.filterControls.get(field)?.value;   }    public getOperatorControl(field: string): FormControl<string> | undefined {     return this.filterControls.get(field)?.operator;   }    public onFilterChange(field: string, value: any, config?: ColumnConfig): void {     if (value || value === 0) {       const defaultOperator: FilterOperator = config?.type === 'number' ? 'equals' : 'contains';       const operator = this.getOperatorControl(field)?.value || defaultOperator;        this.activeFilters.set(field, {         field,         operator: operator as FilterOperator,         value: config?.type === 'number' ? Number(value) : value       });     } else {       this.activeFilters.delete(field);     }      this.filtersChanged.next(this.activeFilters);   }    public onOperatorChange(field: string): void {     const currentValue = this.getFilterControl(field)?.value;     if (currentValue || currentValue === 0) {       this.onFilterChange(field, currentValue);     }   }    public clearAllFilters(): void {     this.activeFilters.clear();     this.filterControls.forEach(controls => {       controls.value.reset();       controls.operator?.reset('=');     });     this.filtersChanged.next(this.activeFilters);   }    public toggleFilters(column: string): void {     if (this.activeFilterColumn === column) {       this.activeFilterColumn = undefined;       this.showFilters = false;     } else {       this.activeFilterColumn = column;       this.showFilters = true;     }   }    public matchesFilter(item: any, filter: FilterState): boolean {     if (item === undefined || item === null) return false;      // Handle numeric comparisons     if (typeof item === 'number' || !isNaN(Number(item))) {       const numValue = Number(item);       const numFilterValue = Number(filter.value);       return this.handleNumericComparison(numValue, numFilterValue, filter.operator);     }      // String handling     const itemValue = String(item).toLowerCase();     const filterValue = String(filter.value).toLowerCase();      switch (filter.operator) {       case 'startsWith':         return itemValue.startsWith(filterValue);       case 'equals':         return itemValue === filterValue;       case '!=':         return itemValue !== filterValue;       default:         return itemValue.includes(filterValue);     }   }    private handleNumericComparison(numValue: number, numFilterValue: number, operator: FilterOperator): boolean {     switch (operator) {       case '>': return numValue > numFilterValue;       case '<': return numValue < numFilterValue;       case '>=': return numValue >= numFilterValue;       case '<=': return numValue <= numFilterValue;       case '!=': return numValue !== numFilterValue;       case 'equals': return numValue === numFilterValue;       default: return false;     }   }    public get isShowingFilters(): boolean {     return this.showFilters;   }    public get activeColumn(): string | undefined {     return this.activeFilterColumn;   }    public getActiveFilters(): Map<string, FilterState> {     return this.activeFilters;   }    public hasActiveFilters(): boolean {     return this.activeFilters.size > 0;   } }
|   |   |      +-- pagination.model.ts: // src/components/ixt-matrix/services/pagination/pagination.model.ts export interface PaginationState {     currentPage: number;     pageSize: number | 'all';     totalItems: number;   }      export interface PageSize {     value: number | 'all';     label: string;   }   
|   |   |      +-- pagination.service.ts:  // src/components/ixt-matrix/services/pagination/pagination.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; import { PageSize, PaginationState } from './pagination.model';  @Injectable({   providedIn: 'root' }) export class PaginationService {   private readonly DEFAULT_PAGE_SIZES: PageSize[] = [     { value: 10, label: '10' },     { value: 100, label: '100' },     { value: 'all', label: 'All' }   ];    private readonly MINIMUM_ROWS_FOR_PAGINATION = 50;    private state = new BehaviorSubject<PaginationState>({     currentPage: 1,     pageSize: 10,     totalItems: 0   });    public state$ = this.state.asObservable();    public initialize(totalItems: number): void {     this.updateState({       currentPage: 1,       pageSize: 10,       totalItems     });   }    public shouldShowPagination(): boolean {     return this.state.getValue().totalItems > this.MINIMUM_ROWS_FOR_PAGINATION;   }    public getCurrentPage(): number {     return this.state.getValue().currentPage;   }    public getPageSize(): number | 'all' {     return this.state.getValue().pageSize;   }    public getPageSizes(): PageSize[] {     return this.DEFAULT_PAGE_SIZES;   }    public getTotalPages(): number {     const { totalItems, pageSize } = this.state.getValue();     if (pageSize === 'all' || totalItems <= this.MINIMUM_ROWS_FOR_PAGINATION) {       return 1;     }     return Math.ceil(totalItems / +pageSize);   }    public getVisiblePages(): number[] {     const totalPages = this.getTotalPages();     const currentPage = this.getCurrentPage();      if (totalPages <= 1) return [];      const pages: number[] = [1];     const WINDOW_SIZE = 4;      let start = Math.max(2, currentPage - WINDOW_SIZE);     let end = Math.min(totalPages - 1, currentPage + WINDOW_SIZE);      if (start > 2) {       pages.push(-1);     }      for (let i = start; i <= end; i++) {       pages.push(i);     }      if (end < totalPages - 1) {       pages.push(-1);     }      if (totalPages > 1) {       pages.push(totalPages);     }      return pages;   }    public onPageChange(page: number): void {     const totalPages = this.getTotalPages();     if (page >= 1 && page <= totalPages) {       this.updateState({         ...this.state.getValue(),         currentPage: page       });     }   }    public onPageSizeChange(newSize: number | 'all'): void {     this.updateState({       ...this.state.getValue(),       pageSize: newSize,       currentPage: 1     });   }    public getPaginatedData<T>(data: T[]): T[] {     const { pageSize, currentPage } = this.state.getValue();      if (pageSize === 'all' || data.length <= this.MINIMUM_ROWS_FOR_PAGINATION) {       return data;     }      const start = (currentPage - 1) * (+pageSize);     const end = start + (+pageSize);     return data.slice(start, end);   }    private updateState(newState: Partial<PaginationState>): void {     this.state.next({       ...this.state.getValue(),       ...newState     });   } }
|   |   |      +-- selection
|   |   |      |   +-- selection.model.ts: // src/components/ixt-matrix/services/selection/selection.model.ts export interface SelectionState {     selectedRows: Set<number>;     allSelected: boolean; } 
|   |   |      |   -- selection.service.ts: // src/components/ixt-matrix/services/selection/selection.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { SelectionState } from './selection.model';  @Injectable({     providedIn: 'root' }) export class SelectionService {     private state = new BehaviorSubject<SelectionState>({         selectedRows: new Set<number>(),         allSelected: false     });      public state$ = this.state.asObservable();      public selectRow(index: number, selected: boolean = true): void {         const currentState = this.state.getValue();         const newSelectedRows = new Set(currentState.selectedRows);          if (selected) {             newSelectedRows.add(index);         } else {             newSelectedRows.delete(index);         }          this.state.next({             selectedRows: newSelectedRows,             allSelected: currentState.allSelected         });     }      public toggleAllRows(selected: boolean, totalRows: number): void {         const newSelectedRows = new Set<number>();          if (selected) {             // Add all row indices             for (let i = 0; i < totalRows; i++) {                 newSelectedRows.add(i);             }         }          this.state.next({             selectedRows: newSelectedRows,             allSelected: selected         });     }      public clearSelection(): void {         this.state.next({             selectedRows: new Set<number>(),             allSelected: false         });     }      public getSelectedRows(): Set<number> {         return this.state.getValue().selectedRows;     }      public isSelected(index: number): boolean {         return this.state.getValue().selectedRows.has(index);     }      public isAllSelected(): boolean {         return this.state.getValue().allSelected;     }      public getSelectedCount(): number {         return this.state.getValue().selectedRows.size;     }      public setSelectedRows(indices: number[]): void {         const newSelectedRows = new Set(indices);         this.state.next({             selectedRows: newSelectedRows,             allSelected: false // Reset all selected state when manually setting rows         });     }      public isPartiallySelected(totalRows: number): boolean {         const selectedCount = this.getSelectedCount();         return selectedCount > 0 && selectedCount < totalRows;     } }
|   |   |      -- sort
|   |   |         +-- sort.model.ts: // src/components/ixt-matrix/services/sort/sort.model.ts export type SortDirection = 'asc' | 'desc' | null;  export interface SortState {   column: string | null;   direction: SortDirection; }  
|   |   |         -- sort.service.ts: // src/components/ixt-matrix/services/sort/sort.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { SortState, SortDirection } from './sort.model';  @Injectable({   providedIn: 'root' }) export class SortService {   private readonly initialState: SortState = {     column: null,     direction: null   };    private state = new BehaviorSubject<SortState>(this.initialState);   public state$ = this.state.asObservable();    public toggleSort(column: string): void {     const currentState = this.state.getValue();     let newDirection: SortDirection = null;      if (currentState.column === column) {       // Cycle through: null -> asc -> desc -> null       if (currentState.direction === null) {         newDirection = 'asc';       } else if (currentState.direction === 'asc') {         newDirection = 'desc';       } else {         newDirection = null;       }     } else {       // New column, start with ascending       newDirection = 'asc';     }      this.state.next({       column: newDirection ? column : null,       direction: newDirection     });   }    public getSortIcon(column: string): string {     const { column: sortColumn, direction } = this.state.getValue();          if (sortColumn !== column) {       return 'unfold_more';     }     return direction === 'asc' ? 'arrow_upward' : 'arrow_downward';   }    public sortData<T>(data: T[]): T[] {     const { column, direction } = this.state.getValue();          if (!column || !direction) {       return data;     }      return [...data].sort((a, b) => {       const aVal = a[column as keyof T];       const bVal = b[column as keyof T];        if (aVal == null) return 1;       if (bVal == null) return -1;        let comparison: number;       if (typeof aVal === 'string') {         comparison = String(aVal).toLowerCase().localeCompare(String(bVal).toLowerCase());       } else {         comparison = aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);       }        return direction === 'asc' ? comparison : -comparison;     });   }    public clearSort(): void {     this.state.next(this.initialState);   }    public getCurrentSort(): SortState {     return this.state.getValue();   }    public isColumnSorted(column: string): boolean {     return this.state.getValue().column === column;   }    public getSortDirection(column: string): SortDirection {     const { column: sortColumn, direction } = this.state.getValue();     return sortColumn === column ? direction : null;   } }
|   |   +-- ixt-menu
|   |   |   +-- index.ts: // index.ts export * from './ixt-menu.component'; //export * from './ixt-menu.model';
|   |   |   +-- ixt-menu.component.html: <nav class="navbar" [ngStyle]="themeStyles" fxLayout="row" fxLayoutAlign="start center" fxFill>   <div class="navbar-brand" fxFlex="none">     <a [routerLink]="brandLink" class="brand-link">       <img *ngIf="brandLogo" [src]="brandLogo" alt="Brand Logo" class="brand-logo">       <span class="brand-name">{{ brandName }}</span>     </a>   </div>    <div fxFlex fxLayout="row" [fxLayoutAlign]="linkAlignment + ' center'" class="nav-items">     <a *ngFor="let item of menuItems"         [routerLink]="item.link"         class="nav-link">       {{ item.name }}     </a>   </div>    <div *ngIf="showSearch" fxFlex="none" class="search-container">     <form (ngSubmit)="onSearch($event)" class="search-form">       <div class="input-group">         <input type="text"                 [(ngModel)]="searchTerm"                name="search"                [placeholder]="searchPlaceholder"                class="form-control">         <button type="submit" class="btn">           Search         </button>       </div>     </form>   </div> </nav>
|   |   |   +-- ixt-menu.component.scss: .navbar {   padding: 0.5rem 1rem;   margin: 0;   font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;   font-size: 1rem;   line-height: 1.5;    :host {     display: block;     margin: 0;   }    .navbar-brand {     .brand-link {       display: flex;       align-items: center;       text-decoration: none;       color: inherit;              &:hover {         opacity: 0.9;       }     }      .brand-logo {       height: 30px;       margin-right: 0.5rem;     }      .brand-name {       font-size: 1.25rem;       font-weight: 700;       white-space: nowrap;     }   }    .nav-items {     padding: 0 1rem;   }    .nav-link {     color: inherit;     text-decoration: none;     padding: 0.5rem 0.75rem;     font-weight: 400;     opacity: 0.8;     transition: all 0.15s ease-in-out;      &:hover {       opacity: 0.9;       background-color: var(--theme-hover);     }      &:active {       opacity: 1;       background-color: var(--theme-active);     }   }    .search-container {     .search-form {       margin: 0;     }      .input-group {       display: flex;       align-items: center;       gap: 0.5rem;     }      .form-control {       padding: 0.375rem 0.75rem;       font-size: 1rem;       line-height: 1.5;       color: #212529;       background-color: #fff;       border: 1px solid rgba(255, 255, 255, 0.1);       border-radius: 0.25rem;       transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;              &:focus {         border-color: rgba(255, 255, 255, 0.25);         outline: 0;         box-shadow: 0 0 0 0.25rem rgba(255, 255, 255, 0.1);       }     }      .btn {       padding: 0.375rem 0.75rem;       font-size: 1rem;       line-height: 1.5;       color: inherit;       background-color: transparent;       border: 1px solid currentColor;       border-radius: 0.25rem;       cursor: pointer;       opacity: 0.8;       transition: all 0.15s ease-in-out;        &:hover {         opacity: 1;         background-color: var(--theme-hover);       }        &:active {         background-color: var(--theme-active);       }     }   } }
|   |   |   +-- ixt-menu.component.ts: import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { baseThemeColors } from '../theme/theme.colors'; import { ThemeVariant, ThemeColors } from '../theme/theme.types';  interface MenuItem {   name: string;   link: string; }  interface MenuConfig {   items: MenuItem[]; }  @Component({   selector: 'ixt-menu',   templateUrl: './ixt-menu.component.html',   styleUrls: ['./ixt-menu.component.scss'] }) export class IxtMenuComponent implements OnInit {   @Input() linkAlignment: string = 'start';   @Input() src: string = '';   @Input() brandName: string = '';   @Input() brandLogo?: string;   @Input() brandLink: string = '/';   @Input() showSearch: boolean = false;   @Input() searchPlaceholder: string = 'Search...';      // Theme inputs   @Input() variant: ThemeVariant = 'primary';   @Input() theme: ThemeColors = baseThemeColors;      @Output() searchSubmitted = new EventEmitter<string>();    menuItems: MenuItem[] = [];   searchTerm: string = '';    get themeStyles() {     const colors = this.theme[this.variant];     return {       'background-color': colors.base,       'color': colors.text,       '--theme-hover': colors.hover,       '--theme-active': colors.active     };   }    constructor(private http: HttpClient) { }    ngOnInit(): void {     if (this.src) {       this.loadMenu();     }   }    loadMenu() {     this.http.get<MenuConfig>(this.src).subscribe({       next: (data) => {         this.menuItems = data.items;       },       error: (error) => {         console.error('Error loading menu:', error);       }     });   }    onSearch(event: Event) {     event.preventDefault();     if (this.searchTerm.trim()) {       this.searchSubmitted.emit(this.searchTerm);     }   } }
|   |   |   +-- ixt-menu.model.ts: 
|   |   |   -- ixt-menu.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { FlexLayoutModule } from '@angular/flex-layout'; import { RouterModule } from '@angular/router'; import { IxtMenuComponent } from './ixt-menu.component';  @NgModule({   declarations: [     IxtMenuComponent   ],   imports: [     CommonModule,     FormsModule,     FlexLayoutModule,     RouterModule   ],   exports: [     IxtMenuComponent   ] }) export class IxtMenuModule { }
|   |   +-- ixt-panel
|   |   |   +-- index.ts: export * from './ixt-panel.component'; export * from './ixt-panel.module';  
|   |   |   +-- ixt-panel.component.html: <div class="ixt-panel" [class.bordered]="bordered" [class.elevated]="elevated">     <div class="panel-title" *ngIf="title">       {{ title }}     </div>          <div class="panel-content" [class.with-padding]="padding">       <ng-content></ng-content>     </div>          <div class="panel-caption" *ngIf="caption">       {{ caption }}     </div>   </div>   
|   |   |   +-- ixt-panel.component.scss: :host {     display: flex;     flex-direction: column;     flex: 1;     min-height: 0;    }        .ixt-panel {     display: flex;     flex-direction: column;     flex: 1;     background: #fff;     border-radius: 8px;     overflow: hidden;     min-height: 0;          &.bordered {         border: 1px solid rgba(0, 0, 0, 0.12);     }          &.elevated {         box-shadow: 0 2px 1px -1px rgba(0,0,0,0.2),                     0 1px 1px 0 rgba(0,0,0,0.14),                     0 1px 3px 0 rgba(0,0,0,0.12);     }         .panel-title {         background-color: #0066ff;         color: white;         padding: 16px 20px;         font-size: 16px;         font-weight: 500;         letter-spacing: 0.15px;         line-height: 1.5;         border-radius: 8px 8px 0 0;     }         .panel-content {         flex: 1;         min-height: 0;         overflow: auto;                  &.with-padding {             padding: 20px;         }     }         .panel-caption {         background-color: #f5f5f5;         color: rgba(0, 0, 0, 0.87);         padding: 12px 20px;         font-size: 14px;         border-top: 1px solid rgba(0, 0, 0, 0.12);         border-radius: 0 0 8px 8px;     }    }
|   |   |   +-- ixt-panel.component.ts: import { Component, Input } from '@angular/core';  @Component({   selector: 'ixt-panel',   templateUrl: './ixt-panel.component.html',   styleUrls: ['./ixt-panel.component.scss'] }) export class IxtPanelComponent {   @Input() title?: string;   @Input() caption?: string;   @Input() padding = true;   @Input() bordered = true;   @Input() elevated = false; }
|   |   |   -- ixt-panel.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtPanelComponent } from './ixt-panel.component';  @NgModule({   declarations: [     IxtPanelComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtPanelComponent   ] }) export class IxtPanelModule { } 
|   |   +-- ixt-progress
|   |   |   +-- ixt-progress.component.html: <ng-container *ngIf="config">     <!-- Modal backdrop -->     <div *ngIf="config.displayMode === 'MODAL'"           class="progress-backdrop"          [class.dark-theme]="config.theme === 'dark'"          [class.light-theme]="config.theme === 'light'"          [@fadeInOut]>     </div>        <!-- Main progress container -->     <div class="progress-container"           [class.modal]="config.displayMode === 'MODAL'"          [class.embedded]="config.displayMode === 'EMBEDDED'"          [class.dark-theme]="config.theme === 'dark'"          [class.light-theme]="config.theme === 'light'"          [@slideInOut]>          <!-- Header Section -->       <div class="progress-header">         <h3 *ngIf="config.title" class="progress-title">{{config.title}}</h3>         <button *ngIf="config.cancelable"                  (click)="cancel()"                 class="cancel-button"                 aria-label="Cancel operation">           ✕         </button>       </div>          <!-- Description -->       <p *ngIf="config.description" class="progress-description">         {{config.description}}       </p>          <!-- Main Progress Section -->       <div class="progress-content" [ngSwitch]="config.mode">                  <!-- Fixed Duration and Steps Based Progress -->         <ng-container *ngSwitchCase="'FIXED_DURATION'">           <div class="progress-bar-container">             <div class="progress-bar"                  [style.width.%]="(progressService.progress$ | async)?.progress || 0"                  [class.smoothed]="(config.mode === 'FIXED_DURATION' && config.smoothing)">             </div>           </div>         </ng-container>            <!-- Steps Based Progress with Labels -->         <ng-container *ngSwitchCase="'STEPS_BASED'">           <div class="steps-container" *ngIf="config.showStepDetails">             <div class="step"                   *ngFor="let label of config.stepLabels; let i = index"                  [class.completed]="(progressService.progress$ | async)?.currentStep > i"                  [class.active]="(progressService.progress$ | async)?.currentStep === i">               <div class="step-marker">{{i + 1}}</div>               <div class="step-label">{{label}}</div>             </div>           </div>           <div class="progress-bar-container">             <div class="progress-bar"                  [style.width.%]="(progressService.progress$ | async)?.progress || 0">             </div>           </div>         </ng-container>            <!-- Indeterminate Progress -->         <ng-container *ngSwitchCase="'INDETERMINATE'">           <div class="indeterminate-container">             <div [ngSwitch]="config.spinnerType">               <div *ngSwitchCase="'circular'" class="spinner-circular"></div>               <div *ngSwitchCase="'pulse'" class="spinner-pulse"></div>               <div *ngSwitchDefault class="spinner-linear"></div>             </div>             <div *ngIf="(progressService.progress$ | async)?.currentMessage"                  class="status-message"                  [@messageChange]>               {{(progressService.progress$ | async)?.currentMessage}}             </div>           </div>         </ng-container>            <!-- Historical Progress -->         <ng-container *ngSwitchCase="'HISTORICAL'">           <div class="progress-bar-container">             <div class="progress-bar"                  [style.width.%]="(progressService.progress$ | async)?.progress || 0">             </div>           </div>         </ng-container>       </div>          <!-- Progress Details Section -->       <div class="progress-details">         <!-- Percentage Display -->         <div *ngIf="config.showPercentage && (progressService.progress$ | async)?.progress !== -1"               class="percentage">           {{(progressService.progress$ | async)?.progress | number:'1.0-0'}}%         </div>            <!-- Time Information -->         <div class="time-info">           <!-- Elapsed Time -->           <span *ngIf="config.showElapsedTime" class="elapsed-time">             Elapsed: {{(progressService.progress$ | async)?.elapsedTime | duration}}           </span>              <!-- Remaining Time -->           <span *ngIf="config.showTimeRemaining &&                         (progressService.progress$ | async)?.estimatedTimeRemaining !== null"                  class="remaining-time">             Remaining: {{(progressService.progress$ | async)?.estimatedTimeRemaining | duration}}           </span>         </div>       </div>          <!-- Controls Section -->       <div class="progress-controls" *ngIf="config.pausable || config.cancelable">         <button *ngIf="config.pausable"                  (click)="(progressService.progress$ | async)?.status === 'PAUSED' ? resume() : pause()"                 class="control-button"                 [class.paused]="(progressService.progress$ | async)?.status === 'PAUSED'">           {{(progressService.progress$ | async)?.status === 'PAUSED' ? 'Resume' : 'Pause'}}         </button>                  <button *ngIf="config.cancelable"                  (click)="cancel()"                 class="control-button cancel">           Cancel         </button>       </div>          <!-- Error Display -->       <div *ngIf="(progressService.progress$ | async)?.status === 'ERROR'"             class="error-container"            [@fadeInOut]>         <div class="error-message">           {{(progressService.progress$ | async)?.error?.message}}         </div>         <button *ngIf="config.errorRetryCount > 0"                 (click)="initializeProgress()"                 class="retry-button">           Retry         </button>       </div>     </div>   </ng-container>
|   |   |   +-- ixt-progress.component.scss: // progress.component.scss  // Variables $backdrop-color: rgba(0, 0, 0, 0.5); $modal-bg-light: #ffffff; $modal-bg-dark: #1a1a1a; $border-radius: 8px; $transition-duration: 0.3s;  // Theme Colors $colors: (   light: (     background: #ffffff,     text: #333333,     border: #e0e0e0,     progress-bg: #f0f0f0,     progress-fill: #2196f3,     success: #4caf50,     error: #f44336,     button-bg: #f5f5f5,     button-text: #333333,     shadow: rgba(0, 0, 0, 0.1)   ),   dark: (     background: #1a1a1a,     text: #ffffff,     border: #333333,     progress-bg: #333333,     progress-fill: #2196f3,     success: #43a047,     error: #d32f2f,     button-bg: #333333,     button-text: #ffffff,     shadow: rgba(0, 0, 0, 0.3)   ) );  // Mixins @mixin theme-aware($property, $key) {   @each $theme, $colors in $colors {     .#{$theme}-theme & {       #{$property}: map-get(map-get($colors, $theme), $key);     }   } }  @mixin flex-center {   display: flex;   align-items: center;   justify-content: center; }  // Backdrop .progress-backdrop {   position: fixed;   top: 0;   left: 0;   right: 0;   bottom: 0;   background-color: $backdrop-color;   z-index: 1000;   backdrop-filter: blur(5px);   animation: fadeIn $transition-duration ease-in-out; }  // Container .progress-container {   position: relative;   width: 100%;   max-width: 500px;   padding: 24px;   border-radius: $border-radius;   box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);   @include theme-aware('background-color', 'background');   @include theme-aware('color', 'text');    &.modal {     position: fixed;     top: 50%;     left: 50%;     transform: translate(-50%, -50%);     z-index: 1001;     animation: slideIn $transition-duration ease-in-out;   }    &.embedded {     margin: 16px 0;   } }  // Header .progress-header {   display: flex;   justify-content: space-between;   align-items: center;   margin-bottom: 16px;    .progress-title {     margin: 0;     font-size: 1.25rem;     font-weight: 500;   }    .cancel-button {     background: none;     border: none;     font-size: 1.5rem;     cursor: pointer;     padding: 4px;     border-radius: 50%;     @include theme-aware('color', 'text');          &:hover {       @include theme-aware('background-color', 'button-bg');     }   } }  // Description .progress-description {   margin-bottom: 20px;   font-size: 0.875rem;   line-height: 1.5;   @include theme-aware('color', 'text'); }  // Progress Bar .progress-bar-container {   height: 8px;   border-radius: 4px;   overflow: hidden;   @include theme-aware('background-color', 'progress-bg');   margin: 12px 0;    .progress-bar {     height: 100%;     transition: width 0.3s ease-in-out;     @include theme-aware('background-color', 'progress-fill');      &.smoothed {       transition: width 0.1s linear;     }   } }  // Steps .steps-container {   display: flex;   justify-content: space-between;   margin-bottom: 24px;    .step {     flex: 1;     text-align: center;     position: relative;      &:not(:last-child)::after {       content: '';       position: absolute;       top: 50%;       left: 50%;       width: 100%;       height: 2px;       @include theme-aware('background-color', 'border');     }      &.completed {       .step-marker {         @include theme-aware('background-color', 'success');         @include theme-aware('color', 'background');       }        &::after {         @include theme-aware('background-color', 'success');       }     }      &.active .step-marker {       @include theme-aware('background-color', 'progress-fill');       @include theme-aware('color', 'background');     }      .step-marker {       width: 24px;       height: 24px;       border-radius: 50%;       @include flex-center;       margin: 0 auto;       font-size: 0.75rem;       position: relative;       z-index: 1;       @include theme-aware('background-color', 'button-bg');       @include theme-aware('color', 'text');     }      .step-label {       margin-top: 8px;       font-size: 0.75rem;     }   } }  // Indeterminate Progress .indeterminate-container {   text-align: center;   padding: 20px 0;    .spinner-circular {     width: 40px;     height: 40px;     margin: 0 auto;     border: 3px solid transparent;     border-radius: 50%;     animation: spin 1s linear infinite;     @include theme-aware('border-top-color', 'progress-fill');   }    .spinner-linear {     height: 4px;     width: 100%;     position: relative;     overflow: hidden;     @include theme-aware('background-color', 'progress-bg');      &::after {       content: '';       position: absolute;       height: 100%;       width: 30%;       @include theme-aware('background-color', 'progress-fill');       animation: indeterminateProgress 1.5s ease-in-out infinite;     }   }    .spinner-pulse {     width: 40px;     height: 40px;     margin: 0 auto;     border-radius: 50%;     animation: pulse 1.5s ease-in-out infinite;     @include theme-aware('background-color', 'progress-fill');   }    .status-message {     margin-top: 16px;     font-size: 0.875rem;   } }  // Progress Details .progress-details {   display: flex;   justify-content: space-between;   align-items: center;   margin-top: 12px;   font-size: 0.875rem;    .percentage {     font-weight: 500;   }    .time-info {     display: flex;     gap: 16px;      .elapsed-time,     .remaining-time {       @include theme-aware('color', 'text');       opacity: 0.8;     }   } }  // Controls .progress-controls {   display: flex;   gap: 12px;   margin-top: 16px;    .control-button {     padding: 8px 16px;     border-radius: 4px;     border: none;     cursor: pointer;     font-size: 0.875rem;     transition: all 0.2s ease;     @include theme-aware('background-color', 'button-bg');     @include theme-aware('color', 'button-text');      &:hover {       opacity: 0.9;     }      &.cancel {       @include theme-aware('background-color', 'error');       @include theme-aware('color', 'background');     }      &.paused {       @include theme-aware('background-color', 'progress-fill');       @include theme-aware('color', 'background');     }   } }  // Error Container .error-container {   margin-top: 16px;   padding: 12px;   border-radius: 4px;   @include theme-aware('background-color', 'error');   @include theme-aware('color', 'background');    .error-message {     margin-bottom: 8px;   }    .retry-button {     background: none;     border: 1px solid currentColor;     padding: 4px 12px;     border-radius: 4px;     cursor: pointer;     font-size: 0.875rem;     @include theme-aware('color', 'background');      &:hover {       opacity: 0.9;     }   } }  // Animations @keyframes fadeIn {   from { opacity: 0; }   to { opacity: 1; } }  @keyframes slideIn {   from {     opacity: 0;     transform: translate(-50%, -60%);   }   to {     opacity: 1;     transform: translate(-50%, -50%);   } }  @keyframes spin {   0% { transform: rotate(0deg); }   100% { transform: rotate(360deg); } }  @keyframes indeterminateProgress {   0% {     left: -30%;   }   100% {     left: 100%;   } }  @keyframes pulse {   0% {     transform: scale(0.8);     opacity: 0.5;   }   50% {     transform: scale(1);     opacity: 0.8;   }   100% {     transform: scale(0.8);     opacity: 0.5;   } }  // Media Queries @media (max-width: 600px) {   .progress-container {     max-width: 100%;     margin: 16px;          &.modal {       width: calc(100% - 32px);       margin: 0 16px;     }   }    .progress-details {     flex-direction: column;     align-items: flex-start;     gap: 8px;   }    .steps-container {     .step-label {       display: none;     }   } }  // Accessibility @media (prefers-reduced-motion: reduce) {   .progress-bar,   .spinner-circular,   .spinner-linear,   .spinner-pulse {     transition: none;     animation: none;   } }
|   |   |   +-- ixt-progress.component.ts:   // progress.component.ts import { Component, Input, Output, EventEmitter, OnInit, OnDestroy } from '@angular/core'; import { ProgressService } from './progress.service'; import { Subject } from 'rxjs'; import { takeUntil } from 'rxjs/operators'; import { BaseProgressConfig, ProgressState } from './progress.types';  @Component({   selector: 'app-progress',   templateUrl: './ixt-progress.component.html',   styleUrls: ['./ixt-progress.component.scss'] }) export class ProgressComponent implements OnInit, OnDestroy {   @Input() config!: BaseProgressConfig;   @Output() progressChange = new EventEmitter<ProgressState>();   @Output() completed = new EventEmitter<void>();   @Output() cancelled = new EventEmitter<void>();   @Output() error = new EventEmitter<Error>();    private destroy$ = new Subject<void>();    constructor(private progressService: ProgressService) {}    ngOnInit(): void {     this.initializeProgress();     this.subscribeToProgress();   }    private initializeProgress(): void {     try {       this.validateConfig();       this.progressService.start(this.config);     } catch (error) {       this.handleError(error as Error);     }   }    private validateConfig(): void {     if (!this.config) {       throw new Error('Progress configuration is required');     }     // Add more validation as needed   }    private subscribeToProgress(): void {     this.progressService.progress$       .pipe(takeUntil(this.destroy$))       .subscribe({         next: (state) => {           this.progressChange.emit(state);           if (state.status === ProgressStatus.COMPLETED) {             this.handleCompletion();           }         },         error: (error) => this.handleError(error)       });   }    private handleCompletion(): void {     this.completed.emit();     if (this.config.autoClose) {       setTimeout(() => {         this.destroy();       }, this.config.autoCloseDelay || 1000);     }   }    private handleError(error: Error): void {     this.error.emit(error);     if (this.config.onError) {       this.config.onError(error);     }   }    pause(): void {     if (this.config.pausable) {       this.progressService.pause();     }   }    resume(): void {     this.progressService.resume();   }    cancel(): void {     if (this.config.cancelable) {       this.progressService.cancel();       this.cancelled.emit();       if (this.config.onCancel) {         this.config.onCancel();       }     }   }    ngOnDestroy(): void {     this.destroy();   }    private destroy(): void {     this.destroy$.next();     this.destroy$.complete();     this.progressService.destroy();   } }  // adaptive-estimator.ts class AdaptiveEstimator {   private readonly history: ProgressHistoryEntry[];   private readonly config: HistoricalConfig;   private readonly similarityThreshold: number = 0.2;    constructor(history: ProgressHistoryEntry[], config: HistoricalConfig) {     this.history = history;     this.config = config;   }    estimate(elapsedTime: number): { progress: number; remaining: number } {     const similarRuns = this.findSimilarRuns();     if (similarRuns.length === 0) {       return this.fallbackEstimate(elapsedTime);     }      return this.calculateEstimate(similarRuns, elapsedTime);   }    private findSimilarRuns(): ProgressHistoryEntry[] {     return this.history.filter(entry => {       const sizeSimilarity = Math.abs(entry.dataSize - this.config.dataSize) / this.config.dataSize;       const complexitySimilarity = this.config.complexityFactor && entry.complexityFactor         ? Math.abs(entry.complexityFactor - this.config.complexityFactor) / this.config.complexityFactor         : 0;              return sizeSimilarity <= this.similarityThreshold &&               complexitySimilarity <= this.similarityThreshold &&              entry.success;     });   }    private calculateEstimate(similarRuns: ProgressHistoryEntry[], elapsedTime: number): { progress: number; remaining: number } {     const averageDuration = similarRuns.reduce((acc, run) => acc + run.duration, 0) / similarRuns.length;     const progress = Math.min((elapsedTime / averageDuration) * 100, 100);     const remaining = Math.max(averageDuration - elapsedTime, 0);      return { progress, remaining };   }    private fallbackEstimate(elapsedTime: number): { progress: number; remaining: number } {     const estimatedTotal = this.config.averageTime;     const progress = Math.min((elapsedTime / estimatedTotal) * 100, 100);     const remaining = Math.max(estimatedTotal - elapsedTime, 0);      return { progress, remaining };   } }
|   |   |   +-- ixt-progress.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtProgressComponent } from './ixt-progress.component';  @NgModule({   declarations: [     IxtProgressComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtProgressComponent   ] }) export class IxtTableModule { } 
|   |   |   +-- progress.service.ts: // progress.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable, Subject, timer } from 'rxjs'; import { takeUntil, map, filter } from 'rxjs/operators'; import { BaseProgressConfig, FixedDurationConfig, HistoricalConfig, IndeterminateConfig, ProgressHistoryEntry, ProgressMode, ProgressState, ProgressStatus, StepsConfig } from './progress.types';  @Injectable({   providedIn: 'root' }) export class ProgressService {   private progressSubject = new BehaviorSubject<ProgressState>({     status: ProgressStatus.IDLE,     progress: 0,     elapsedTime: 0,     estimatedTimeRemaining: null   });    private destroySubject = new Subject<void>();   private startTime: number = 0;   private historyCache: Map<string, ProgressHistoryEntry[]> = new Map();    progress$ = this.progressSubject.asObservable();    start(config: BaseProgressConfig): void {     this.startTime = Date.now();     this.initializeProgress(config);   }    private initializeProgress(config: BaseProgressConfig): void {     switch (config.mode) {       case ProgressMode.FIXED_DURATION:         this.handleFixedDuration(config as FixedDurationConfig);         break;       case ProgressMode.STEPS_BASED:         this.handleStepsBased(config as StepsConfig);         break;       case ProgressMode.INDETERMINATE:         this.handleIndeterminate(config as IndeterminateConfig);         break;       case ProgressMode.HISTORICAL:         this.handleHistorical(config as HistoricalConfig);         break;     }   }    private handleFixedDuration(config: FixedDurationConfig): void {     const updateInterval = config.updateInterval || 100;     const smoothing = config.smoothing !== false;      timer(0, updateInterval)       .pipe(         takeUntil(this.destroySubject),         map(() => {           const elapsed = Date.now() - this.startTime;           const rawProgress = Math.min((elapsed / config.totalDuration) * 100, 100);           return smoothing ? this.smoothProgress(rawProgress) : rawProgress;         }),         filter(progress => progress <= 100)       )       .subscribe(progress => {         this.updateProgress({           status: progress === 100 ? ProgressStatus.COMPLETED : ProgressStatus.RUNNING,           progress,           elapsedTime: Date.now() - this.startTime,           estimatedTimeRemaining: this.calculateTimeRemaining(progress, config.totalDuration)         });       });   }    private handleStepsBased(config: StepsConfig): void {     // Implementation for steps-based progress     if (config.bytesLoaded !== undefined && config.totalBytes) {       this.updateProgress({         status: ProgressStatus.RUNNING,         progress: (config.bytesLoaded / config.totalBytes) * 100,         currentStep: config.currentStep,         elapsedTime: Date.now() - this.startTime,         estimatedTimeRemaining: this.estimateTimeFromBytes(config.bytesLoaded, config.totalBytes)       });     } else {       this.updateProgress({         status: ProgressStatus.RUNNING,         progress: ((config.currentStep || 0) / config.totalSteps) * 100,         currentStep: config.currentStep,         elapsedTime: Date.now() - this.startTime,         estimatedTimeRemaining: null       });     }   }    private handleIndeterminate(config: IndeterminateConfig): void {     if (config.statusMessages?.length) {       timer(0, config.messageRotationInterval || 3000)         .pipe(takeUntil(this.destroySubject))         .subscribe(tick => {           const messageIndex = tick % config.statusMessages.length;           this.updateProgress({             status: ProgressStatus.RUNNING,             progress: -1,             elapsedTime: Date.now() - this.startTime,             estimatedTimeRemaining: null,             currentMessage: config.statusMessages[messageIndex]           });         });     }   }    private handleHistorical(config: HistoricalConfig): void {     const historicalData = this.getHistoricalData(config);     if (config.adaptiveEstimation && historicalData.length > 0) {       this.startAdaptiveEstimation(config, historicalData);     } else {       this.startBasicEstimation(config);     }   }    private startAdaptiveEstimation(config: HistoricalConfig, history: ProgressHistoryEntry[]): void {     const estimator = new AdaptiveEstimator(history, config);     timer(0, 1000)       .pipe(takeUntil(this.destroySubject))       .subscribe(() => {         const estimation = estimator.estimate(Date.now() - this.startTime);         this.updateProgress({           status: ProgressStatus.RUNNING,           progress: estimation.progress,           elapsedTime: Date.now() - this.startTime,           estimatedTimeRemaining: estimation.remaining         });       });   }    private smoothProgress(rawProgress: number): number {     // Implement smoothing algorithm (e.g., exponential moving average)     return rawProgress;   }    private calculateTimeRemaining(progress: number, totalDuration: number): number {     if (progress === 0) return totalDuration;     const elapsed = Date.now() - this.startTime;     return (elapsed / progress) * (100 - progress);   }    private estimateTimeFromBytes(loaded: number, total: number): number {     const elapsed = Date.now() - this.startTime;     const bytesPerMs = loaded / elapsed;     return (total - loaded) / bytesPerMs;   }    private updateProgress(state: Partial<ProgressState>): void {     this.progressSubject.next({       ...this.progressSubject.getValue(),       ...state     });   }    pause(): void {     if (this.progressSubject.getValue().status === ProgressStatus.RUNNING) {       this.updateProgress({ status: ProgressStatus.PAUSED });       this.destroySubject.next();     }   }    resume(): void {     if (this.progressSubject.getValue().status === ProgressStatus.PAUSED) {       this.startTime = Date.now() - this.progressSubject.getValue().elapsedTime;       this.updateProgress({ status: ProgressStatus.RUNNING });     }   }    cancel(): void {     this.updateProgress({ status: ProgressStatus.CANCELLED });     this.destroy();   }    destroy(): void {     this.destroySubject.next();     this.destroySubject.complete();   }    private getHistoricalData(config: HistoricalConfig): ProgressHistoryEntry[] {     const cacheKey = this.generateCacheKey(config);     return this.historyCache.get(cacheKey) || [];   }    private generateCacheKey(config: HistoricalConfig): string {     return `${config.dataSize}-${config.complexityFactor || 1}`;   } } 
|   |   |   -- progress.types.ts: // progress.types.ts export enum ProgressMode {     FIXED_DURATION = 'FIXED_DURATION',     STEPS_BASED = 'STEPS_BASED',     INDETERMINATE = 'INDETERMINATE',     HISTORICAL = 'HISTORICAL'   }      export enum DisplayMode {     EMBEDDED = 'EMBEDDED',     MODAL = 'MODAL'   }      export enum ProgressStatus {     IDLE = 'IDLE',     RUNNING = 'RUNNING',     PAUSED = 'PAUSED',     COMPLETED = 'COMPLETED',     ERROR = 'ERROR',     CANCELLED = 'CANCELLED'   }      export interface BaseProgressConfig {     mode: ProgressMode;     displayMode: DisplayMode;     title?: string;     description?: string;     theme?: 'light' | 'dark' | 'system';     cancelable?: boolean;     pausable?: boolean;     autoClose?: boolean;     autoCloseDelay?: number;     showPercentage?: boolean;     showTimeRemaining?: boolean;     showElapsedTime?: boolean;     errorRetryCount?: number;     onComplete?: () => void;     onError?: (error: Error) => void;     onCancel?: () => void;   }      export interface FixedDurationConfig extends BaseProgressConfig {     mode: ProgressMode.FIXED_DURATION;     totalDuration: number;     startTime?: number;     smoothing?: boolean;     updateInterval?: number;   }      export interface StepsConfig extends BaseProgressConfig {     mode: ProgressMode.STEPS_BASED;     totalSteps: number;     currentStep?: number;     stepLabels?: string[];     stepDescriptions?: string[];     bytesLoaded?: number;     totalBytes?: number;     showStepDetails?: boolean;   }      export interface IndeterminateConfig extends BaseProgressConfig {     mode: ProgressMode.INDETERMINATE;     statusMessages?: string[];     spinnerType?: 'circular' | 'linear' | 'pulse';     messageRotationInterval?: number;     showSpinner?: boolean;   }      export interface HistoricalConfig extends BaseProgressConfig {     mode: ProgressMode.HISTORICAL;     averageTime: number;     dataSize: number;     complexityFactor?: number;     previousRuns?: ProgressHistoryEntry[];     adaptiveEstimation?: boolean;     confidenceThreshold?: number;   }      export interface ProgressHistoryEntry {     timestamp: number;     duration: number;     dataSize: number;     complexityFactor?: number;     success: boolean;   }      export interface ProgressState {     status: ProgressStatus;     progress: number;     elapsedTime: number;     estimatedTimeRemaining: number | null;     currentStep?: number;     currentMessage?: string;     error?: Error;   }   
|   |   +-- ixt-select
|   |   |   +-- ixt-select.component.html: <p>ixt-select works!</p> 
|   |   |   +-- ixt-select.component.scss: 
|   |   |   +-- ixt-select.component.ts: import { Component } from '@angular/core';  @Component({   selector: 'ixt-ixt-select',   templateUrl: './ixt-select.component.html',   styleUrls: ['./ixt-select.component.scss'] }) export class IxtSelectComponent {  } 
|   |   |   -- ixt-select.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtSelectComponent } from './ixt-select.component';  @NgModule({   declarations: [     IxtSelectComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtSelectComponent   ] }) export class IxtSelectModule { } 
|   |   +-- ixt-split-pane
|   |   |   +-- index.ts: // public-api.ts (or index.ts) export * from './ixt-split-pane.component'; export * from './ixt-split-pane.module';
|   |   |   +-- ixt-split-pane.component.html: <div class="split-pane-container" #container>   <div class="left-pane" #leftPane>     <ng-content select=".left-pane"></ng-content>   </div>    <div class="divider" #divider (mousedown)="onDragStart($event)">     <div class="collapse-buttons">       <button class="collapse-button" (click)="collapseLeft()" [class.hidden]="isLeftCollapsed">◀</button>       <button class="collapse-button" (click)="collapseRight()" [class.hidden]="isRightCollapsed">▶</button>     </div>   </div>    <div class="right-pane">     <ng-content select=".right-pane"></ng-content>   </div>    <button *ngIf="isLeftCollapsed" class="expand-button" (click)="expandLeft()">▶</button>   <button *ngIf="isRightCollapsed" class="expand-button right" (click)="expandRight()">◀</button> </div>
|   |   |   +-- ixt-split-pane.component.scss: .split-pane-container {   display: flex;   flex: 1;   min-height: 0;   min-width: 0;   padding: 8px;   margin: 8px;   border: 2px solid orange;   box-sizing: border-box; }  .left-pane {   height: 100%;   overflow: auto;   transition: width 0.3s ease-in-out;   margin-right: 4px;   min-width: 0; }  .right-pane {   flex: 1;   height: 100%;   overflow: auto;   margin-left: 4px;   min-width: 0; }  .divider {   width: 6px;   background: #e0e0e0;   cursor: col-resize;   position: relative;   flex-shrink: 0; /* Prevent divider from shrinking */   margin: 0 -4px; /* Negative margin to overlap with pane margins */    &:hover {     background: #bdbdbd;   } }  .collapse-buttons {   position: absolute;   top: 50%;   left: 50%;   transform: translate(-50%, -50%);   display: flex;   flex-direction: column;   gap: 4px;   z-index: 1; /* Ensure buttons appear above panes */ }  .collapse-button {   padding: 4px;   border: none;   background: #fff;   border-radius: 50%;   cursor: pointer;   box-shadow: 0 1px 3px rgba(0,0,0,0.2);    &:hover {     background: #f5f5f5;   }    &.hidden {     display: none;   } }  .expand-button {   position: absolute;   top: 50%;   transform: translateY(-50%);   left: 0;   padding: 8px;   background: #fff;   border: 1px solid #e0e0e0;   border-radius: 0 4px 4px 0;   cursor: pointer;   z-index: 1; /* Ensure button appears above panes */    &.right {     left: auto;     right: 0;     border-radius: 4px 0 0 4px;   }    &:hover {     background: #f5f5f5;   } }  
|   |   |   +-- ixt-split-pane.component.ts: import { Component, ElementRef, HostListener, Input, ViewChild } from '@angular/core';  @Component({   selector: 'ixt-split-pane',   template: `     <div class="split-container">       <div class="first-panel" [style.flexBasis.%]="firstPanelSize">         <ng-content select=".left-pane"></ng-content>       </div>       <div #divider class="divider" (mousedown)="startResize($event)">       </div>       <div class="second-panel" [style.flexBasis.%]="100 - firstPanelSize">         <ng-content select=".right-pane"></ng-content>       </div>     </div>   `,     styles: [`     :host {       display: flex;       flex: 1;       min-height: 0;       min-width: 0;       font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', Arial, sans-serif;       font-size: 14px;       color: #2c3e50;       -webkit-font-smoothing: antialiased;       -moz-osx-font-smoothing: grayscale;     }      .split-container {       display: flex;       flex: 1;       min-height: 0;       min-width: 0;       background: #ffffff;       border: 1px solid #e0e4e8;       border-radius: 4px;     }      .first-panel, .second-panel {       display: flex;       flex: 1;       min-height: 0;       min-width: 0;       overflow: auto;       background: white;       padding: 16px;        /* Table styles for your file list */       ::ng-deep {         table {           width: 100%;           border-collapse: collapse;         }          th {           text-align: left;           font-weight: 500;           color: #546e7a;           padding: 8px 16px;           border-bottom: 2px solid #e0e4e8;           font-size: 13px;           text-transform: uppercase;           letter-spacing: 0.5px;         }          td {           padding: 12px 16px;           border-bottom: 1px solid #f0f2f5;           color: #37474f;           font-size: 14px;         }          tr:hover {           background-color: #f8fafc;         }       }        /* Scrollbar styling */       &::-webkit-scrollbar {         width: 8px;         height: 8px;       }        &::-webkit-scrollbar-track {         background: #f5f6f8;         border-radius: 4px;       }        &::-webkit-scrollbar-thumb {         background: #dde1e6;         border-radius: 4px;         &:hover {           background: #c7ccd1;         }       }     }      .divider {       display: flex;       justify-content: center;       width: 16px;       flex-shrink: 0;       cursor: col-resize;       background: transparent;       transition: background-color 0.2s;        &:hover {         background: #f5f6f8;         .divider-line {           background: #c7ccd1;         }       }     }      .divider {       width: 6px;       background: #ccc;       cursor: col-resize;       flex-shrink: 0;       border-left: 1px solid #b4b4b4;       border-right: 1px solid #b4b4b4;        &:hover {         background: #999;       }     }    `] }) export class IxtSplitPaneComponent {   firstPanelSize = 50;  // default size   isDragging = false;   startPosition = 0;   startSize = 0;   @ViewChild('divider') divider!: ElementRef;    startResize(e: MouseEvent) {     this.isDragging = true;     this.startPosition = e.pageX;     this.startSize = this.firstPanelSize;     document.addEventListener('mousemove', this.resize.bind(this));     document.addEventListener('mouseup', this.stopResize.bind(this));   }    @HostListener('window:mousemove', ['$event'])   resize(e: MouseEvent) {     if (!this.isDragging) return;     const containerRect = this.divider.nativeElement.parentElement.getBoundingClientRect();     const difference = e.pageX - this.startPosition;     let newSize = this.startSize + (difference / containerRect.width * 100);     newSize = Math.max(0, Math.min(100, newSize));     this.firstPanelSize = newSize;   }    stopResize() {     this.isDragging = false;     document.removeEventListener('mousemove', this.resize.bind(this));     document.removeEventListener('mouseup', this.stopResize.bind(this));   } }
|   |   |   -- ixt-split-pane.module.ts: // ixt-split-pane.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtSplitPaneComponent } from './ixt-split-pane.component';  @NgModule({   declarations: [     IxtSplitPaneComponent   ],   imports: [     CommonModule   ],   exports: [     IxtSplitPaneComponent   ] }) export class IxtSplitPaneModule { } 
|   |   +-- ixt-table
|   |   |   +-- ixt-table.component.html: <div class="table-container" #tableContainer>   <!-- Toolbar -->   <div class="toolbar">     <button *ngIf="config.allowAdd" (click)="onAddNewRow()">Add New</button>     <button *ngIf="editingRows.size > 0" (click)="onSaveAll()">Save All</button>     <button (click)="toggleFilters($event)">       {{ showFilters ? 'Hide Filters' : 'Show Filters' }}     </button>   </div>    <!-- Table -->   <table>     <thead>       <tr>         <th *ngFor="let col of config.columns">           {{col.header}}           <button *ngIf="col.sortable" (click)="onSort(col)">Sort</button>         </th>         <th *ngIf="config.allowEdit || config.allowDelete">Actions</th>       </tr>       <tr *ngIf="showFilters">         <th *ngFor="let col of config.columns">           <input *ngIf="col.filterable"                   [placeholder]="'Filter ' + col.header"                  (input)="onFilter($event, col)">         </th>         <th></th>       </tr>     </thead>     <tbody>       <tr *ngFor="let row of paginatedData; let i = index"           [class.selected]="isRowSelected(row)"           (click)="onRowClick(row, i, $event)">         <td *ngFor="let col of config.columns">           <ng-container *ngIf="!isEditing(i); else editCell">             {{ formatCell(row[col.key], col) }}           </ng-container>           <ng-template #editCell>             <input [value]="row[col.key]"                    (input)="onFieldChange($event, col.key, row, i)">           </ng-template>         </td>         <td *ngIf="config.allowEdit || config.allowDelete">           <button *ngIf="config.allowEdit && !isEditing(i)"                    (click)="onEdit(row, i, $event)">Edit</button>           <button *ngIf="isEditing(i)"                    (click)="onSave(row, i)">Save</button>           <button *ngIf="isEditing(i)"                    (click)="onCancel(row, i)">Cancel</button>           <button *ngIf="config.allowDelete"                    (click)="onDelete(row, i, $event)">Delete</button>         </td>       </tr>     </tbody>   </table>    <!-- Pagination -->   <div class="pagination">     <select (change)="onPageSizeChange($event)">       <option *ngFor="let size of pagination.pageSizeOptions"                [value]="size">         {{size === -1 ? 'All' : size}}       </option>     </select>          <button (click)="goToFirstPage()"              [disabled]="pagination.currentPage === 1">First</button>     <button (click)="goToPreviousPage()"              [disabled]="pagination.currentPage === 1">Previous</button>          <span *ngFor="let page of visiblePages">       <button *ngIf="page !== -1"               [class.active]="page === pagination.currentPage"               (click)="onPageChange(page)">         {{page}}       </button>       <span *ngIf="page === -1">...</span>     </span>          <button (click)="goToNextPage()"              [disabled]="pagination.currentPage === totalPages">Next</button>     <button (click)="goToLastPage()"              [disabled]="pagination.currentPage === totalPages">Last</button>   </div> </div>
|   |   |   +-- ixt-table.component.scss: .table-container {   display: flex;   flex-direction: column;   gap: 1rem;   padding: 1rem;   width: 100%;   height: 100%;   overflow: auto;    .toolbar {     display: flex;     gap: 0.5rem;     align-items: center;     padding: 0.5rem;     background-color: #f5f5f5;     border-radius: 4px;      button {       padding: 0.5rem 1rem;       border: 1px solid #ddd;       border-radius: 4px;       background-color: white;       cursor: pointer;        &:hover {         background-color: #f0f0f0;       }        &:active {         background-color: #e0e0e0;       }     }   }    table {     width: 100%;     border-collapse: collapse;     background-color: white;      th, td {       padding: 0.75rem;       border: 1px solid #ddd;       text-align: left;        input {         width: 100%;         padding: 0.25rem;         border: 1px solid #ddd;         border-radius: 2px;          &:focus {           outline: none;           border-color: #2196f3;         }       }     }      th {       background-color: #f5f5f5;       font-weight: 600;        button {         margin-left: 0.5rem;         padding: 0.25rem 0.5rem;         border: 1px solid #ddd;         border-radius: 2px;         background-color: white;         cursor: pointer;          &:hover {           background-color: #f0f0f0;         }       }     }      tr {       &:hover {         background-color: #f8f8f8;       }        &.selected {         background-color: #e3f2fd;          &:hover {           background-color: #e1f0fb;         }       }     }      tbody tr {       td {         &:last-child {           white-space: nowrap;            button {             margin: 0 0.25rem;             padding: 0.25rem 0.5rem;             border: 1px solid #ddd;             border-radius: 2px;             background-color: white;             cursor: pointer;              &:hover {               background-color: #f0f0f0;             }           }         }       }     }   }    .pagination {     display: flex;     gap: 0.5rem;     align-items: center;     justify-content: center;     padding: 0.5rem;     background-color: #f5f5f5;     border-radius: 4px;      select {       padding: 0.25rem;       border: 1px solid #ddd;       border-radius: 2px;       background-color: white;        &:focus {         outline: none;         border-color: #2196f3;       }     }      button {       padding: 0.25rem 0.75rem;       border: 1px solid #ddd;       border-radius: 2px;       background-color: white;       cursor: pointer;        &:hover:not([disabled]) {         background-color: #f0f0f0;       }        &:active:not([disabled]) {         background-color: #e0e0e0;       }        &[disabled] {         opacity: 0.5;         cursor: not-allowed;       }        &.active {         background-color: #2196f3;         color: white;         border-color: #2196f3;          &:hover {           background-color: #1976d2;         }       }     }   } }  // Filter animation styles .filter-row {   &.ng-enter, &.ng-leave {     transition: all 0.3s ease;   }    &.ng-enter {     opacity: 0;     transform: translateY(-20px);   }    &.ng-enter-active {     opacity: 1;     transform: translateY(0);   }    &.ng-leave {     opacity: 1;     transform: translateY(0);   }    &.ng-leave-active {     opacity: 0;     transform: translateY(-20px);   } } 
|   |   |   +-- ixt-table.component.ts: import { Component, OnInit, AfterViewInit, OnDestroy, ElementRef, ViewChild, Input, Output, EventEmitter, Inject } from '@angular/core'; import { Subscription } from 'rxjs'; import { TableConfig, TableColumnDef, PaginationConfig } from './ixt-table.interfaces'; import { ChangeDetectorRef, inject } from '@angular/core';  @Component({   selector: 'ixt-table',   templateUrl: './ixt-table.component.html',   styleUrls: ['./ixt-table.component.scss'] }) export class IxtTableComponent<T extends object> implements OnInit, AfterViewInit, OnDestroy {   @ViewChild('tableContainer', { static: true }) tableContainer!: ElementRef;      @Input() data: T[] = [];   @Input() config!: TableConfig<T>;      @Output() selectionChange = new EventEmitter<T[]>();   @Output() rowAdd = new EventEmitter<T>();   @Output() rowEdit = new EventEmitter<{ original: T, changes: Partial<T> }>();   @Output() rowDelete = new EventEmitter<T>();   @Output() sortChange = new EventEmitter<{ column: keyof T, direction: 'asc' | 'desc' }>();   @Output() filterChange = new EventEmitter<{ column: keyof T, value: string }>();    private resizeObserver!: ResizeObserver;   private cdr = inject(ChangeDetectorRef);   selectedRows = new Set<T>();   lastClickedRowIndex: number | null = null;   editingRows = new Set<number>();   showFilters = false;   paginatedData: T[] = [];    pagination: PaginationConfig = {     pageSize: 10,     currentPage: 1,     totalItems: 0,     pageSizeOptions: [10, 25, 50, 100, -1]   };    constructor() {}    ngOnInit(): void {     this.initTable();   }    ngAfterViewInit(): void {     this.resizeObserver = new ResizeObserver(() => {       this.resizeTable();     });     this.resizeObserver.observe(this.tableContainer.nativeElement);   }    ngOnDestroy(): void {     if (this.resizeObserver) {       this.resizeObserver.disconnect();     }   }    private initTable(): void {     this.pagination.totalItems = this.data.length;     this.updatePaginatedData();   }    isRowSelected(row: T): boolean {     return this.selectedRows.has(row);   }    isEditing(index: number): boolean {     return this.editingRows.has(index);   }    formatCell(value: any, column: TableColumnDef<T>): string {     if (column.formatter) {       return column.formatter(value);     }     return value?.toString() ?? '';   }    onAddNewRow(): void {     const newRow = {} as T;     this.data.unshift(newRow);     this.editingRows.add(0);     this.rowAdd.emit(newRow);     this.updatePaginatedData();   }    onFieldChange(event: Event, field: keyof T, row: T, index: number): void {     const input = event.target as HTMLInputElement;     const value = input.value;          const column = this.config.columns.find((col: TableColumnDef<T>) => col.key === field);     if (column?.validator) {       const validationResult = column.validator(value);       if (typeof validationResult === 'string') {         alert(validationResult);         return;       }       if (!validationResult) {         return;       }     }      (row[field] as any) = value;   }    onRowClick(row: T, index: number, event: MouseEvent): void {     if (this.editingRows.size > 0) return;     if (this.config.selectionMode === 'none') return;      this.lastClickedRowIndex = index;          if (this.config.selectionMode === 'single') {       this.selectedRows.clear();       this.selectedRows.add(row);     } else if (this.config.selectionMode === 'multiple') {       if (event.shiftKey && this.lastClickedRowIndex !== null) {         const start = Math.min(index, this.lastClickedRowIndex);         const end = Math.max(index, this.lastClickedRowIndex);         this.selectedRows = new Set(this.paginatedData.slice(start, end + 1));       } else if (event.ctrlKey || event.metaKey) {         if (this.selectedRows.has(row)) {           this.selectedRows.delete(row);         } else {           this.selectedRows.add(row);         }       } else {         this.selectedRows.clear();         this.selectedRows.add(row);       }     }      this.selectionChange.emit(Array.from(this.selectedRows));   }    onEdit(row: T, index: number, event: Event): void {     event.stopPropagation();     (row as any).originalData = { ...row };     this.editingRows.add(index);   }    onSave(row: T, index: number): void {     const changes = {} as Partial<T>;     const original = (row as any).originalData;          for (const key of Object.keys(row) as (keyof T)[]) {       if (key !== 'originalData' && row[key] !== original[key]) {         changes[key] = row[key];       }     }      this.rowEdit.emit({ original, changes });     this.editingRows.delete(index);     delete (row as any).originalData;   }    onCancel(row: T, index: number): void {     const original = (row as any).originalData;     Object.assign(row, original);     this.editingRows.delete(index);     delete (row as any).originalData;   }    onDelete(row: T, index: number, event: Event): void {     event.stopPropagation();     if (confirm('Are you sure you want to delete this row?')) {       this.data = this.data.filter((_, i) => i !== index);       this.rowDelete.emit(row);       this.updatePaginatedData();     }   }    onSaveAll(): void {     for (const index of Array.from(this.editingRows)) {       const row = this.paginatedData[index];       this.onSave(row, index);     }   }    onSort(column: TableColumnDef<T>): void {     this.sortChange.emit({        column: column.key,        direction: 'asc' // Toggle this based on current state     });   }    onFilter(event: Event, column: TableColumnDef<T>): void {     const input = event.target as HTMLInputElement;     this.filterChange.emit({ column: column.key, value: input.value });   }    updatePaginatedData(): void {     if (this.pagination.pageSize === -1) {       this.paginatedData = [...this.data];       return;     }      const startIndex = (this.pagination.currentPage - 1) * this.pagination.pageSize;     const endIndex = startIndex + this.pagination.pageSize;     this.paginatedData = this.data.slice(startIndex, endIndex);   }    get totalPages(): number {     if (this.pagination.pageSize === -1) return 1;     return Math.ceil(this.pagination.totalItems / this.pagination.pageSize);   }    get visiblePages(): number[] {     const totalPages = this.totalPages;     const current = this.pagination.currentPage;     const pages: number[] = [];      if (totalPages <= 7) {       for (let i = 1; i <= totalPages; i++) pages.push(i);     } else {       pages.push(1);       if (current > 3) pages.push(-1);       for (let i = Math.max(2, current - 1); i <= Math.min(totalPages - 1, current + 1); i++) {         pages.push(i);       }       if (current < totalPages - 2) pages.push(-1);       pages.push(totalPages);     }      return pages;   }    onPageSizeChange(event: Event): void {     const select = event.target as HTMLSelectElement;     const newSize = parseInt(select.value, 10);     this.pagination.pageSize = newSize;     this.pagination.currentPage = 1;     this.updatePaginatedData();   }    onPageChange(page: number): void {     if (page < 1 || page > this.totalPages) return;     this.pagination.currentPage = page;     this.updatePaginatedData();   }    goToFirstPage(): void { this.onPageChange(1); }   goToLastPage(): void { this.onPageChange(this.totalPages); }   goToPreviousPage(): void { this.onPageChange(this.pagination.currentPage - 1); }   goToNextPage(): void { this.onPageChange(this.pagination.currentPage + 1); }    private resizeTable(): void {     if (this.tableContainer) {       const width = this.tableContainer.nativeElement.offsetWidth;       const height = this.tableContainer.nativeElement.offsetHeight;     }   }    toggleFilters(event?: Event): void {     if (event) {       event.stopPropagation();     }     this.showFilters = !this.showFilters;   } }
|   |   |   +-- ixt-table.index.ts: export * from './ixt-table.component'; export * from './ixt-table.interfaces'; export * from './ixt-table.module';
|   |   |   +-- ixt-table.interfaces.ts: export interface TableColumnDef<T> {   key: keyof T;   header: string;   editable?: boolean;   sortable?: boolean;   filterable?: boolean;   width?: string;   formatter?: (value: any) => string;   validator?: (value: any) => boolean | string; }  export interface TableConfig<T> {   columns: TableColumnDef<T>[];   selectionMode?: 'none' | 'single' | 'multiple';   pageSize?: number;   pageSizeOptions?: number[];   allowAdd?: boolean;   allowEdit?: boolean;   allowDelete?: boolean; }  export interface PaginationConfig {   pageSize: number;   currentPage: number;   totalItems: number;   pageSizeOptions: number[]; }
|   |   |   -- ixt-table.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTableComponent } from './ixt-table.component';  @NgModule({   declarations: [     IxtTableComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtTableComponent   ] }) export class IxtTableModule { }
|   |   +-- ixt-table-tree
|   |   |   +-- ixt-table-tree.component.html: <p>ixt-table-tree works!</p> 
|   |   |   +-- ixt-table-tree.component.scss: 
|   |   |   +-- ixt-table-tree.component.ts: import { Component } from '@angular/core';  @Component({   selector: 'ixt-ixt-table-tree',   templateUrl: './ixt-table-tree.component.html',   styleUrls: ['./ixt-table-tree.component.scss'] }) export class IxtTableTreeComponent {  } 
|   |   |   -- ixt-table-tree.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTableTreeComponent } from './ixt-table-tree.component';  @NgModule({   declarations: [     IxtTableTreeComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtTableTreeComponent   ] }) export class IxtTableTreeModule { } 
|   |   +-- ixt-tabset
|   |   |   +-- ixt-tab.component.html: <ng-template>   <ng-content></ng-content> </ng-template> 
|   |   |   +-- ixt-tab.component.scss: :host {   display: flex;   flex: 1;   min-height: 0;   min-width: 0; } 
|   |   |   +-- ixt-tab.component.ts: import { Component, Input, TemplateRef, ViewChild } from '@angular/core';  @Component({   selector: 'ixt-tab',   templateUrl: './ixt-tab.component.html',   styleUrls: ['./ixt-tab.component.scss'] }) export class IxtTabComponent {   @Input() title: string = '';   @ViewChild(TemplateRef, { static: true }) implicitContent!: TemplateRef<any>; } 
|   |   |   +-- ixt-tabset.component.html: <div class="button-row">   <button *ngFor="let tab of tabs; let idx = index"           [class.selected]="selectedIndex === idx"           (click)="selectTab(tab)">     {{ tab.title }}   </button> </div> <div class="content">   <div class="top-band">     <span>🔔</span>     <span>{{ notificationText }}</span>   </div>   <div *ngFor="let tab of tabs; let idx = index"        [id]="'tab' + (idx + 1)"        class="main-content"        [class.active]="selectedIndex === idx">     <ng-container *ngTemplateOutlet="tab.implicitContent"></ng-container>   </div> </div> 
|   |   |   +-- ixt-tabset.component.scss: :host {   display: flex;   flex-direction: column;   flex: 1;   min-height: 0;   min-width: 0;   height: 100%; }   .button-row {   display: flex;   gap: 10px;   justify-content: flex-start;   border-bottom: 2px solid #007BFF;   margin-bottom: -2px;    button {     background-color: #f0f0f0;     border: 1px solid #ccc;     border-bottom: none;     padding: 10px 20px;     cursor: pointer;     font-size: 16px;     transition: background-color 0.3s, color 0.3s;      &:hover {       background-color: #e0e0e0;     }      &.selected {       background-color: #007BFF;       color: #ffffff;       border: 1px solid #007BFF;       border-bottom: 2px solid #007BFF;       font-weight: bold;     }   } }  .content {   border: 2px solid #007BFF;   margin-top: -2px;   display: flex;   flex-direction: column;   flex: 1;   min-height: 0;    .top-band {     background-color: #007BFF;     color: #ffffff;     padding: 10px;     display: flex;     align-items: center;     gap: 10px;   }    .main-content {     display: none;     flex: 1;     min-height: 0;        &.active {       display: flex;       flex-direction: column;       padding: 20px;        // Changed from 10px to 20px to match the panel container       box-sizing: border-box;        }   }  } 
|   |   |   +-- ixt-tabset.component.ts: import { Component, ContentChildren, QueryList, AfterContentInit } from '@angular/core'; import { IxtTabComponent } from './ixt-tab.component';  @Component({   selector: 'ixt-tabset',   templateUrl: './ixt-tabset.component.html',   styleUrls: ['./ixt-tabset.component.scss'] }) export class IxtTabsetComponent implements AfterContentInit {   @ContentChildren(IxtTabComponent) tabs!: QueryList<IxtTabComponent>;    selectedIndex: number = 0;   notificationText: string = 'Content Band Icons or Info';    ngAfterContentInit() {     // Set initial active tab if there are tabs     if (this.tabs?.first) {       this.selectTab(this.tabs.first);     }      // Listen for dynamic tab changes     this.tabs?.changes.subscribe(() => {       if (this.tabs.length && this.selectedIndex >= this.tabs.length) {         this.selectTab(this.tabs.last);       }     });   }    selectTab(tab: IxtTabComponent) {     this.selectedIndex = this.tabs.toArray().indexOf(tab);   } } 
|   |   |   +-- ixt-tabset.index.ts: export * from './ixt-tabset.component'; export * from './ixt-tab.component';  // Updated path export * from './ixt-tabset.interfaces'; export * from './ixt-tabset.module'; 
|   |   |   +-- ixt-tabset.interfaces.ts: export interface ITabContent {   id: string;   title: string;   content: string;   active: boolean; }  export interface ITabsetConfig {   notificationText?: string;   showNotificationBand?: boolean;   animationDuration?: number; } 
|   |   |   -- ixt-tabset.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtTabsetComponent } from './ixt-tabset.component'; import { IxtTabComponent } from './ixt-tab.component';  // Updated path  @NgModule({   declarations: [     IxtTabsetComponent,     IxtTabComponent   ],   imports: [     CommonModule   ],   exports: [     IxtTabsetComponent,     IxtTabComponent   ] }) export class IxtTabsetModule { } 
|   |   +-- ixt-text
|   |   |   +-- ixt-text.component.html: <p>ixt-text works!</p> 
|   |   |   +-- ixt-text.component.scss: 
|   |   |   +-- ixt-text.component.ts: import { Component } from '@angular/core';  @Component({   selector: 'ixt-ixt-text',   templateUrl: './ixt-text.component.html',   styleUrls: ['./ixt-text.component.scss'] }) export class IxtTextComponent {  } 
|   |   |   -- ixt-text.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTableComponent } from './ixt-text.component';  @NgModule({   declarations: [     IxtTextComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtTextComponent   ] }) export class IxtTableModule { } 
|   |   +-- ixt-text-editor
|   |   |   +-- ixt-text-editor.component.html: <p>ixt-text-editor works!</p> 
|   |   |   +-- ixt-text-editor.component.scss: 
|   |   |   +-- ixt-text-editor.component.ts: import { Component } from '@angular/core';  @Component({   selector: 'ixt-ixt-text-editor',   templateUrl: './ixt-text-editor.component.html',   styleUrls: ['./ixt-text-editor.component.scss'] }) export class IxtTextEditorComponent {  } 
|   |   |   -- ixt-text-editor.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTextEditorComponent } from './ixt-text-editor.component';  @NgModule({   declarations: [     IxtTextEditorComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtTextEditorComponent   ] }) export class IxtTableModule { } 
|   |   +-- ixt-textra
|   |   +-- ixt-tree
|   |   |   +-- ixt-tree.component.html: <ul class="tree-container">   <ng-container *ngFor="let node of nodes; trackBy: trackByFn">     <li class="tree-node" (click)="selectNode(node, $event)">       <div class="node-content">         <span class="icon-container" (click)="toggleNode(node, $event)">           <ng-container *ngIf="node.children && node.children.length > 0">             <span class="expand-icon" [class.expanded]="node.expanded">               {{node.expanded ? '▼' : '▶'}}             </span>           </ng-container>           <span class="node-icon">             {{(node.children && node.children.length > 0) ? '📁' : '📄'}}           </span>         </span>         <span class="node-label">{{node.label}}</span>       </div>       <ul *ngIf="node.expanded && node.children" class="tree-children">         <ixt-tree           [nodes]="node.children"           (nodeExpanded)="nodeExpanded.emit($event)"           (nodeCollapsed)="nodeCollapsed.emit($event)"           (nodeSelected)="nodeSelected.emit($event)">         </ixt-tree>       </ul>     </li>   </ng-container> </ul>  
|   |   |   +-- ixt-tree.component.scss: .tree-container {   list-style: none;   padding: 0;   margin: 0; }  .tree-node {   padding: 0;   margin: 0;    .node-content {     display: flex;     align-items: center;     padding: 4px 8px;     cursor: pointer;     transition: background-color 0.2s ease;      &:hover {       background-color: rgba(0, 0, 0, 0.04);     }   }    .icon-container {     display: flex;     align-items: center;     margin-right: 4px;      .expand-icon {       font-size: 12px;       width: 16px;       height: 16px;       display: inline-flex;       align-items: center;       justify-content: center;       cursor: pointer;       transition: transform 0.2s ease;        &.expanded {         transform: rotate(0deg);       }        &:not(.expanded) {         transform: rotate(-90deg);       }     }      .node-icon {       font-size: 14px;       margin-right: 4px;       opacity: 0.7;     }   }    .node-label {     font-size: 14px;     color: rgba(0, 0, 0, 0.87);   } }  .tree-children {   list-style: none;   padding-left: 24px;   margin: 0; } 
|   |   |   +-- ixt-tree.component.ts: // ixt-tree.component.ts import { Component, Input, Output, EventEmitter } from '@angular/core';  export interface TreeNode {   id: string;   label: string;   expanded?: boolean;   children?: TreeNode[];   isLeaf?: boolean; }  @Component({   selector: 'ixt-tree',   templateUrl: './ixt-tree.component.html',   styleUrls: ['./ixt-tree.component.scss'] }) export class IxtTreeComponent {   @Input() nodes: TreeNode[] = [];   @Output() nodeExpanded = new EventEmitter<TreeNode>();   @Output() nodeCollapsed = new EventEmitter<TreeNode>();   @Output() nodeSelected = new EventEmitter<TreeNode>();    toggleNode(node: TreeNode, event: Event): void {     event.stopPropagation();      if (node.children && node.children.length > 0) {       node.expanded = !node.expanded;       if (node.expanded) {         this.nodeExpanded.emit(node);       } else {         this.nodeCollapsed.emit(node);       }     }   }    selectNode(node: TreeNode, event: Event): void {     event.stopPropagation();     this.nodeSelected.emit(node);   }    trackByFn(index: number, item: TreeNode): string {     return item.id;   } }  
|   |   |   -- ixt-tree.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTreeComponent } from './ixt-tree.component';  @NgModule({   declarations: [     IxtTreeComponent   ],   imports: [     CommonModule,     FormsModule   ],   exports: [     IxtTreeComponent   ] }) export class IxtTreeModule { } 
|   |   -- theme
|   |      +-- indext.ts: // src/components/theme/index.ts export * from './theme.types'; export * from './theme.colors';
|   |      +-- theme.colors.ts: import { ThemeColors } from "./theme.types";  // src/app/theme/theme.colors.ts export const baseThemeColors: ThemeColors = {     primary: {       base: '#4169E1',    // Royal Blue       hover: '#2850c9',       active: '#1e40af',       text: '#ffffff'     },     secondary: {       base: '#6c757d',       hover: '#5c636a',       active: '#4d5154',       text: '#ffffff'     },     success: {       base: '#28a745',       hover: '#218838',       active: '#1e7e34',       text: '#ffffff'     },     danger: {       base: '#dc3545',       hover: '#c82333',       active: '#bd2130',       text: '#ffffff'     },     warning: {       base: '#ffc107',       hover: '#e0a800',       active: '#d39e00',       text: '#000000'     },     info: {       base: '#17a2b8',       hover: '#138496',       active: '#117a8b',       text: '#ffffff'     },     light: {       base: '#f8f9fa',       hover: '#e2e6ea',       active: '#dae0e5',       text: '#000000'     },     dark: {       base: '#343a40',       hover: '#23272b',       active: '#1d2124',       text: '#ffffff'     },     default: {       base: '#ffffff',       hover: '#f8f9fa',       active: '#e9ecef',       text: '#000000'     }   };
|   |      +-- theme.module.ts: // src/components/theme/theme.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common';  @NgModule({   imports: [CommonModule],   exports: [] }) export class ThemeModule {}
|   |      -- theme.types.ts: // src/app/theme/theme.types.ts export type ThemeVariant =    | 'primary'    // Main brand color, key actions   | 'secondary'  // Supporting color   | 'success'    // Positive actions/states   | 'danger'     // Errors, destructive actions   | 'warning'    // Caution states   | 'info'       // Informational states   | 'light'      // Light backgrounds   | 'dark'       // Dark text/backgrounds   | 'default';   // Default state  export interface ThemeColor {   base: string;   hover: string;   active: string;   text: string; }  export type ThemeColors = Record<ThemeVariant, ThemeColor>;
|   +-- favicon.ico
|   +-- index.html: <!doctype html> <html> <head>   <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">   <meta charset="utf-8">   <title>Ixtlan Demo</title>   <base href="/">   <meta name="viewport" content="width=device-width, initial-scale=1">   <link rel="icon" type="image/x-icon" href="favicon.ico"> </head> <body> <app-root></app-root> </body> </html> 
|   +-- main.ts: import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module';  platformBrowserDynamic().bootstrapModule(AppModule)   .catch(err => console.error(err)); 
|   +-- polyfills.ts: import 'zone.js'; 
|   +-- public-api.ts: export * from './components/ixt-table/ixt-table.index'; //export * from './components/ixt-table/ixt-table.interfaces'; //export * from './components/ixt-table/ixt-table.module';  export * from './components/ixt-tabset/ixt-tabset.index'; //export * from './components/ixt-tabset/ixt-tabset.interfaces'; //export * from './components/ixt-tabset/ixt-tabset.module';   export * from './components/ixt-matrix/ixt-matrix.index'; export * from './components/ixt-dialog/ixt-dialog.index'; 
|   +-- reset.scss: 
|   +-- services
|   |   -- breadcrumb.service.ts: import { Injectable } from '@angular/core'; import { Router, NavigationEnd, ActivatedRoute } from '@angular/router'; import { filter, map } from 'rxjs/operators'; import { Observable } from 'rxjs';  export interface Breadcrumb {   label: string;   url: string; }  @Injectable({   providedIn: 'root' }) export class BreadcrumbService {   breadcrumbs$: Observable<Breadcrumb[]>;    constructor(private router: Router, private activatedRoute: ActivatedRoute) {     this.breadcrumbs$ = this.router.events.pipe(       filter(event => event instanceof NavigationEnd),       map(event => {         const root = this.activatedRoute.root;         return this.createBreadcrumbs(root);       })     );   }    private createBreadcrumbs(route: ActivatedRoute, url: string = '', breadcrumbs: Breadcrumb[] = []): Breadcrumb[] {     const children: ActivatedRoute[] = route.children;      if (children.length === 0) {       return breadcrumbs;     }      for (const child of children) {       const routeURL: string = child.snapshot.url.map(segment => segment.path).join('/');       if (routeURL !== '') {         url += `/${routeURL}`;       }        const label = child.snapshot.data['breadcrumb'];       if (label) {         breadcrumbs.push({ label, url });       }       return this.createBreadcrumbs(child, url, breadcrumbs);     }     return breadcrumbs;   } } 
|   -- styles.scss: @import "@angular/material/prebuilt-themes/indigo-pink.css";  html, body {   height: 100vh;   margin: 0;   padding: 0;   overflow: hidden; }  app-root {   display: block;   height: 100vh;   width: 100vw;   padding: 10px; }  main {   display: grid;   grid-template-areas:       "nav header header"       "nav section aside"       "nav footer footer";   grid-template-columns: 300px 1fr 300px;   grid-template-rows: 80px 1fr 80px;   height: calc(100% - 20px);   width: calc(100% - 20px);   gap: 8px; }  nav, header, section, aside, footer {   background: white;   box-shadow: 0 2px 4px rgba(0,0,0,0.1); }  nav { grid-area: nav; } header { grid-area: header; } section { grid-area: section; } aside { grid-area: aside; } footer { grid-area: footer; }     .form-grid {   display: grid;   grid-template-columns: repeat(3, 1fr);   gap: 20px;   padding: 20px; }  h3 {   grid-column: 1 / -1;   margin: 20px 0 10px;   border-bottom: 1px solid #ddd; }  .field {   display: grid;   gap: 5px;    label {     font-weight: 500;   }    input, select {     padding: 8px;     border: 1px solid #ccc;     border-radius: 4px;   } }  .actions {   grid-column: 1 / -1;   display: flex;   gap: 10px;   justify-content: flex-end;   margin-top: 20px;    button {     padding: 8px 16px;     border: none;     border-radius: 4px;     cursor: pointer;      &:first-child {       background: #007bff;       color: white;     }      &:last-child {       background: #6c757d;       color: white;     }   } }  .expression-tab-container {   padding: 20px;    .tab-header {     margin-bottom: 20px;   }    .preview-container {     margin-top: 20px;     padding: 15px;     background: #f8f9fa;     border-radius: 4px;      pre {       background: #fff;       padding: 10px;       border-radius: 4px;       border: 1px solid #eee;     }   }     .autocomplete-wrapper {     margin-top: 20px;     width: 50%;   } }  .ixt-panel-container {   padding: 20px;    // Header styling   .title {       font-size: 24px;       margin-bottom: 24px;       padding-bottom: 16px;       border-bottom: 1px solid rgba(0, 0, 0, 0.12);   }    // Grid container for the panels   .panel-grid {       display: grid;       grid-template-columns: repeat(2, 1fr);       gap: 24px;   } }
+-- tag.bat
+-- tree-content.ps1
+-- tree-content.py
+-- tree.ps1
+-- tsconfig.app.json
+-- tsconfig.json
+-- tsconfig.lib.json
+-- tsconfig.lib.prod.json
-- tsconfig.spec.json
