+-- .angular
|   \-- cache
+-- src
|   +-- app
|   |   +-- accordion
|   |   |   --- accordion.data.ts: import { Injectable } from '@angular/core'; import { AccordionPanel } from '../../components/ixt-accordian/ixt-accordian.component'; @Injectable({ providedIn: 'root' }) export class AccordianDataService { getAccordianPanels(): AccordionPanel[] { return [ { title: 'Section 1', content: 'Content for section 1', isOpen: false }, { title: 'Section 2', content: 'Content for section 2', isOpen: false }, { title: 'Section 3', content: 'Content for section 3', isOpen: false } ]; } }
|   |   +-- dialog
|   |   |   --- ixt-dialog.handler.ts: <empty file>
|   |   +-- expression
|   |   |   --- ixt-expression.helper.ts: // src/app/expression/ixt-expression.helper.ts import { Injectable } from '@angular/core'; // Add this import { Expression, ExpressionGroup } from '../../components/ixt-expression-builder/ixt-expression-builder.interfaces'; @Injectable() export class IxtExpressionHelper { convertToJsonLogic(group: ExpressionGroup): any { if (group.children.length === 0) return {}; const logic: any = { [group.operator]: group.children.map((child: Expression | ExpressionGroup) => { if (child.type === 'group') { return this.convertToJsonLogic(child); } if (child.type === 'expression') { if (child.operator === 'in' || child.operator === 'not_in') { return { [child.operator === 'in' ? 'in' : '!in']: [ { var: child.field }, child.values || [] ] }; } return { [child.operator]: [ { var: child.field }, child.value ] }; } return {}; }) }; return logic; } }
|   |   |   --- ixt-expression.provider.ts: // src/app/expression/ixt-expression.provider.ts import { Injectable } from '@angular/core'; // Add this import { Expression, ExpressionGroup } from '../../components/ixt-expression-builder/ixt-expression-builder.interfaces'; import { IxtExpressionHelper } from './ixt-expression.helper'; @Injectable() // Add this export class IxtExpressionProvider { expressionGroup: ExpressionGroup = { type: 'group', operator: 'and', children: [] }; expressionJsonLogic: any = {}; constructor(private helper: IxtExpressionHelper) {} onExpressionGroupChange(group: ExpressionGroup): void { this.expressionGroup = group; this.expressionJsonLogic = this.helper.convertToJsonLogic(group); } }
|   |   +-- form
|   |   |   --- ixt-employee-form.handler.ts: // src/app/form/ixt-employee-form.handler.ts import { Injectable } from '@angular/core'; import { IxtEmployeeFormProvider } from './ixt-employee-form.provider'; import { IxtDialogService } from '../../components/ixt-dialog/ixt-dialog.service'; import { EmployeeForm } from './ixt-employee-form.provider'; @Injectable() export class IxtEmployeeFormHandler { constructor( private provider: IxtEmployeeFormProvider, private dialogService: IxtDialogService ) {} async submitForm() { const form = this.provider.getCurrentForm(); // Validate form if (!this.validateForm(form)) { // this.dialogService.show({ // title: 'Validation Error', // message: 'Please fill in all required fields.', // type: DialogType.Error, // okText: 'OK', // showCancel: false, // isModal: true // }); return; } try { // Simulate API call await this.saveEmployee(form); // this.dialogService.show({ // title: 'Success', // message: 'Employee information saved successfully!', // type: DialogType.Success, // okText: 'OK', // showCancel: false, // isModal: true // }); this.provider.resetForm(); } catch (error) { // this.dialogService.show({ // title: 'Error', // message: 'Failed to save employee information. Please try again.', // type: DialogType.Error, // okText: 'OK', // showCancel: false, // isModal: true // }); } } confirmDelete(employeeId: number) { // this.dialogService.show({ // title: 'Confirm Delete', // message: 'Are you sure you want to delete this employee record?', // type: DialogType.Question, // okText: 'Yes', // cancelText: 'No', // showCancel: true, // isModal: true // }); } updateField(field: keyof EmployeeForm, value: any) { this.provider.updateForm({ [field]: value }); } private validateForm(form: EmployeeForm): boolean { return !!( form.firstName && form.lastName && form.email && form.department && form.position && form.hireDate ); } private async saveEmployee(form: EmployeeForm): Promise<void> { // Simulate API call return new Promise((resolve, reject) => { setTimeout(() => { // Simulate 90% success rate if (Math.random() > 0.1) { resolve(); } else { reject(new Error('Failed to save employee')); } }, 1000); }); } showUnsavedChangesDialog(): Promise<boolean> { return new Promise((resolve) => { // this.dialogService.show({ // title: 'Unsaved Changes', // message: 'You have unsaved changes. Do you want to continue?', // type: DialogType.Warning, // okText: 'Yes', // cancelText: 'No', // showCancel: true, // isModal: true // }); }); } resetForm() { // this.dialogService.show({ // title: 'Confirm Reset', // message: 'Are you sure you want to reset the form? All unsaved changes will be lost.', // type: DialogType.Warning, // okText: 'Yes', // cancelText: 'No', // showCancel: true, // isModal: true // }); } }
|   |   |   --- ixt-employee-form.provider.ts: // src/app/form/ixt-employee-form.provider.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; export interface EmployeeForm { id?: number; firstName: string; lastName: string; email: string; phone: string; department: string; position: string; hireDate: Date; // Add any other employee fields you need } @Injectable() export class IxtEmployeeFormProvider { private formState = new BehaviorSubject<EmployeeForm>({ firstName: '', lastName: '', email: '', phone: '', department: '', position: '', hireDate: new Date() }); formState$ = this.formState.asObservable(); updateForm(form: Partial<EmployeeForm>) { this.formState.next({ ...this.formState.value, ...form }); } resetForm() { this.formState.next({ firstName: '', lastName: '', email: '', phone: '', department: '', position: '', hireDate: new Date() }); } getCurrentForm(): EmployeeForm { return this.formState.value; } }
|   |   +-- layer
|   |   |   --- ixt-layer.manager.ts: // src/app/layer/ixt-layer.manager.ts import { Injectable } from '@angular/core'; import { Layer } from '../../components/ixt-layer-manager/ixt-layer-manager.component'; @Injectable({ providedIn: 'root' // Makes it a singleton service available app-wide }) export class IxtLayerManager { onLayerChange(layers: any[]) { console.log('Layers updated:', layers); // Implement your layer update logic here } onLayerOrderChange(layers: any[]) { console.log('Layer order changed:', layers); // Implement your layer order update logic here } }
|   |   |   --- ixt-layer.provider.ts: // src/app/layer/ixt-layer.provider.ts import { Injectable } from '@angular/core'; import { Layer } from '../../components/ixt-layer-manager/ixt-layer-manager.component'; @Injectable({ providedIn: 'root' // Makes it a singleton service available app-wide }) export class IxtLayerProvider { mapLayers: Layer[] = [ { id: 'layer1', name: 'Base Map', visible: true, fillColor: '#e3e3e3', strokeColor: '#666666', strokeStyle: 'solid' as const, order: 0 }, { id: 'layer2', name: 'Roads', visible: true, fillColor: '#ffffff', strokeColor: '#333333', strokeStyle: 'solid' as const, order: 1 }, { id: 'layer3', name: 'Points of Interest', visible: true, fillColor: '#ff4444', strokeColor: '#cc0000', strokeStyle: 'dotted' as const, order: 2 } ]; }
|   |   +-- menu
|   |   |   --- ixt-menu.provider.ts: // ixt-menu.provider.ts import { Injectable } from '@angular/core'; //import { MenuNode } from 'src/components/ixt-menu'; @Injectable({ providedIn: 'root' }) export class IxtMenuProvider { }
|   |   +-- table
|   |   |   --- ixt-table.provider.ts: // src/app/matrix/ixt-matrix.provider.ts import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { Observable } from 'rxjs'; import { IxtDialogService } from 'src/components/ixt-dialog/ixt-dialog.service'; import { ColumnConfigs, AirportCodeEditorComponent, CoordinateEditorComponent } from 'src/public-api'; @Injectable({ providedIn: 'root' }) export class IxtTableProvider { constructor( private http: HttpClient, private dialogService: IxtDialogService ) {} getColumnConfigs(): ColumnConfigs { return { code: { type: AirportCodeEditorComponent as any, field: 'code', editable: true, label: 'IATA Code' }, region: { type: 'text', field: 'region', label: 'Region', editable: true }, name: { type: 'text', field: 'name', label: 'Name', editable: true }, city: { type: 'text', field: 'city', label: 'City', editable: true }, country: { type: 'text', field: 'country', label: 'Country', editable: true }, lat: { type: CoordinateEditorComponent, field: 'lat', label: 'LAT', editable: true }, lon: { type: CoordinateEditorComponent, field: 'lon', label: 'LON', editable: true } }; } getAirportData(): Observable<any[]> { return this.http.get<any[]>('assets/Airport.json'); } getAirportColumnConfigs(): ColumnConfigs { return this.getColumnConfigs(); } }
|   |   +-- tree
|   |   |   --- ixt-tree.handler.ts: // src/app/tree/ixt-tree.handler.ts import { Injectable } from '@angular/core'; import { TreeNode } from '../../components/ixt-tree/ixt-tree.component'; @Injectable({ providedIn: 'root' }) export class IxtTreeHandler { onNodeExpanded(node: TreeNode): void { console.log('Node expanded:', node); } onNodeCollapsed(node: TreeNode): void { console.log('Node collapsed:', node); } onNodeSelected(node: TreeNode): void { console.log('Node selected:', node); } }
|   |   |   --- ixt-tree.provider.ts: // src/app/tree/ixt-tree.provider.ts import { Injectable } from '@angular/core'; import { TreeNode } from '../../components/ixt-tree/ixt-tree.component'; @Injectable({ providedIn: 'root' }) export class IxtTreeProvider { treeData: TreeNode[] = [ { id: '1', label: 'Project Files', children: [ { id: '1.1', label: 'src', children: [ { id: '1.1.1', label: 'app', children: [ { id: '1.1.1.1', label: 'components' }, { id: '1.1.1.2', label: 'services' } ] }, { id: '1.1.2', label: 'assets' } ] }, { id: '1.2', label: 'config', children: [ { id: '1.2.1', label: 'tsconfig.json' }, { id: '1.2.2', label: 'package.json' } ] } ] } ]; }
|   |   --- app.component.html: <main> <nav> <ixt-tabset title="Employee Form"> <ixt-tab title="Tab 1"> <ixt-tree [nodes]="treeProvider.treeData" (nodeExpanded)="treeHandler.onNodeExpanded($event)" (nodeCollapsed)="treeHandler.onNodeCollapsed($event)" (nodeSelected)="treeHandler.onNodeSelected($event)"> </ixt-tree> </ixt-tab> <ixt-tab title="Tab 2"> <ixt-accordian [panels]="accordionPanels" [allowMultiple]="true"> </ixt-accordian> </ixt-tab> </ixt-tabset> </nav> <header> <ixt-menu src="./../assets/menu.json" brandName="Your Brand" brandLogo="./../assets/logo.png" brandLink="/" variant="default" [showSearch]="true" searchPlaceholder="Search products..." (searchSubmitted)="onSearch($event)"> </ixt-menu> </header> <section> <ixt-tabset> <ixt-tab title="diagrams"> <ixt-tabset> <ixt-tab title="Clazz"> <ixt-clazz></ixt-clazz> </ixt-tab> <ixt-tab title="Sequence"> <ixt-diagram></ixt-diagram> </ixt-tab> <ixt-tab title="viewport"> <ixt-viewport></ixt-viewport> </ixt-tab> <ixt-tab title="cavas"> <ixt-canvas></ixt-canvas> </ixt-tab> <ixt-tab title="EBNF"> <ixt-ebnf></ixt-ebnf> </ixt-tab> <ixt-tab title="ERD"> <ixt-erd></ixt-erd> </ixt-tab> <ixt-tab title="Network"> <ixt-network></ixt-network> </ixt-tab> <ixt-tab title="Flow"> <ixt-flow></ixt-flow> </ixt-tab> <ixt-tab title="Gannt"> <gannt-diagram></gannt-diagram> </ixt-tab> <ixt-tab title="Sankey"> <ixt-sankey></ixt-sankey> </ixt-tab> <ixt-tab title="Wireframe"> <ixt-wireframe></ixt-wireframe> </ixt-tab> </ixt-tabset> </ixt-tab> <ixt-tab title="D3 Geo"> <ixt-map [width]="'100%'" [height]="'80%'" scale="1" translate="0,0"> <ixt-layer src="./../assets/countries.geojson" stroke="black" fill="gray"></ixt-layer> <ixt-layer src="./../assets/flights.minified.geojson" stroke="red" fill="none" (click)="select($event)"> properties.airlineIata === 'F9' </ixt-layer> <ixt-layer src="./../assets/flights.minified.geojson" stroke="green" fill="none" (click)="select($event)"> properties.airlineIata === 'NK' </ixt-layer> <ixt-layer src="./../assets/lakes.geojson" stroke="black" fill="blue" (click)="select($event)"></ixt-layer> <ixt-layer src="./../assets/rivers.geojson" stroke="purple" fill="none" (hover)="highlight($event)"></ixt-layer> </ixt-map> </ixt-tab> <ixt-tab title="Buttons"> <div class="button-showcase"> <!-- Size Variants --> <div class="section"> <h4>Size Variants</h4> <div class="button-row"> <ixt-button variant="primary" size="sm">Small</ixt-button> <ixt-button variant="primary" size="md">Medium</ixt-button> <ixt-button variant="primary" size="lg">Large</ixt-button> </div> </div> <!-- Theme Variants --> <div class="section"> <h4>Theme Variants</h4> <div class="button-row"> <div class="theme"> <h5>Base Theme</h5> <div class="button-row"> <ixt-button variant="primary">Primary</ixt-button> <ixt-button variant="secondary">Secondary</ixt-button> <ixt-button variant="danger">Danger</ixt-button> </div> </div> <div class="theme"> <h5>United Theme</h5> <div class="button-row"> <ixt-button variant="primary" [theme]="unitedThemeColors">Primary</ixt-button> <ixt-button variant="secondary" [theme]="unitedThemeColors">Secondary</ixt-button> <ixt-button variant="danger" [theme]="unitedThemeColors">Danger</ixt-button> </div> </div> </div> </div> <!-- Examples --> <div class="section"> <h4>Examples</h4> <div class="button-row"> <ixt-button *ngFor="let button of buttonDemos" [variant]="button.variant" [size]="button.size || 'md'" [theme]="button.theme || baseThemeColors" [disabled]="button.disabled" (onClick)="handleButtonClick(button.label)"> <span *ngIf="button.prefix" prefix>{{button.prefix}}</span> {{button.label}} <span *ngIf="button.suffix" suffix>{{button.suffix}}</span> </ixt-button> </div> </div> </div> </ixt-tab> <!-- Dialog Example --> <ixt-tab title="Dialog Example"> <div class="dialog-demo-container flex flex-col gap-4 p-4"> <!-- Service-based dialogs --> <div class="flex flex-col gap-2"> <h3 class="text-lg font-semibold">Service-based Dialogs</h3> <div class="flex flex-wrap gap-2"> <button (click)="showSuccessDialog()" class="px-4 py-2 bg-green-500 text-white rounded"> Success Dialog </button> </div> </div> </div> </ixt-tab> <ixt-tab title="Employee Form"> <form class="form-grid"> <h3>Personal Information</h3> <div class="field"> <label>First Name</label> <input type="text" [(ngModel)]="formData.firstName" name="firstName"> </div> <div class="field"> <label>Last Name</label> <input type="text" [(ngModel)]="formData.lastName" name="lastName"> </div> <div class="field"> <label>Email</label> <input type="email" [(ngModel)]="formData.email" name="email"> </div> <h3>Employment Details</h3> <div class="field"> <label>Department</label> <input type="text" [(ngModel)]="formData.department" name="department"> </div> <div class="field"> <label>Position</label> <input type="text" [(ngModel)]="formData.position" name="position"> </div> <div class="field"> <label>Start Date</label> <input type="date" [(ngModel)]="formData.hireDate" name="hireDate"> </div> <div class="actions"> <button type="button" (click)="employeeFormHandler.submitForm()">Save</button> <button type="button" (click)="employeeFormHandler.resetForm()">Cancel</button> </div> </form> </ixt-tab> <ixt-tab title="Calendar"> <ixt-calendar></ixt-calendar> </ixt-tab> <ixt-tab title="Standard Table"> <ixt-table [data]="tableAirportData" [columnConfigs]="tableColumnConfigs" *ngIf="tableAirportData.length"> </ixt-table> </ixt-tab> <ixt-tab title="IxtSplitPane"> <ixt-split-pane> <div class="left-pane"> <h2>Left</h2> </div> <div class="right-pane"> <h2>Right</h2> </div> </ixt-split-pane> </ixt-tab> <ixt-tab title="Panels"> <h2>Examples</h2> <div class="ixt-panel-container"> <div class="panel-grid"> <ixt-panel title="Basic Panel"> <div class="panel-content"> This is a basic panel with default settings (bordered=true, elevated=false) </div> </ixt-panel> <ixt-panel title="Elevated Panel" [elevated]="true" caption="With caption text"> <div class="panel-content"> This panel has elevation enabled, creating a shadow effect </div> </ixt-panel> <ixt-panel title="No Border Panel" [bordered]="false" [padding]="true"> <div class="panel-content"> This panel has borders disabled but keeps padding </div> </ixt-panel> <ixt-panel [bordered]="false" [padding]="false" [elevated]="false"> <div class="panel-content"> A minimal panel without title, borders, elevation or padding </div> </ixt-panel> </div> </div> </ixt-tab> </ixt-tabset> </section> <aside> <ixt-layer-manager [layers]="layerProvider.mapLayers" (layerChange)="layerManager.onLayerChange($event)" (layerOrderChange)="layerManager.onLayerOrderChange($event)"> </ixt-layer-manager> </aside> <footer>Footer</footer> </main> <app-lunch-form></app-lunch-form>
|   |   --- app.component.ts: import { Component, ViewChild, AfterViewInit } from '@angular/core'; import { IxtLayerProvider } from './layer/ixt-layer.provider'; import { IxtLayerManager } from './layer/ixt-layer.manager'; import { IxtTreeProvider } from './tree/ixt-tree.provider'; import { IxtTreeHandler } from './tree/ixt-tree.handler'; import { IxtExpressionProvider } from './expression/ixt-expression.provider'; import { IxtExpressionHelper } from './expression/ixt-expression.helper'; import { IxtEmployeeFormProvider } from './form/ixt-employee-form.provider'; import { IxtEmployeeFormHandler } from './form/ixt-employee-form.handler'; import { IxtTableProvider } from './table/ixt-table.provider'; import { IxtMenuProvider } from './menu/ixt-menu.provider'; import { AccordianDataService } from './accordion/accordion.data'; import { IxtDialogService } from 'src/components/ixt-dialog/ixt-dialog.service'; import { firstValueFrom } from 'rxjs'; import { NgForm } from '@angular/forms'; import { LunchFormComponent } from './lunch-form.component'; import { ThemeVariant, ThemeColors } from 'src/components/theme/theme.types'; import { baseThemeColors, unitedThemeColors } from 'src/components/theme/theme.colors'; // Add to existing AppComponent class export interface ButtonDemo { label: string; variant: ThemeVariant; size?: 'sm' | 'md' | 'lg'; theme?: ThemeColors; disabled: boolean; prefix?: string; suffix?: string; } @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'], providers: [ IxtLayerProvider, IxtLayerManager, IxtTreeProvider, IxtTreeHandler, IxtExpressionProvider, IxtExpressionHelper, IxtEmployeeFormProvider, IxtEmployeeFormHandler, IxtTableProvider, IxtMenuProvider ] }) export class AppComponent implements AfterViewInit { @ViewChild(LunchFormComponent, { static: true }) lunchForm!: LunchFormComponent; protected baseThemeColors = baseThemeColors; protected unitedThemeColors = unitedThemeColors; formData = this.employeeFormProvider.getCurrentForm(); tableAirportData: any[] = []; tableColumnConfigs = this.tableProvider.getAirportColumnConfigs(); accordionPanels = this.accordianDataService.getAccordianPanels(); constructor( private dialog: IxtDialogService, public layerProvider: IxtLayerProvider, public layerManager: IxtLayerManager, public treeProvider: IxtTreeProvider, public treeHandler: IxtTreeHandler, public expressionProvider: IxtExpressionProvider, public expressionHelper: IxtExpressionHelper, public employeeFormProvider: IxtEmployeeFormProvider, public employeeFormHandler: IxtEmployeeFormHandler, public tableProvider: IxtTableProvider, public menuProvider: IxtMenuProvider, private accordianDataService: AccordianDataService ) { } ngOnInit() { this.tableProvider.getAirportData().subscribe(data => { this.tableAirportData = data; }); } ngAfterViewInit() { } select(event: Event): void { console.log('Selected:', event); } highlight(event: Event): void { console.log('Highlighted:', event); } onSearch(searchTerm: string) { console.log('Search term:', searchTerm); } // Dialog examples using improved service ------------------------------------------------------ async showSuccessDialog() { console.log('Starting dialog test'); await this.dialog.success('Success123!', 'Success Dialog 456'); console.log('Dialog completed'); } buttonDemos: ButtonDemo[] = [ { label: 'Submit Form', variant: 'primary', size: 'lg', suffix: '→', disabled: false }, { label: 'Cancel', variant: 'secondary', size: 'lg', disabled: false }, { label: 'Delete Record', variant: 'danger', prefix: '⚠️', disabled: false }, { label: 'United Theme', variant: 'primary', theme: unitedThemeColors, size: 'lg', disabled: false }, { label: 'Processing...', variant: 'primary', disabled: true }, { label: 'View Details', variant: 'info', size: 'sm', disabled: false } ]; handleButtonClick(label: string) { console.log(`Button clicked: ${label}`); } }
|   |   --- app.module.ts: import { NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { HttpClientModule } from '@angular/common/http'; import { RouterModule } from '@angular/router'; // Import components individually since library isn't published yet import { IxtButtonModule } from 'src/components/ixt-button/ixt-button.module'; import { IxtDialogModule } from 'src/components/ixt-dialog/ixt-dialog.module'; import { IxtTableModule } from 'src/components/ixt-table/ixt-table.module'; import { IxtTabsetModule } from 'src/components/ixt-tabset/ixt-tabset.module'; // Fixed name import { IxtTabComponent } from 'src/components/ixt-tabset/ixt-tab.component'; // Added individual component import { IxtPanelModule } from 'src/components/ixt-panel/ixt-panel.module'; import { IxtMenuModule } from 'src/components/ixt-menu/ixt-menu.module'; import { IxtTreeModule } from 'src/components/ixt-tree/ixt-tree.module'; import { IxtAccordianModule } from 'src/components/ixt-accordian/ixt-accordian.module'; // Fixed path import { IxtCanvasModule } from 'src/components/ixt-canvas/ixt-canvas.module'; import { IxtViewportModule } from 'src/components/ixt-viewport/ixt-viewport.module'; import { IxtExpressionBuilderModule } from 'src/components/ixt-expression-builder/ixt-expression-builder.module'; import { IxtMapModule } from 'src/components/ixt-map/ixt-map.module'; import { IxtLayerModule } from 'src/components/ixt-map/ixt-layer.module'; import { IxtLayerManagerModule } from 'src/components/ixt-layer-manager/ixt-layer-manager.module'; import { IxtSplitPaneModule } from 'src/components/ixt-splitpane/ixt-split-pane.module'; import { IxtCalendarModule } from 'src/components/ixt-calendar/ixt-calendar.module'; // Diagram Modules import { IxtDiagramModule } from 'src/components/ixt-diagram/ixt-diagram.module'; import { IxtClazzModule } from 'src/components/ixt-diagram/types/clazz/ixt-clazz.module'; import { IxtDeploymentModule } from 'src/components/ixt-diagram/types/deployment/ixt-deployment.module'; import { IxtEbnfModule } from 'src/components/ixt-diagram/types/EBNF/ixt-ebnf.module'; // Fixed path import { IxtFlowModule } from 'src/components/ixt-diagram/types/flow/ixt-flow.module'; import { IxtGanntModule } from 'src/components/ixt-diagram/types/gannt/gannt.module'; import { IxtNetworkModule } from 'src/components/ixt-diagram/types/network/ixt-network.module'; import { IxtSankeyModule } from 'src/components/ixt-diagram/types/sankey/ixt-sankey.module'; import { IxtWireframeModule } from 'src/components/ixt-diagram/types/wireframe/ixt-wireframe.module'; // Components import { AppComponent } from './app.component'; import { LunchFormComponent } from './lunch-form.component'; // Providers import { IxtEmployeeFormHandler } from './form/ixt-employee-form.handler'; import { IxtEmployeeFormProvider } from './form/ixt-employee-form.provider'; import { IxtExpressionHelper } from './expression/ixt-expression.helper'; import { IxtExpressionProvider } from './expression/ixt-expression.provider'; import { IxtLayerManager } from './layer/ixt-layer.manager'; import { IxtLayerProvider } from './layer/ixt-layer.provider'; import { IxtTreeHandler } from './tree/ixt-tree.handler'; import { IxtTableProvider } from './table/ixt-table.provider'; import { IxtTreeProvider } from './tree/ixt-tree.provider'; @NgModule({ declarations: [ AppComponent, LunchFormComponent ], imports: [ // Angular Core Modules BrowserModule, BrowserAnimationsModule, FormsModule, ReactiveFormsModule, HttpClientModule, RouterModule.forRoot([]), // Ixtlan Modules IxtAccordianModule, IxtButtonModule, IxtCalendarModule, IxtCanvasModule, IxtDialogModule, IxtDiagramModule, IxtExpressionBuilderModule, IxtLayerModule, // Added Layer module IxtLayerManagerModule, IxtMapModule, IxtMenuModule, IxtPanelModule, IxtSplitPaneModule, IxtTableModule, IxtTreeModule, IxtTabsetModule, IxtViewportModule, // Diagram Type Modules IxtClazzModule, IxtDeploymentModule, IxtEbnfModule, IxtFlowModule, IxtGanntModule, IxtNetworkModule, IxtSankeyModule, IxtWireframeModule ], providers: [ IxtEmployeeFormHandler, IxtEmployeeFormProvider, IxtExpressionHelper, IxtExpressionProvider, IxtLayerManager, IxtLayerProvider, IxtTreeHandler, IxtTreeProvider, IxtTableProvider ], schemas: [ CUSTOM_ELEMENTS_SCHEMA // Added schema for custom elements ], bootstrap: [AppComponent] }) export class AppModule { }
|   |   --- lunch-form.component.html: <button (click)="showLunchOrderDialog()" class="place-order px-4 py-2 rounded"> Place Lunch Order </button> <ng-template #lunchOrderTemplate> <form #orderForm="ngForm"> <div class="space-y-4"> <div class="form-group"> <label class="block text-sm font-medium text-gray-700">Sandwich:</label> <select name="sandwich" [(ngModel)]="orderData.sandwich" required #sandwichField="ngModel" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" > <option value="">Select a sandwich</option> <option>grilled cheese</option> <option>roast beef</option> <option>hamburger</option> </select> <div *ngIf="sandwichField.invalid && sandwichField.touched" class="text-red-500 text-sm"> Please select a sandwich </div> </div> <div class="form-group"> <label class="block text-sm font-medium text-gray-700">Side:</label> <select name="side" [(ngModel)]="orderData.side" required #sideField="ngModel" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" > <option value="">Select a side</option> <option>French fries</option> <option>Onion Rings</option> <option>Salad</option> </select> <div *ngIf="sideField.invalid && sideField.touched" class="text-red-500 text-sm"> Please select a side </div> </div> <div class="form-group"> <label class="block text-sm font-medium text-gray-700">Drink:</label> <select name="drink" [(ngModel)]="orderData.drink" required #drinkField="ngModel" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" > <option value="">Select a drink</option> <option>Coke</option> <option>Coffee</option> <option>Juice</option> </select> <div *ngIf="drinkField.invalid && drinkField.touched" class="text-red-500 text-sm"> Please select a drink </div> </div> <div class="form-group"> <label class="block text-sm font-medium text-gray-700">Name for order:</label> <input name="customerName" [(ngModel)]="orderData.customerName" required minlength="2" #nameField="ngModel" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" placeholder="Enter your name" > <div *ngIf="nameField.invalid && nameField.touched" class="text-red-500 text-sm"> Please enter a name (minimum 2 characters) </div> </div> <div class="form-group"> <label>Takeout?</label> <div> <input type="checkbox" name="isTakeout" [(ngModel)]="orderData.isTakeout" > </div> </div> <!-- Debug info during development --> <div class="mt-4 text-sm text-gray-500"> Form Valid: {{orderForm.valid}} <br> Form Values: {{orderData | json}} </div> </div> </form> </ng-template>
|   |   --- lunch-form.component.ts: import { Component, ViewChild, TemplateRef, OnInit, EventEmitter, Output } from '@angular/core'; import { NgForm } from '@angular/forms'; import { IxtDialogService } from 'src/components/ixt-dialog/ixt-dialog.service'; import { firstValueFrom } from 'rxjs'; interface LunchOrder { sandwich: string; side: string; drink: string; customerName: string; isTakeout: boolean; } @Component({ selector: 'app-lunch-form', templateUrl: './lunch-form.component.html', styleUrls: ['./lunch-form.component.scss'], }) export class LunchFormComponent implements OnInit { @Output() init = new EventEmitter<LunchFormComponent>(); @ViewChild('lunchOrderTemplate') lunchOrderTemplate!: TemplateRef<any>; @ViewChild('orderForm') orderForm!: NgForm; orderData: LunchOrder = { sandwich: '', side: '', drink: '', customerName: '', isTakeout: false }; constructor(private dialogService: IxtDialogService) { } ngOnInit(): void { this.init.emit(this); } private getFormData(): LunchOrder { return { sandwich: this.orderData.sandwich, // Bound to the "Sandwich" field side: this.orderData.side, // Bound to the "Side" field drink: this.orderData.drink, // Bound to the "Drink" field customerName: this.orderData.customerName, // Bound to the "Name for order" field isTakeout: this.orderData.isTakeout, // Bound to the "Takeout?" checkbox }; } private resetForm(): void { // Reset the form fields to default values this.orderData = { sandwich: '', side: '', drink: '', customerName: '', isTakeout: false, }; // Reset the form state if it exists if (this.orderForm) { this.orderForm.resetForm(this.orderData); } } public showLunchOrderDialog(): Promise<{ status: 'OK' | 'Cancel'; data?: LunchOrder }> { // Reset form data and state this.resetForm(); return new Promise((resolve) => { // this.dialogService.template('Lunch Order', this.lunchOrderTemplate, { // buttons: [ // { // text: 'Place Order', // action: () => { // if (this.orderForm?.valid) { // const formData = this.getFormData(); // Get the form data // resolve({ status: 'OK', data: formData }); // Resolve with structured success result // return formData; // Required by the dialogService to process the action // } else { // this.dialogService.warning('Please fill out all required fields'); // return false; // Prevent dialog from closing if validation fails // } // }, // close: true, // Ensure dialog closes // }, // { // text: 'Cancel', // action: () => { // resolve({ status: 'Cancel' }); // Resolve with cancel status // }, // close: true, // Ensure dialog closes // }, // ], // }).subscribe({ // complete: () => { // console.log('Dialog closed'); // Ensure the dialog completes properly // }, // }); }); } }
|   +-- assets
|   |   --- .gitkeep: <empty file>
|   |   --- logo.png: <image file>
|   |   --- logo2.png: <image file>
|   +-- components
|   |   +-- ixt-colorpalette
|   |   |   --- ixt-canvas.component.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   --- ixt-canvas.component.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   +-- ixt-dialog
|   |   |   +-- types
|   |   |   |   +-- color
|   |   |   |   |   --- ixt-color.dialog.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   |   --- ixt-color.dialog.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   +-- confirm
|   |   |   |   |   --- ixt-confirm.dialog.html: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   |   --- ixt-confirm.dialog.ts: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   +-- error
|   |   |   |   |   --- ixt-error.dialog.html: // ixt-error-template.ts export const ERROR_TEMPLATE = ` <div role="alert"> <p>{{message}}</p> </div> `;
|   |   |   |   |   --- ixt-error.dialog.ts: // ixt-error-template.ts export const ERROR_TEMPLATE = ` <div role="alert"> <p>{{message}}</p> </div> `;
|   |   |   |   +-- font
|   |   |   |   |   --- ixt-font.dialog.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   |   --- ixt-font.dialog.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   +-- form
|   |   |   |   |   --- ixt-form.dialog.html: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   |   --- ixt-form.dialog.ts: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   +-- info
|   |   |   |   |   --- ixt-confirm.dialog.html: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   |   --- ixt-confirm.dialog.ts: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   |   --- ixt-info-template.component.ts: // ixt-info-template.component.ts import { Component, Input } from '@angular/core'; @Component({ template: ` <div role="status"> <p>{{message}}</p> </div> `, standalone: true }) export class InfoTemplateComponent { @Input() message!: string; }
|   |   |   |   +-- prompt
|   |   |   |   |   --- ixt-prompt.dialog.html: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   |   --- ixt-prompt.dialog.ts: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   +-- success
|   |   |   |   |   --- ixt-success-dialog.component.html: <div role="alert"> <p>{{ message || 'Operation completed successfully!' }}</p> </div>
|   |   |   |   |   --- ixt-success-dialog.component.ts: // ixt-success-dialog.component.ts import { Component, Input } from '@angular/core'; import { baseThemeColors } from 'src/components/theme/theme.colors'; import { ThemeVariant, ThemeColors } from 'src/components/theme/theme.types'; @Component({ selector: 'ixt-success-dialog', templateUrl: './ixt-success-dialog.component.html', styleUrls: ['./ixt-success-dialog.component.scss'] }) export class SuccessDialogComponent { @Input() message?: string; @Input() variant: ThemeVariant = 'success'; @Input() theme: ThemeColors = baseThemeColors; get themeStyles() { const colors = this.theme[this.variant]; return { 'background-color': `${colors.base}15`, // 15% opacity 'color': '#0f0', //colors.base, 'border-color': colors.base }; } }
|   |   |   |   \-- warn
|   |   |   |       --- ixt-warn.dialog.html: // ixt-warn-template.ts export const WARN_TEMPLATE = ` <div role="alert"> <p>{{message}}</p> </div> `;
|   |   |   |       --- ixt-warn.dialog.ts: // ixt-warn-template.ts export const WARN_TEMPLATE = ` <div role="alert"> <p>{{message}}</p> </div> `;
|   |   |   |       --- ixt-warn.scss.ts: // ixt-warn-template.ts export const WARN_TEMPLATE = ` <div role="alert"> <p>{{message}}</p> </div> `;
|   |   |   --- ixt-dialog.component.html: <dialog #dialog role="dialog" [ngStyle]="themeStyles"> <div role="document"> <header> <h2>{{ title }}</h2> </header> <section> <ng-template #contentHost></ng-template> </section> <footer> <button type="button" (click)="closeDialog(false)">Cancel</button> <button type="button" (click)="closeDialog(true)">OK</button> </footer> </div> </dialog>
|   |   |   --- ixt-dialog.component.ts: import { Component, ViewChild, ElementRef, Input, Output, EventEmitter, ViewContainerRef, ComponentFactoryResolver, Type, AfterViewInit } from '@angular/core'; import { baseThemeColors } from './../theme/theme.colors'; import { ThemeVariant, ThemeColors } from './../theme/theme.types'; @Component({ selector: 'ixt-dialog', templateUrl: './ixt-dialog.component.html', styleUrls: ['./ixt-dialog.component.scss'] }) export class IxtDialogComponent { @ViewChild('dialog') public dialog!: ElementRef<HTMLDialogElement>; @ViewChild('contentHost', { read: ViewContainerRef, static: true }) contentHost!: ViewContainerRef; @Input() modal: boolean = true; @Input() title: string = ''; @Input() variant: ThemeVariant = 'primary'; @Input() theme: ThemeColors = baseThemeColors; @Output() close = new EventEmitter<boolean>(); constructor() {} open() { if (this.modal) { this.dialog.nativeElement.showModal(); } else { this.dialog.nativeElement.show(); } } closeDialog(result: boolean) { this.dialog.nativeElement.close(); this.close.emit(result); } get themeStyles() { const colors = this.theme[this.variant]; return { 'background-color': colors.base, 'color': colors.text, '--theme-hover': colors.hover, '--theme-active': colors.active, '--theme-text': colors.text }; } }
|   |   |   --- ixt-dialog.index.ts: export * from './ixt-dialog.module'; export { IxtDialogComponent } from './ixt-dialog.component'; export { IxtDialogService } from './ixt-dialog.service';
|   |   |   --- ixt-dialog.module.ts: // ixt-dialog.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { MatButtonModule } from '@angular/material/button'; import { MatIconModule } from '@angular/material/icon'; import { IxtDialogComponent } from './ixt-dialog.component'; import { IxtDialogService } from './ixt-dialog.service'; // Add this import { FormsModule } from '@angular/forms'; import { SuccessDialogComponent } from './types/success/ixt-success-dialog.component'; @NgModule({ declarations: [ IxtDialogComponent, SuccessDialogComponent // Add this ], imports: [ CommonModule, MatButtonModule, MatIconModule, FormsModule ], exports: [IxtDialogComponent], providers: [IxtDialogService] // Add this }) export class IxtDialogModule { }
|   |   |   --- ixt-dialog.service.ts: // ixt-dialog.service.ts import { ApplicationRef, ComponentFactoryResolver, ComponentRef, Injectable, Injector, Type, createComponent } from '@angular/core'; import { IxtDialogComponent } from './ixt-dialog.component'; import { firstValueFrom } from 'rxjs'; import { SuccessDialogComponent } from './types/success/ixt-success-dialog.component'; @Injectable({ providedIn: 'root' }) export class IxtDialogService { private dialogComponentRef!: ComponentRef<IxtDialogComponent>; constructor( private componentFactoryResolver: ComponentFactoryResolver, private appRef: ApplicationRef, private injector: Injector ) { } // async openDialog(component: Type<any>, title: string, message: string, modal: boolean = true): Promise<boolean> { // this.dialogComponentRef = this.componentFactoryResolver // .resolveComponentFactory(IxtDialogComponent) // .create(this.injector); // const instance = this.dialogComponentRef.instance; // instance.title = title; // instance.modal = modal; // this.appRef.attachView(this.dialogComponentRef.hostView); // const domElem = (this.dialogComponentRef.hostView as any).rootNodes[0]; // document.body.appendChild(domElem); // // Allow time for component initialization // await new Promise(resolve => requestAnimationFrame(resolve)); // // Just create once and set message // const contentComponent = instance.contentHost.createComponent(component); // contentComponent.instance.message = message; // instance.open(); // // Wait for dialog result // const result = await firstValueFrom(instance.close); // document.body.removeChild(domElem); // this.appRef.detachView(this.dialogComponentRef.hostView); // this.dialogComponentRef.destroy(); // return result; // } async openDialog(component: Type<any>, title: string, message: string, modal: boolean = true): Promise<boolean> { this.dialogComponentRef = this.componentFactoryResolver .resolveComponentFactory(IxtDialogComponent) .create(this.injector); const instance = this.dialogComponentRef.instance; instance.title = title; instance.modal = modal; this.appRef.attachView(this.dialogComponentRef.hostView); const domElem = (this.dialogComponentRef.hostView as any).rootNodes[0]; document.body.appendChild(domElem); // Ensure ViewContainerRef is ready await new Promise(resolve => requestAnimationFrame(resolve)); // Clear any existing content instance.contentHost.clear(); // Create the component in the ViewContainerRef const contentComponentRef = instance.contentHost.createComponent(component); contentComponentRef.instance.message = message; instance.open(); const result = await firstValueFrom(instance.close); document.body.removeChild(domElem); this.appRef.detachView(this.dialogComponentRef.hostView); this.dialogComponentRef.destroy(); return result; } // async openDialog(component: Type<any>, title: string, message: string, modal: boolean = true): Promise<boolean> { // // Dynamically create the dialog component // this.dialogComponentRef = this.componentFactoryResolver // .resolveComponentFactory(IxtDialogComponent) // .create(this.injector); // // Attach the component to the view // this.appRef.attachView(this.dialogComponentRef.hostView); // // Append the component to the DOM // const componentElement = (this.dialogComponentRef.hostView as any).rootNodes[0]; // document.body.appendChild(componentElement); // // Set inputs on the dialog component // const instance = this.dialogComponentRef.instance; // instance.title = title; // instance.message = message; // Set message input // instance.modal = modal; // // Open the dialog // instance.open(); // // Return a promise that resolves when the dialog emits `close` // return firstValueFrom(instance.close); // } closeDialog(result: boolean): void { if (this.dialogComponentRef) { this.dialogComponentRef.instance.closeDialog(result); } } // async success(message: string, title: string): Promise<boolean> { // return await this.openDialog(SuccessDialogComponent, title, true); // } // async success(message: string, title: string): Promise<boolean> { // const dialogRef = this.componentFactoryResolver // .resolveComponentFactory(SuccessDialogComponent) // .create(this.injector); // // Set the message before creating dialog // dialogRef.instance.message = message; // return await this.openDialog(SuccessDialogComponent, message, title, true); // } async success(message: string, title: string): Promise<boolean> { return await this.openDialog(SuccessDialogComponent, title, message, true); } }
|   |   +-- ixt-table
|   |   |   +-- editors
|   |   |   |   +-- airport-code
|   |   |   |   |   --- airport-code-editor.component.ts: import { Component, Input, forwardRef, OnInit, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { IxtDialogService } from '../../../ixt-dialog/ixt-dialog.service'; import { MatrixEditor, MatrixEditorConfig } from '../editor.interface'; @Component({ selector: 'airport-code-editor', template: ` <div class="editor-container"> <input type="text" [formControl]="inputControl" class="w-24 px-2 py-1 border rounded" [class.border-red-500]="hasError" [attr.maxlength]="config?.['maxLength'] || 3" (blur)="onTouched()" /> <div *ngIf="hasError" class="text-red-500 text-sm mt-1"> {{ errorMessage }} </div> </div> `, styles: [` .editor-container { position: relative; } `], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AirportCodeEditorComponent), multi: true } ] }) export class AirportCodeEditorComponent implements ControlValueAccessor, OnInit, MatrixEditor { @Input() config?: MatrixEditorConfig; @Input() existingCodes: string[] = []; @Input() field: string = 'code'; inputControl = new FormControl(''); hasError = false; errorMessage = ''; // MatrixEditor implementation component: Type<any> = AirportCodeEditorComponent; // ControlValueAccessor implementations public onChanged: (value: string) => void = () => {}; public onTouched: () => void = () => {}; constructor(private dialogService: IxtDialogService) {} ngOnInit() { this.setupValueChanges(); } // MatrixEditor methods getEditConfig(): MatrixEditorConfig { return { existingValues: this.existingCodes, maxLength: 3, pattern: /^[A-Z]+$/ }; } getDefaultValue(): string { return ''; } validate(value: any): boolean { if (!value) return false; const code = String(value).toUpperCase(); if (code.length !== 3) return false; if (!/^[A-Z]+$/.test(code)) return false; if (this.existingCodes.includes(code)) return false; return true; } format(value: any): string { return value ? String(value).toUpperCase() : ''; } private async setupValueChanges() { this.inputControl.valueChanges.subscribe(async value => { if (value !== null) { const upperValue = value.toUpperCase(); if (upperValue !== value) { this.inputControl.setValue(upperValue, { emitEvent: false }); } if (await this.validateValue(upperValue)) { console.log('Editor emitting code change:', upperValue); this.onChanged(upperValue); } } }); } private async validateValue(value: string): Promise<boolean> { this.hasError = false; this.errorMessage = ''; if (!value) return false; if (value.length !== (this.config?.['maxLength'] || 3)) { this.hasError = true; this.errorMessage = `Code must be exactly ${this.config?.['maxLength'] || 3} characters`; return false; } const pattern = this.config?.['pattern'] || /^[A-Z]+$/; if (!pattern.test(value)) { this.hasError = true; this.errorMessage = 'Only letters are allowed'; return false; } if (this.config?.existingValues?.includes(value)) { this.hasError = true; this.errorMessage = 'This code already exists'; // await this.dialogService.warning( // `The code "${value}" already exists. Please enter a different code.`, // 'Duplicate Code' // ); return false; } return true; } // ControlValueAccessor interface implementation writeValue(value: string): void { console.log('AirportCodeEditor writeValue:', value); this.inputControl.setValue(value, { emitEvent: false }); } registerOnChange(fn: (value: string) => void): void { console.log('AirportCodeEditor registerOnChange'); this.onChanged = fn; } registerOnTouched(fn: () => void): void { this.onTouched = fn; } setDisabledState(isDisabled: boolean): void { if (isDisabled) { this.inputControl.disable(); } else { this.inputControl.enable(); } } }
|   |   |   |   +-- binary-editor
|   |   |   |   |   --- binary-editor.component.ts: // src/components/ixt-matrix/matrix-editors/binary-editor/binary-editor.component.ts import { Component, Input, forwardRef, Output, EventEmitter, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { MatrixEditor, MatrixEditorConfig } from '../editor.interface'; interface BinaryConfig extends MatrixEditorConfig { trueValue?: any; falseValue?: any; trueDisplay?: string; falseDisplay?: string; rowData?: any; rowIndex?: number; } interface SelectionEvent { selected: boolean; rowData?: any; rowIndex?: number; } @Component({ selector: 'binary-editor', template: ` <div class="editor-container"> <input type="checkbox" [formControl]="inputControl" [checked]="isChecked" (change)="onCheckboxChange($event)" class="w-4 h-4 rounded border-gray-300" /> <span *ngIf="showLabel" class="ml-2"> {{ isChecked ? config.trueDisplay : config.falseDisplay }} </span> </div> `, providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => BinaryEditorComponent), multi: true } ] }) export class BinaryEditorComponent implements ControlValueAccessor, MatrixEditor { @Input() config: BinaryConfig = {}; @Output() selectionChange = new EventEmitter<SelectionEvent>(); inputControl = new FormControl<boolean | null>(false); component: Type<any> = BinaryEditorComponent; showLabel = false; isChecked = false; private onChange: (value: any) => void = () => { }; private onTouch: () => void = () => { }; constructor() { this.setupDefaults(); this.isChecked = false; } ngOnInit() { this.setupDefaults(); this.setupValueChanges(); } private setupDefaults() { this.config = { trueValue: true, falseValue: false, trueDisplay: 'True', falseDisplay: 'False', ...this.config }; } private setupValueChanges(): void { this.inputControl.valueChanges.subscribe((checked: boolean | null) => { if (checked !== null) { const value = checked ? this.config.trueValue : this.config.falseValue; this.isChecked = checked; this.onChange(value); this.selectionChange.emit({ selected: checked, rowData: this.config.rowData, rowIndex: this.config.rowIndex }); } }); } onCheckboxChange(event: Event) { const checkbox = event.target as HTMLInputElement; this.inputControl.setValue(checkbox.checked); this.onTouch(); } getEditConfig(): BinaryConfig { return { trueValue: this.config.trueValue || true, falseValue: this.config.falseValue || false, trueDisplay: this.config.trueDisplay || 'True', falseDisplay: this.config.falseDisplay || 'False' }; } writeValue(value: any): void { const checked = value === this.config.trueValue; this.isChecked = checked; this.inputControl.setValue(checked, { emitEvent: false }); } registerOnChange(fn: any): void { this.onChange = fn; } registerOnTouched(fn: any): void { this.onTouch = fn; } setDisabledState(isDisabled: boolean): void { if (isDisabled) { this.inputControl.disable(); } else { this.inputControl.enable(); } } }
|   |   |   |   +-- coordinate
|   |   |   |   |   --- coordinate-editor.component.ts: // src/components/ixt-matrix/matrix-editors/coordinate/coordinate-editor.component.ts import { Component, Input, forwardRef, OnInit, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { IxtDialogService } from '../../../ixt-dialog/ixt-dialog.service'; import { MatrixEditor, MatrixEditorConfig } from '../editor.interface'; @Component({ selector: 'coordinate-editor', template: ` <div class="editor-container"> <input type="number" step="any" [min]="config?.['type'] === 'lat' ? -90 : -180" [max]="config?.['type'] === 'lat' ? 90 : 180" [formControl]="inputControl" class="w-24 px-2 py-1 border rounded" [class.border-red-500]="hasError" [placeholder]="config?.['type'] === 'lat' ? '(-90 to 90)' : '(-180 to 180)'" (blur)="onBlur()" /> <div *ngIf="hasError" class="text-red-500 text-sm mt-1"> {{ errorMessage }} </div> </div>`, providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => CoordinateEditorComponent), multi: true } ] }) export class CoordinateEditorComponent implements ControlValueAccessor, OnInit, MatrixEditor { @Input() config?: MatrixEditorConfig; inputControl = new FormControl(''); hasError = false; errorMessage = ''; // MatrixEditor implementation component: Type<any> = CoordinateEditorComponent; private onChange: (value: number) => void = () => { }; private onTouch: () => void = () => { }; constructor(private dialogService: IxtDialogService) { } ngOnInit() { this.setupValueChanges(); } getEditConfig(): MatrixEditorConfig { return { type: this.config?.['type'] || 'lat' }; } validate(value: any): boolean { const num = Number(value); const isLat = this.config?.['type'] === 'lat'; return isLat ? (num >= -90 && num <= 90) : (num >= -180 && num <= 180); } // private setupValueChanges() { // this.inputControl.valueChanges.subscribe(value => { // if (value !== null) { // // Convert string to number for validation // const numValue = Number(value); // if (this.validateValue(numValue)) { // this.onChange(numValue); // } // } // }); // } setupValueChanges() { this.inputControl.valueChanges.subscribe(value => { if (value !== null) { const numValue = Number(value); if (!isNaN(numValue) && this.validateValue(numValue)) { this.onChange(numValue); } else { // Reset to last valid value or empty this.inputControl.setValue('', {emitEvent: false}); } } }); } private validateValue(value: number): boolean { this.hasError = false; this.errorMessage = ''; if (isNaN(value)) { this.hasError = true; this.errorMessage = 'Must be a valid number'; return false; } const isLat = this.config?.['type'] === 'lat'; const min = isLat ? -90 : -180; const max = isLat ? 90 : 180; if (value < min || value > max) { this.hasError = true; this.errorMessage = `Must be between ${min} and ${max}`; return false; } return true; } // ControlValueAccessor methods writeValue(value: number): void { this.inputControl.setValue(value?.toString() || '', { emitEvent: false }); } registerOnChange(fn: any): void { this.onChange = fn; } registerOnTouched(fn: any): void { this.onTouch = fn; } onBlur(): void { this.onTouch(); } }
|   |   |   |   --- DatePickerComponent.ts: // matrix-editors/date-picker.component.ts import { Component, Input, Output, EventEmitter } from '@angular/core'; @Component({ selector: 'ixt-date-picker', template: ` <input type="date" [value]="value | date:'yyyy-MM-dd'" (change)="onChange($event)" class="ixt-date-picker__input"> `, styles: [` .ixt-date-picker__input { width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 4px; } `] }) export class DatePickerComponent { @Input() value: Date | null = null; @Output() valueChange = new EventEmitter<Date>(); onChange(event: Event) { const value = (event.target as HTMLInputElement).value; this.valueChange.emit(new Date(value)); } }
|   |   |   |   --- color.editor.ts: <empty file>
|   |   |   |   --- date.editor.ts: import { Injectable } from "@angular/core"; import { MatrixEditor } from "./editor.interface"; import { formatDate } from "@angular/common"; import { DatePickerComponent } from "./DatePickerComponent"; // matrix-editors/date.editor.ts @Injectable() export class DateEditor implements MatrixEditor { component = DatePickerComponent; getEditConfig() { return { format: 'yyyy-MM-dd', showTimeSelect: false }; } format(value: Date): string { return formatDate(value, 'shortDate', 'en-US'); } }
|   |   |   |   --- editor.interface.ts: import { Type } from "@angular/core"; export interface MatrixEditorConfig { existingValues?: any[]; validators?: any[]; field?: string; [key: string]: any; } export interface MatrixEditor { component: Type<any>; getEditConfig(): any; validate?(value: any): boolean; format?(value: any): string; getDefaultValue?(): any; }
|   |   |   +-- services
|   |   |   |   +-- edit
|   |   |   |   |   --- edit.model.ts: // src/components/ixt-matrix/services/edit/edit.model.ts import { FormControl } from '@angular/forms'; export interface RowChanges { [key: string]: any; } export interface EditState { editingRows: Set<number>; newRows: any[]; rowChanges: Map<number, RowChanges>; editControls: Map<string, FormControl>; } export interface EditEvent { rowIndex: number; field: string; value: any; }
|   |   |   |   |   --- edit.service.ts: // src/components/ixt-matrix/services/edit/edit.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { FormControl } from '@angular/forms'; import { EditState, RowChanges, EditEvent } from './edit.model'; import { ColumnConfig } from '../../ixt-table.interfaces'; @Injectable({ providedIn: 'root' }) export class EditService { private readonly initialState: EditState = { editingRows: new Set<number>(), newRows: [], rowChanges: new Map<number, RowChanges>(), editControls: new Map<string, FormControl>() }; private state = new BehaviorSubject<EditState>(this.initialState); public state$ = this.state.asObservable(); private getDefaultValueForType(type: string | any): any { switch (type) { case 'number': return 0; case 'enum': return ''; case 'text': default: return ''; } } public addNewRow(columnConfigs: Record<string, ColumnConfig>): void { const newRow: any = {}; if (columnConfigs) { Object.entries(columnConfigs).forEach(([field, config]) => { newRow[field] = this.getDefaultValueForType(config.type); }); } const currentState = this.state.getValue(); const newRows = [...currentState.newRows]; newRows.unshift(newRow); // Start editing the new row const editingRows = new Set(currentState.editingRows); editingRows.add(-newRows.length); this.state.next({ ...currentState, newRows, editingRows }); } public startEditing(rowIndex: number): void { const currentState = this.state.getValue(); const editingRows = new Set(currentState.editingRows); editingRows.add(rowIndex); this.state.next({ ...currentState, editingRows }); } public cancelEditing(rowIndex: number): void { const currentState = this.state.getValue(); const editingRows = new Set(currentState.editingRows); const rowChanges = new Map(currentState.rowChanges); editingRows.delete(rowIndex); rowChanges.delete(rowIndex); this.state.next({ ...currentState, editingRows, rowChanges }); } public onValueChange(event: EditEvent): void { const { rowIndex, field, value } = event; const currentState = this.state.getValue(); const rowChanges = new Map(currentState.rowChanges); let changes = rowChanges.get(rowIndex) || {}; changes = { ...changes, [field]: value }; rowChanges.set(rowIndex, changes); this.state.next({ ...currentState, rowChanges }); } public getEditControl(rowIndex: number, field: string): FormControl { const key = `${rowIndex}-${field}`; const currentState = this.state.getValue(); let control = currentState.editControls.get(key); if (!control) { control = new FormControl(''); const editControls = new Map(currentState.editControls); editControls.set(key, control); this.state.next({ ...currentState, editControls }); } return control; } public saveChanges(data: any[]): any[] { const currentState = this.state.getValue(); const updatedData = [...data]; // Apply changes to existing rows currentState.rowChanges.forEach((changes, rowIndex) => { if (rowIndex >= 0) { updatedData[rowIndex] = { ...updatedData[rowIndex], ...changes }; } }); // Add new rows if (currentState.newRows.length) { // Apply any changes to new rows const processedNewRows = currentState.newRows.map((row, index) => { const changes = currentState.rowChanges.get(-index - 1); return changes ? { ...row, ...changes } : row; }); updatedData.unshift(...processedNewRows); } // Reset state this.state.next(this.initialState); return updatedData; } public isNewRow(index: number): boolean { return index < this.state.getValue().newRows.length; } public isEditing(rowIndex: number): boolean { return this.state.getValue().editingRows.has(rowIndex); } public hasChanges(): boolean { const currentState = this.state.getValue(); return currentState.rowChanges.size > 0 || currentState.newRows.length > 0; } public getNewRows(): any[] { return this.state.getValue().newRows; } public getRowChanges(rowIndex: number): RowChanges | undefined { return this.state.getValue().rowChanges.get(rowIndex); } public getRowIndex(displayIndex: number): number { return displayIndex - this.state.getValue().newRows.length; } public clearEditing(): void { this.state.next(this.initialState); } }
|   |   |   |   +-- filter
|   |   |   |   |   --- filter.model.ts: // src/components/ixt-matrix/services/filter/filter.model.ts import { FormControl } from '@angular/forms'; export type FilterOperator = 'equals' | 'startsWith' | 'contains' | 'between' | '>' | '<' | '>=' | '<=' | '!='; export interface FilterState { field: string; operator: FilterOperator; value: any; secondaryValue?: any; } export interface FilterControls { value: FormControl; operator?: FormControl<string>; }
|   |   |   |   |   --- filter.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; import { FormControl } from '@angular/forms'; import { FilterState, FilterOperator, FilterControls } from './filter.model'; import { ColumnConfig } from '../../ixt-table.interfaces'; @Injectable({ providedIn: 'root' }) export class FilterService { private activeFilters = new Map<string, FilterState>(); private filterControls = new Map<string, FilterControls>(); private activeFilterColumn?: string; private showFilters = false; private filtersChanged = new BehaviorSubject<Map<string, FilterState>>(new Map()); public filtersChanged$ = this.filtersChanged.asObservable(); public initializeFilter(field: string, config: ColumnConfig): void { const controls: FilterControls = { value: new FormControl('') }; if (config.type === 'number') { // Fix: Explicitly type the FormControl controls.operator = new FormControl<string>('=', { nonNullable: true }); } this.filterControls.set(field, controls); } public getFilterControl(field: string): FormControl | undefined { return this.filterControls.get(field)?.value; } public getOperatorControl(field: string): FormControl<string> | undefined { return this.filterControls.get(field)?.operator; } public onFilterChange(field: string, value: any, config?: ColumnConfig): void { if (value || value === 0) { const defaultOperator: FilterOperator = config?.type === 'number' ? 'equals' : 'contains'; const operator = this.getOperatorControl(field)?.value || defaultOperator; this.activeFilters.set(field, { field, operator: operator as FilterOperator, value: config?.type === 'number' ? Number(value) : value }); } else { this.activeFilters.delete(field); } this.filtersChanged.next(this.activeFilters); } public onOperatorChange(field: string): void { const currentValue = this.getFilterControl(field)?.value; if (currentValue || currentValue === 0) { this.onFilterChange(field, currentValue); } } public clearAllFilters(): void { this.activeFilters.clear(); this.filterControls.forEach(controls => { controls.value.reset(); controls.operator?.reset('='); }); this.filtersChanged.next(this.activeFilters); } public toggleFilters(column: string): void { if (this.activeFilterColumn === column) { this.activeFilterColumn = undefined; this.showFilters = false; } else { this.activeFilterColumn = column; this.showFilters = true; } } public matchesFilter(item: any, filter: FilterState): boolean { if (item === undefined || item === null) return false; // Handle numeric comparisons if (typeof item === 'number' || !isNaN(Number(item))) { const numValue = Number(item); const numFilterValue = Number(filter.value); return this.handleNumericComparison(numValue, numFilterValue, filter.operator); } // String handling const itemValue = String(item).toLowerCase(); const filterValue = String(filter.value).toLowerCase(); switch (filter.operator) { case 'startsWith': return itemValue.startsWith(filterValue); case 'equals': return itemValue === filterValue; case '!=': return itemValue !== filterValue; default: return itemValue.includes(filterValue); } } private handleNumericComparison(numValue: number, numFilterValue: number, operator: FilterOperator): boolean { switch (operator) { case '>': return numValue > numFilterValue; case '<': return numValue < numFilterValue; case '>=': return numValue >= numFilterValue; case '<=': return numValue <= numFilterValue; case '!=': return numValue !== numFilterValue; case 'equals': return numValue === numFilterValue; default: return false; } } public get isShowingFilters(): boolean { return this.showFilters; } public get activeColumn(): string | undefined { return this.activeFilterColumn; } public getActiveFilters(): Map<string, FilterState> { return this.activeFilters; } public hasActiveFilters(): boolean { return this.activeFilters.size > 0; } }
|   |   |   |   +-- selection
|   |   |   |   |   --- selection.model.ts: // src/components/ixt-matrix/services/selection/selection.model.ts export interface SelectionState { selectedRows: Set<number>; allSelected: boolean; }
|   |   |   |   |   --- selection.service.ts: // src/components/ixt-matrix/services/selection/selection.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { SelectionState } from './selection.model'; @Injectable({ providedIn: 'root' }) export class SelectionService { private state = new BehaviorSubject<SelectionState>({ selectedRows: new Set<number>(), allSelected: false }); public state$ = this.state.asObservable(); public selectRow(index: number, selected: boolean = true): void { const currentState = this.state.getValue(); const newSelectedRows = new Set(currentState.selectedRows); if (selected) { newSelectedRows.add(index); } else { newSelectedRows.delete(index); } this.state.next({ selectedRows: newSelectedRows, allSelected: currentState.allSelected }); } public toggleAllRows(selected: boolean, totalRows: number): void { const newSelectedRows = new Set<number>(); if (selected) { // Add all row indices for (let i = 0; i < totalRows; i++) { newSelectedRows.add(i); } } this.state.next({ selectedRows: newSelectedRows, allSelected: selected }); } public clearSelection(): void { this.state.next({ selectedRows: new Set<number>(), allSelected: false }); } public getSelectedRows(): Set<number> { return this.state.getValue().selectedRows; } public isSelected(index: number): boolean { return this.state.getValue().selectedRows.has(index); } public isAllSelected(): boolean { return this.state.getValue().allSelected; } public getSelectedCount(): number { return this.state.getValue().selectedRows.size; } public setSelectedRows(indices: number[]): void { const newSelectedRows = new Set(indices); this.state.next({ selectedRows: newSelectedRows, allSelected: false // Reset all selected state when manually setting rows }); } public isPartiallySelected(totalRows: number): boolean { const selectedCount = this.getSelectedCount(); return selectedCount > 0 && selectedCount < totalRows; } }
|   |   |   |   +-- sort
|   |   |   |   |   --- sort.model.ts: // src/components/ixt-matrix/services/sort/sort.model.ts export type SortDirection = 'asc' | 'desc' | null; export interface SortState { column: string | null; direction: SortDirection; }
|   |   |   |   |   --- sort.service.ts: // src/components/ixt-matrix/services/sort/sort.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { SortState, SortDirection } from './sort.model'; @Injectable({ providedIn: 'root' }) export class SortService { private readonly initialState: SortState = { column: null, direction: null }; private state = new BehaviorSubject<SortState>(this.initialState); public state$ = this.state.asObservable(); public toggleSort(column: string): void { const currentState = this.state.getValue(); let newDirection: SortDirection = null; if (currentState.column === column) { // Cycle through: null -> asc -> desc -> null if (currentState.direction === null) { newDirection = 'asc'; } else if (currentState.direction === 'asc') { newDirection = 'desc'; } else { newDirection = null; } } else { // New column, start with ascending newDirection = 'asc'; } this.state.next({ column: newDirection ? column : null, direction: newDirection }); } public getSortIcon(column: string): string { const { column: sortColumn, direction } = this.state.getValue(); if (sortColumn !== column) { return 'unfold_more'; } return direction === 'asc' ? 'arrow_upward' : 'arrow_downward'; } public sortData<T>(data: T[]): T[] { const { column, direction } = this.state.getValue(); if (!column || !direction) { return data; } return [...data].sort((a, b) => { const aVal = a[column as keyof T]; const bVal = b[column as keyof T]; if (aVal == null) return 1; if (bVal == null) return -1; let comparison: number; if (typeof aVal === 'string') { comparison = String(aVal).toLowerCase().localeCompare(String(bVal).toLowerCase()); } else { comparison = aVal < bVal ? -1 : (aVal > bVal ? 1 : 0); } return direction === 'asc' ? comparison : -comparison; }); } public clearSort(): void { this.state.next(this.initialState); } public getCurrentSort(): SortState { return this.state.getValue(); } public isColumnSorted(column: string): boolean { return this.state.getValue().column === column; } public getSortDirection(column: string): SortDirection { const { column: sortColumn, direction } = this.state.getValue(); return sortColumn === column ? direction : null; } }
|   |   |   |   --- pagination.model.ts: // src/components/ixt-matrix/services/pagination/pagination.model.ts export interface PaginationState { currentPage: number; pageSize: number | 'all'; totalItems: number; } export interface PageSize { value: number | 'all'; label: string; }
|   |   |   |   --- pagination.service.ts: // src/components/ixt-matrix/services/pagination/pagination.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; import { PageSize, PaginationState } from './pagination.model'; @Injectable({ providedIn: 'root' }) export class PaginationService { private readonly DEFAULT_PAGE_SIZES: PageSize[] = [ { value: 10, label: '10' }, { value: 100, label: '100' }, { value: 'all', label: 'All' } ]; private readonly MINIMUM_ROWS_FOR_PAGINATION = 50; private state = new BehaviorSubject<PaginationState>({ currentPage: 1, pageSize: 10, totalItems: 0 }); public state$ = this.state.asObservable(); public initialize(totalItems: number): void { this.updateState({ currentPage: 1, pageSize: 10, totalItems }); } public shouldShowPagination(): boolean { return this.state.getValue().totalItems > this.MINIMUM_ROWS_FOR_PAGINATION; } public getCurrentPage(): number { return this.state.getValue().currentPage; } public getPageSize(): number | 'all' { return this.state.getValue().pageSize; } public getPageSizes(): PageSize[] { return this.DEFAULT_PAGE_SIZES; } public getTotalPages(): number { const { totalItems, pageSize } = this.state.getValue(); if (pageSize === 'all' || totalItems <= this.MINIMUM_ROWS_FOR_PAGINATION) { return 1; } return Math.ceil(totalItems / +pageSize); } public getVisiblePages(): number[] { const totalPages = this.getTotalPages(); const currentPage = this.getCurrentPage(); if (totalPages <= 1) return []; const pages: number[] = [1]; const WINDOW_SIZE = 4; let start = Math.max(2, currentPage - WINDOW_SIZE); let end = Math.min(totalPages - 1, currentPage + WINDOW_SIZE); if (start > 2) { pages.push(-1); } for (let i = start; i <= end; i++) { pages.push(i); } if (end < totalPages - 1) { pages.push(-1); } if (totalPages > 1) { pages.push(totalPages); } return pages; } public onPageChange(page: number): void { const totalPages = this.getTotalPages(); if (page >= 1 && page <= totalPages) { this.updateState({ ...this.state.getValue(), currentPage: page }); } } public onPageSizeChange(newSize: number | 'all'): void { this.updateState({ ...this.state.getValue(), pageSize: newSize, currentPage: 1 }); } public getPaginatedData<T>(data: T[]): T[] { const { pageSize, currentPage } = this.state.getValue(); if (pageSize === 'all' || data.length <= this.MINIMUM_ROWS_FOR_PAGINATION) { return data; } const start = (currentPage - 1) * (+pageSize); const end = start + (+pageSize); return data.slice(start, end); } private updateState(newState: Partial<PaginationState>): void { this.state.next({ ...this.state.getValue(), ...newState }); } }
|   |   |   --- ixt-table.component.html: <div class="ixt-table__toolbar"> <button class="ixt-table__action-button" (click)="addNewRow()"> <span class="material-icons">add</span> </button> <button class="ixt-table__action-button" [disabled]="!hasChanges && newRowsLength === 0" (click)="saveChanges()"> <span class="material-icons">save</span> </button> </div> <ng-container *ngIf="hasData; else noData"> <div class="ixt-table"> <!-- Header --> <div class="ixt-table__header"> <div class="ixt-table__cell"> <binary-editor [config]="{ rowIndex: -1 }" [(ngModel)]="allSelected" (selectionChange)="toggleAllRows($event.selected)"> </binary-editor> </div> <div class="ixt-table__cell" *ngFor="let col of columns" [class.ixt-table__cell--first]="col === columns[0]"> <div class="ixt-table__cell-content"> {{columnConfigs?.[col]?.label || col}} <div class="ixt-table__cell-actions"> <button class="ixt-table__sort-toggle" (click)="toggleSort(col)"> <span class="material-icons">{{getSortIcon(col)}}</span> </button> <button class="ixt-table__filter-toggle" (click)="toggleFilters(col)"> <span class="material-icons">filter_alt</span> </button> </div> </div> </div> <div class="ixt-table__cell">Actions</div> </div> <!-- Filter Row --> <div class="ixt-table__header" *ngIf="showFilters"> <div class="ixt-table__cell"></div> <div class="ixt-table__cell" *ngFor="let col of columns" [class.ixt-table__cell--first]="col === columns[0]"> <ng-container *ngIf="activeFilterColumn === col && columnConfigs?.[col]"> <ng-container [ngSwitch]="getEditorType(columnConfigs?.[col]?.type)"> <!-- Text Filter --> <input *ngSwitchCase="'text'" [formControl]="getFilterControl(col)" [placeholder]="columnConfigs?.[col]?.placeholder || ''" class="ixt-table__filter-input"> <!-- Number Filter --> <div *ngSwitchCase="'number'" class="ixt-table__number-filter"> <select [formControl]="getOperatorControl(col)" (change)="onOperatorChange(col)"> <option value="=">=</option> <option value=">">&gt;</option> <option value="<">&lt;</option> <option value=">=">&gt;=</option> <option value="<=">&lt;=</option> <option value="!=">!=</option> </select> <input type="number" [formControl]="getFilterControl(col)" [placeholder]="columnConfigs?.[col]?.placeholder || ''" class="ixt-table__filter-input"> </div> <!-- Enum Filter --> <div *ngSwitchCase="'enum'"> <select [formControl]="getFilterControl(col)" class="ixt-table__filter-input"> <option value="">All</option> <option *ngFor="let opt of columnConfigs?.[col]?.enumValues" [value]="opt.value"> {{opt.label}} </option> </select> </div> </ng-container> </ng-container> </div> <div class="ixt-table__cell"></div> </div> <!-- Data Rows --> <div class="ixt-table__row" *ngFor="let row of paginatedData; let i = index" [class.ixt-table__row--selected]="isRowSelected(getRowIndex(i))"> <div class="ixt-table__cell"> <binary-editor [config]="{ rowIndex: getRowIndex(i), rowData: row }" [ngModel]="isRowSelected(getRowIndex(i))" (selectionChange)="selectRow(getRowIndex(i), $event.selected)"> </binary-editor> </div> <div class="ixt-table__cell" *ngFor="let col of columns" [class.ixt-table__cell--first]="col === columns[0]"> <ng-container *ngIf="isNewRow(i) || isEditing(getRowIndex(i)); else displayValue"> <ng-container [ngSwitch]="getEditorType(columnConfigs?.[col]?.type)"> <!-- Text Input --> <input *ngSwitchCase="'text'" type="text" [ngModel]="row[col]" (ngModelChange)="onValueChange(getRowIndex(i), col, $event)"> <!-- Number Input --> <input *ngSwitchCase="'number'" type="number" [ngModel]="row[col]" (ngModelChange)="onValueChange(getRowIndex(i), col, $event)"> <!-- Enum Select --> <select *ngSwitchCase="'enum'" [ngModel]="row[col]" (ngModelChange)="onValueChange(getRowIndex(i), col, $event)"> <option *ngFor="let opt of columnConfigs?.[col]?.enumValues" [ngValue]="opt.value"> {{opt.label}} </option> </select> <!-- Custom Editor --> <ng-container *ngSwitchCase="'custom'"> <ng-container *ngTemplateOutlet="customEditorTpl; context: { $implicit: getEditorComponent(columnConfigs?.[col]?.type), row: row, col: col, index: i, control: getEditControl(getRowIndex(i), col) }"> </ng-container> </ng-container> </ng-container> </ng-container> <ng-template #displayValue> <ng-container [ngSwitch]="columnConfigs?.[col]?.type"> <ng-container *ngSwitchCase="CoordinateEditorComponent"> {{formatCoordinate(row[col])}} </ng-container> <ng-container *ngSwitchDefault> {{row[col]}} </ng-container> </ng-container> </ng-template> </div> <div class="ixt-table__cell"> <ng-container *ngIf="!isNewRow(i) && !isEditing(getRowIndex(i))"> <button class="ixt-table__action-button" (click)="startEditing(getRowIndex(i))"> <span class="material-icons">edit</span> </button> </ng-container> <ng-container *ngIf="isNewRow(i) || isEditing(getRowIndex(i))"> <button class="ixt-table__action-button" (click)="cancelEditing(getRowIndex(i))"> <span class="material-icons">close</span> </button> </ng-container> </div> </div> <!-- Pagination --> <div class="ixt-table__footer" *ngIf="showPagination"> <div class="ixt-table__pagination"> <div class="ixt-table__page-size"> <select [formControl]="pageSizeControl"> <option *ngFor="let size of pageSizes" [value]="size.value"> {{size.label}} </option> </select> rows per page </div> <div class="ixt-table__controls"> <button (click)="onPageChange(1)" [disabled]="currentPage === 1"> <span class="material-icons">first_page</span> </button> <button (click)="onPageChange(currentPage - 1)" [disabled]="currentPage === 1"> <span class="material-icons">chevron_left</span> </button> <button *ngFor="let page of visiblePages" [class.active]="page === currentPage" [class.ellipsis]="page === -1" [disabled]="page === -1" (click)="onPageChange(page)"> {{page === -1 ? '...' : page}} </button> <button (click)="onPageChange(currentPage + 1)" [disabled]="currentPage === totalPages"> <span class="material-icons">chevron_right</span> </button> <button (click)="onPageChange(totalPages)" [disabled]="currentPage === totalPages"> <span class="material-icons">last_page</span> </button> </div> </div> </div> </div> </ng-container> <!-- Custom Editor Template --> <ng-template #customEditorTpl let-editor let-row="row" let-col="col" let-index="index" let-control="control"> <coordinate-editor *ngIf="editor?.component === CoordinateEditorComponent" [formControl]="control" [config]="{ type: col === 'lat' ? 'lat' : 'lon' }"> </coordinate-editor> <airport-code-editor *ngIf="editor?.component === AirportCodeEditorComponent" [formControl]="control" [config]="editor.getEditConfig()" [existingCodes]="getCodes(data)"> </airport-code-editor> </ng-template> <!-- No Data Template --> <ng-template #noData> <div class="ixt-table__empty"> No data available </div> </ng-template>
|   |   |   --- ixt-table.component.ts: import { ChangeDetectorRef, Component, Input, OnInit, TemplateRef, ViewChild, Type } from '@angular/core'; import { FormControl } from '@angular/forms'; import { ColumnConfig, FilterOperator, FilterState, MatrixNode, PageSize, RowChanges } from './ixt-table.interfaces'; import { debounceTime, distinctUntilChanged } from 'rxjs/operators'; import { IxtDialogService } from '../ixt-dialog/ixt-dialog.index'; import { PaginationService } from './services/pagination.service'; import { FilterService } from './services/filter/filter.service'; import { SortService } from './services/sort/sort.service'; import { SelectionService } from './services/selection/selection.service'; import { EditService } from './services/edit/edit.service'; import { MatrixEditor } from './editors/editor.interface'; import { AirportCodeEditorComponent, CoordinateEditorComponent } from './ixt-table.index'; export type SortDirection = 'asc' | 'desc' | null; @Component({ selector: 'ixt-table', templateUrl: './ixt-table.component.html', styleUrls: ['./ixt-table.component.scss'] }) export class IxtTableComponent implements OnInit { @Input() data: MatrixNode[] = []; @Input() columnConfigs?: Record<string, ColumnConfig>; @ViewChild('noData') noDataTemplate!: TemplateRef<any>; @ViewChild('customEditorTpl') customEditorTpl!: TemplateRef<any>; columns: string[] = []; pageSizeControl = new FormControl<number | 'all'>(10); readonly AirportCodeEditorComponent = AirportCodeEditorComponent; readonly CoordinateEditorComponent = CoordinateEditorComponent; constructor( private dialogService: IxtDialogService, private changeDetectorRef: ChangeDetectorRef, private paginationService: PaginationService, private filterService: FilterService, private sortService: SortService, private selectionService: SelectionService, private editService: EditService ) { } ngOnInit() { this.columns = this.getColumns(this.data); // Initialize pagination this.paginationService.initialize(this.data.length); // Initialize filters if (this.columnConfigs) { Object.entries(this.columnConfigs).forEach(([field, config]) => { this.filterService.initializeFilter(field, config); // Get the control from service and subscribe to changes const control = this.filterService.getFilterControl(field); if (control) { control.valueChanges.pipe( debounceTime(config.debounceTime || 300), distinctUntilChanged() ).subscribe(value => { this.filterService.onFilterChange(field, value, config); }); } }); } // Subscribe to filter changes this.filterService.filtersChanged$.subscribe(() => { this.changeDetectorRef.markForCheck(); }); // Subscribe to pagination changes this.paginationService.state$.subscribe(() => { this.changeDetectorRef.markForCheck(); }); // Subscribe to page size changes this.pageSizeControl.valueChanges.subscribe(value => { if (value) { this.paginationService.onPageSizeChange(value); } }); } // edit logic start addNewRow(): void { this.editService.addNewRow(this.columnConfigs || {}); } cancelEditing(rowIndex: number): void { this.editService.cancelEditing(rowIndex); } getEditorComponent(type: any): MatrixEditor | null { console.log('getEditorComponent called with:', { type, isCoordinate: type === CoordinateEditorComponent, isAirport: type === AirportCodeEditorComponent }); if (type === AirportCodeEditorComponent) { return new AirportCodeEditorComponent(this.dialogService); } if (type === CoordinateEditorComponent) { return new CoordinateEditorComponent(this.dialogService); } return null; } getEditorType(type: any): string { console.log('getEditorType called with:', { type, isString: typeof type === 'string', isCoordinate: type === CoordinateEditorComponent, isAirport: type === AirportCodeEditorComponent }); if (typeof type === 'string') { return type; } if (type === AirportCodeEditorComponent || type === CoordinateEditorComponent) { console.log('Returning custom for editor type'); return 'custom'; } console.log('Falling back to text type'); return 'text'; } getEditControl(rowIndex: number, field: string): FormControl { return this.editService.getEditControl(rowIndex, field); } getRowIndex(displayIndex: number): number { return this.editService.getRowIndex(displayIndex); } get hasChanges(): boolean { return this.editService.hasChanges(); } isEditing(index: number): boolean { return this.editService.isEditing(index); } isNewRow(displayIndex: number): boolean { return this.editService.isNewRow(displayIndex); } get newRowsLength(): number { return this.editService.getNewRows().length; } onValueChange(rowIndex: number, field: string, value: any): void { this.editService.onValueChange({ rowIndex, field, value }); } saveChanges(): void { this.data = this.editService.saveChanges(this.data); this.changeDetectorRef.markForCheck(); } startEditing(rowIndex: number): void { this.editService.startEditing(rowIndex); } // edit logic end // filter logic start get activeFilterColumn(): string | undefined { return this.filterService.activeColumn; } getFilterControl(col: string): FormControl<any> { return this.filterService.getFilterControl(col)!; } getOperatorControl(col: string): FormControl<string> { return this.filterService.getOperatorControl(col)!; } onOperatorChange(field: string): void { this.filterService.onOperatorChange(field); } get showFilters(): boolean { return this.filterService.isShowingFilters; } toggleFilters(col: string): void { this.filterService.toggleFilters(col); } // filter logic end // pagination logic start get currentPage(): number { return this.paginationService.getCurrentPage(); } onPageChange(page: number): void { this.paginationService.onPageChange(page); } onPageSizeChange(size: number | 'all'): void { this.paginationService.onPageSizeChange(size); } get paginatedData(): MatrixNode[] { // Start with combined data let allData = [...this.editService.getNewRows(), ...this.data]; // Apply filters if (this.filterService.hasActiveFilters()) { const activeFilters = this.filterService.getActiveFilters(); const filteredExisting = this.data.filter(item => Array.from(activeFilters.values()).every(filter => this.filterService.matchesFilter(item[filter.field], filter) ) ); allData = [...this.editService.getNewRows(), ...filteredExisting]; } // Apply sorting allData = this.sortService.sortData(allData); // Apply pagination return this.paginationService.getPaginatedData(allData); } get pageSizes(): PageSize[] { return this.paginationService.getPageSizes(); } get showPagination(): boolean { return this.paginationService.shouldShowPagination(); } get totalPages(): number { return this.paginationService.getTotalPages(); } get visiblePages(): number[] { return this.paginationService.getVisiblePages(); } // pagination logic end // selection logic start get allSelected(): boolean { return this.selectionService.isAllSelected(); } set allSelected(value: boolean) { this.selectionService.toggleAllRows(value, this.data.length); } getSelectedRows(): MatrixNode[] { return Array.from(this.selectionService.getSelectedRows()) .map(index => this.data[index]) .filter(row => row !== undefined); } get hasSelectedRows(): boolean { return this.selectionService.getSelectedCount() > 0; } isRowSelected(index: number): boolean { return this.selectionService.isSelected(index); } selectRow(index: number, selected = true): void { this.selectionService.selectRow(index, selected); } setSelectedRows(indices: number[]): void { this.selectionService.setSelectedRows(indices); } toggleAllRows(selected: boolean): void { this.selectionService.toggleAllRows(selected, this.data.length); } // selection logic end // sort logic start getSortIcon(column: string): string { return this.sortService.getSortIcon(column); } toggleSort(column: string): void { this.sortService.toggleSort(column); } // sort logic end // i/o logic start formatCoordinate(value: number): string { return value.toFixed(1); } getCodes(data: MatrixNode[]): string[] { if (!data) return []; return data.map(row => row['code']?.toString() || ''); } // i/o logic end // config logic start getColumns(data: MatrixNode[]): string[] { if (!data?.length) return []; const firstRow = data[0]; return Object.keys(firstRow); } get hasData(): boolean { return !!this.data?.length; } // config logic end }
|   |   |   --- ixt-table.index.ts: // src/components/ixt-matrix/index.ts // Fix these import paths to match your folder structure export * from './ixt-table.component'; export * from './ixt-table.interfaces'; export * from './ixt-table.module'; export interface MatrixNode { [key: string]: any; children?: MatrixNode[]; } export * from './editors/airport-code/airport-code-editor.component'; export * from './editors/binary-editor/binary-editor.component'; export * from './editors/coordinate/coordinate-editor.component';
|   |   |   --- ixt-table.interfaces.ts: // File: src/components/ixt-table/ixt-table.interfaces.ts import { Type } from "@angular/core"; import { MatrixEditor } from "./editors/editor.interface"; export interface MatrixNode { code?: string; // Add this property [key: string]: any; } export interface PageSize { value: number | 'all'; label: string; } export type FilterOperator = 'equals' | 'startsWith' | 'contains' | 'between' | '>' | '<' | '>=' | '<=' | '!='; export interface FilterState { field: string; operator: FilterOperator; value: any; secondaryValue?: any; } export interface ColumnConfig { type: 'text' | 'number' | 'enum' | Type<MatrixEditor> | MatrixEditor; field: string; label?: string; operator?: FilterOperator; enumValues?: { value: any, label: string }[]; placeholder?: string; debounceTime?: number; editable?: boolean; config?: any; } export interface RowChanges { [key: string]: any; } export type ColumnConfigs = Record<string, ColumnConfig>;
|   |   |   --- ixt-table.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { MatIconModule } from '@angular/material/icon'; import { MatAutocompleteModule } from '@angular/material/autocomplete'; import { IxtTableComponent } from './ixt-table.component'; import { AirportCodeEditorComponent } from './editors/airport-code/airport-code-editor.component'; import { CoordinateEditorComponent } from './editors/coordinate/coordinate-editor.component'; import { BinaryEditorComponent } from './editors/binary-editor/binary-editor.component'; @NgModule({ declarations: [ IxtTableComponent, AirportCodeEditorComponent, CoordinateEditorComponent, BinaryEditorComponent ], imports: [ CommonModule, FormsModule, // Make sure this is here ReactiveFormsModule, MatIconModule, MatAutocompleteModule ], exports: [IxtTableComponent] }) export class IxtTableModule { }
|   |   |   --- ixt-table.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject, combineLatest, Observable } from 'rxjs'; import { map } from 'rxjs/operators'; import { MatrixRow } from './matrix-base.type'; import { PageSize } from './ixt-matrix.interfaces'; export interface PaginationState { currentPage: number; pageSize: number | 'all'; totalPages: number; } @Injectable({ providedIn: 'root' }) export class MatrixDataService { private dataSubject = new BehaviorSubject<MatrixRow[]>([]); private newRowsSubject = new BehaviorSubject<MatrixRow[]>([]); private paginationStateSubject = new BehaviorSubject<PaginationState>({ currentPage: 1, pageSize: 10, totalPages: 1 }); readonly pageSizes: PageSize[] = [ { value: 10, label: '10' }, { value: 100, label: '100' }, { value: 'all', label: 'All' } ]; constructor() { } // Data operations setData(data: MatrixRow[]): void { this.dataSubject.next(data); this.updateTotalPages(); } getData(): Observable<MatrixRow[]> { return this.dataSubject.asObservable(); } // New rows operations addNewRow(row: MatrixRow): void { const currentNewRows = this.newRowsSubject.value; this.newRowsSubject.next([row, ...currentNewRows]); } getNewRows(): Observable<MatrixRow[]> { return this.newRowsSubject.asObservable(); } commitNewRows(): void { const currentData = this.dataSubject.value; const newRows = this.newRowsSubject.value; this.dataSubject.next([...newRows, ...currentData]); this.newRowsSubject.next([]); this.updateTotalPages(); } // Pagination operations setPaginationState(state: Partial<PaginationState>): void { const currentState = this.paginationStateSubject.value; this.paginationStateSubject.next({ ...currentState, ...state }); this.updateTotalPages(); } getPaginationState(): Observable<PaginationState> { return this.paginationStateSubject.asObservable(); } getPaginatedData(): Observable<MatrixRow[]> { return this.combineData().pipe( map(allData => this.paginateData(allData)) ); } private combineData(): Observable<MatrixRow[]> { return combineLatest([ this.dataSubject, this.newRowsSubject ]).pipe( map(([data, newRows]) => [...newRows, ...data]) ); } private paginateData(data: MatrixRow[]): MatrixRow[] { const state = this.paginationStateSubject.value; if (state.pageSize === 'all' || data.length <= 50) { return data; } const start = (state.currentPage - 1) * (+state.pageSize); const end = start + (+state.pageSize); return data.slice(start, end); } private updateTotalPages(): void { const currentState = this.paginationStateSubject.value; const totalItems = this.dataSubject.value.length + this.newRowsSubject.value.length; const totalPages = currentState.pageSize === 'all' || totalItems <= 50 ? 1 : Math.ceil(totalItems / +currentState.pageSize); this.paginationStateSubject.next({ ...currentState, totalPages }); } }
|   |   |   --- ixt-table.type.ts: export interface MatrixRow { [key: string]: any; }
|   |   \-- theme
|   |       +-- styles
|   |       |   \-- themes
|   |       --- indext.ts: // src/components/theme/index.ts export * from './theme.types'; export * from './theme.colors';
|   |       --- theme.colors.ts: import { ThemeColors } from "./theme.types"; // src/app/theme/theme.colors.ts export const baseThemeColors: ThemeColors = { primary: { base: '#4169E1', // Royal Blue hover: '#2850c9', active: '#1e40af', text: '#ffffff' }, secondary: { base: '#6c757d', hover: '#5c636a', active: '#4d5154', text: '#ffffff' }, tertiary: { base: '#003057', // Rhapsody Blue (Pantone 289) hover: '#002649', // Darker shade for hover state active: '#001C3B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, success: { base: '#28a745', hover: '#218838', active: '#1e7e34', text: '#ffffff' }, danger: { base: '#dc3545', hover: '#c82333', active: '#bd2130', text: '#ffffff' }, warning: { base: '#ffc107', hover: '#e0a800', active: '#d39e00', text: '#000000' }, info: { base: '#17a2b8', hover: '#138496', active: '#117a8b', text: '#ffffff' }, light: { base: '#f8f9fa', hover: '#e2e6ea', active: '#dae0e5', text: '#000000' }, dark: { base: '#343a40', hover: '#23272b', active: '#1d2124', text: '#ffffff' }, default: { base: '#ffffff', hover: '#f8f9fa', active: '#e9ecef', text: '#000000' } }; // src/app/theme/theme.colors.ts export const unitedThemeColors: ThemeColors = { primary: { base: '#0033A0', // United Blue hover: '#00297A', // Darker shade for hover state active: '#002060', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, secondary: { base: '#6D2077', // Atlantic Amethyst hover: '#5A1A63', // Darker shade for hover state active: '#48154F', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, tertiary: { base: '#003057', // Rhapsody Blue (Pantone 289) hover: '#002649', // Darker shade for hover state active: '#001C3B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, success: { base: '#4CAF50', // Subtle green hover: '#43A047', // Darker shade for hover state active: '#388E3C', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, warning: { base: '#FF9800', // Warm yellow-orange hover: '#FB8C00', // Darker shade for hover state active: '#F57C00', // Even darker shade for active state text: '#000000' // Black text for readability }, danger: { base: '#E53935', // Tomato red hover: '#D32F2F', // Darker shade for hover state active: '#C62828', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, info: { base: '#17A2B8', // Standard info blue hover: '#138496', // Darker shade for hover state active: '#117A8B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, light: { base: '#F8F9FA', // Light gray hover: '#E2E6EA', // Darker shade for hover state active: '#DAE0E5', // Even darker shade for active state text: '#000000' // Black text for readability }, dark: { base: '#343A40', // Dark gray hover: '#23272B', // Darker shade for hover state active: '#1D2124', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, default: { base: '#FFFFFF', // White hover: '#F8F9FA', // Light gray for hover state active: '#E9ECEF', // Darker gray for active state text: '#000000' // Black text for readability } };
|   |       --- theme.colors.united.ts: <empty file>
|   |       --- theme.module.ts: // src/components/theme/theme.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [CommonModule], exports: [] }) export class ThemeModule {}
|   |       --- theme.types.ts: // src/app/theme/theme.types.ts export type ThemeVariant = | 'primary' // Main brand color, key actions | 'secondary' // Supporting color | 'tertiary' | 'success' // Positive actions/states | 'danger' // Errors, destructive actions | 'warning' // Caution states | 'info' // Informational states | 'light' // Light backgrounds | 'dark' // Dark text/backgrounds | 'default'; // Default state export interface ThemeColor { base: string; hover: string; active: string; text: string; } export type ThemeColors = Record<ThemeVariant, ThemeColor>;
|   +-- services
|   |   --- breadcrumb.service.ts: import { Injectable } from '@angular/core'; import { Router, NavigationEnd, ActivatedRoute } from '@angular/router'; import { filter, map } from 'rxjs/operators'; import { Observable } from 'rxjs'; export interface Breadcrumb { label: string; url: string; } @Injectable({ providedIn: 'root' }) export class BreadcrumbService { breadcrumbs$: Observable<Breadcrumb[]>; constructor(private router: Router, private activatedRoute: ActivatedRoute) { this.breadcrumbs$ = this.router.events.pipe( filter(event => event instanceof NavigationEnd), map(event => { const root = this.activatedRoute.root; return this.createBreadcrumbs(root); }) ); } private createBreadcrumbs(route: ActivatedRoute, url: string = '', breadcrumbs: Breadcrumb[] = []): Breadcrumb[] { const children: ActivatedRoute[] = route.children; if (children.length === 0) { return breadcrumbs; } for (const child of children) { const routeURL: string = child.snapshot.url.map(segment => segment.path).join('/'); if (routeURL !== '') { url += `/${routeURL}`; } const label = child.snapshot.data['breadcrumb']; if (label) { breadcrumbs.push({ label, url }); } return this.createBreadcrumbs(child, url, breadcrumbs); } return breadcrumbs; } }
|   --- colors.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>United Airlines Palette</title> <style> body { font-family: Arial, sans-serif; line-height: 1.5; margin: 20px; } table { width: 100%; border-collapse: collapse; } th, td { border: 1px solid #ccc; padding: 10px; text-align: left; } th { background-color: #f4f4f4; } .color-box { width: 50px; height: 50px; display: inline-block; border-radius: 5px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } .header-example { width: 100%; height: 100px; border-radius: 5px; margin: 10px 0; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15); } .united-blue { background: radial-gradient(circle at center, #0033A0, #00297D); } .rhapsody-blue { background: radial-gradient(circle at center, #003057, #00203D); } .runway-gray { background: linear-gradient(to bottom, #E6E7E8, #CBCBCD); } .dusk { background: linear-gradient(to right, #9B9FBB, #7E8298); } .premium-purple { background: radial-gradient(circle at center, #4B306A, #3B2553); } .atlantic-amethyst { background: linear-gradient(to bottom, #7D5FB2, #614989); } .pacific-blue { background: radial-gradient(circle at center, #00B2A9, #008983); } .sky-blue { background: linear-gradient(to right, #6CB4E0, #4F8CB4); } .platinum { background: radial-gradient(circle at center, #A2AAAD, #808586); } .cloud-white { background: linear-gradient(to bottom, #F1F2F2, #D7D8D8); } .balanced-beige-gold { background: radial-gradient(circle at center, #C9A972, #D8BB8A, #E6CFA5, #F1DDBE); } .success { background: radial-gradient(circle at center, #28A745, #1E7A34); } .warning { background: radial-gradient(circle at center, #FFC107, #E0A800); } .danger { background: radial-gradient(circle at center, #DC3545, #B02A37); } .info { background: radial-gradient(circle at center, #17A2B8, #117A8B); } .error { background: radial-gradient(circle at center, #C82333, #9A1F29); } </style> </head> <body> <h1>United Airlines Palette with Header Examples</h1> <table> <thead> <tr> <th>Color Name</th> <th>Color Name 2</th> <th>Hex Code</th> <th>Gradient Definition</th> <th>Sample</th> <th>Header Example</th> <th>Use Cases</th> </tr> </thead> <tbody> <tr> <td>United Blue</td> <td>Digital Sapphire, Quantum Sky, Blue Alloy</td> <td>#0033A0</td> <td>Radial Gradient: #0033A0, #00297D</td> <td> <div class="color-box united-blue"></div> </td> <td> <div class="header-example united-blue"></div> </td> <td>Primary, Buttons, Nav Menu</td> </tr> <tr> <td>Rhapsody Blue</td> <td>Midnight Carbon, Indigo Core, Deep Silicon</td> <td>#003057</td> <td>Radial Gradient: #003057, #00203D</td> <td> <div class="color-box rhapsody-blue"></div> </td> <td> <div class="header-example rhapsody-blue"></div> </td> <td>Background, Secondary Headers, Borders</td> </tr> <tr> <td>Runway Gray</td> <td>Titanium Mist, Cloud Alloy, Digital Quartz</td> <td>#E6E7E8</td> <td>Linear Gradient: #E6E7E8, #CBCBCD</td> <td> <div class="color-box runway-gray"></div> </td> <td> <div class="header-example runway-gray"></div> </td> <td>Background, Disabled States, Borders</td> </tr> <tr> <td>Dusk</td> <td>Amethyst Fog, Violet Cloud, Digital Orchid</td> <td>#9B9FBB</td> <td>Linear Gradient: #9B9FBB, #7E8298</td> <td> <div class="color-box dusk"></div> </td> <td> <div class="header-example dusk"></div> </td> <td>Accents, Text Hover, Selected States</td> </tr> <tr> <td>Premium Purple</td> <td>Plasma Violet, Quantum Plum, Tech Amethyst</td> <td>#4B306A</td> <td>Radial Gradient: #4B306A, #3B2553</td> <td> <div class="color-box premium-purple"></div> </td> <td> <div class="header-example premium-purple"></div> </td> <td>Premium Features, Buttons, Highlights</td> </tr> <tr> <td>Atlantic Amethyst</td> <td>Neon Lavender, Mineral Glow, Crystal Orchid</td> <td>#7D5FB2</td> <td>Linear Gradient: #7D5FB2, #614989</td> <td> <div class="color-box atlantic-amethyst"></div> </td> <td> <div class="header-example atlantic-amethyst"></div> </td> <td>Links, Text Selected, Call-to-Action</td> </tr> <tr> <td>Pacific Blue</td> <td>Digital Aqua, Silicon Crest, Coastal Alloy</td> <td>#00B2A9</td> <td>Radial Gradient: #00B2A9, #008983</td> <td> <div class="color-box pacific-blue"></div> </td> <td> <div class="header-example pacific-blue"></div> </td> <td>Buttons, Nav Menu, Active States</td> </tr> <tr> <td>Sky Blue</td> <td>Arctic Tech, Horizon Core, Frosted Silicon</td> <td>#6CB4E0</td> <td>Linear Gradient: #6CB4E0, #4F8CB4</td> <td> <div class="color-box sky-blue"></div> </td> <td> <div class="header-example sky-blue"></div> </td> <td>Text, Hover Effects, Subtle Highlights</td> </tr> <tr> <td>Platinum</td> <td>Metal Glow, Lunar Alloy, Circuit Silver</td> <td>#A2AAAD</td> <td>Radial Gradient: #A2AAAD, #808586</td> <td> <div class="color-box platinum"></div> </td> <td> <div class="header-example platinum"></div> </td> <td>Borders, Dividers, Neutral Backgrounds</td> </tr> <tr> <td>Cloud White</td> <td>Neural Cloud, Pearl Alloy, Tech Mist</td> <td>#F1F2F2</td> <td>Linear Gradient: #F1F2F2, #D7D8D8</td> <td> <div class="color-box cloud-white"></div> </td> <td> <div class="header-example cloud-white"></div> </td> <td>Main Background, Text Background</td> </tr> <tr> <td>Balanced Beige-Gold</td> <td>Quantum Gold, Solar Alloy, Crystal Dune</td> <td>#D8BB8A</td> <td>Radial Gradient: #C9A972, #D8BB8A, #E6CFA5, #F1DDBE</td> <td> <div class="color-box balanced-beige-gold"></div> </td> <td> <div class="header-example balanced-beige-gold"></div> </td> <td>Headers, Highlights, Premium Sections</td> </tr> <tr> <td rowspan="2">Success</td> <td>Emerald, Growth Green, Vitality</td> <td>#28A745</td> <td>Radial Gradient: #28A745, #1E7A34</td> <td><div class="color-box success"></div></td> <td><div class="header-example success"></div></td> <td>Dialog Headers</td> </tr> <tr> <td>Soft Emerald, Pastel Green</td> <td>#A7E3B2</td> <td>Radial Gradient: #A7E3B2, #8EDBA2</td> <td><div class="color-box" style="background: radial-gradient(circle, #A7E3B2, #8EDBA2);"></div></td> <td><div class="header-example" style="background: radial-gradient(circle, #A7E3B2, #8EDBA2);"></div></td> <td>Text Backgrounds, Form Highlights</td> </tr> <tr> <td rowspan="2">Warning</td> <td>Amber, Alert Yellow, Solar Glow</td> <td>#FFC107</td> <td>Radial Gradient: #FFC107, #E0A800</td> <td><div class="color-box warning"></div></td> <td><div class="header-example warning"></div></td> <td>Dialog Headers</td> </tr> <tr> <td>Soft Amber, Pastel Yellow</td> <td>#FFE59B</td> <td>Radial Gradient: #FFE59B, #FFD86A</td> <td><div class="color-box" style="background: radial-gradient(circle, #FFE59B, #FFD86A);"></div></td> <td><div class="header-example" style="background: radial-gradient(circle, #FFE59B, #FFD86A);"></div></td> <td>Text Backgrounds, Form Highlights</td> </tr> <tr> <td rowspan="2">Danger</td> <td>Crimson, Risk Red, Fire Glow</td> <td>#DC3545</td> <td>Radial Gradient: #DC3545, #B02A37</td> <td><div class="color-box danger"></div></td> <td><div class="header-example danger"></div></td> <td>Dialog Headers</td> </tr> <tr> <td>Soft Crimson, Pastel Red</td> <td>#F5A6A8</td> <td>Radial Gradient: #F5A6A8, #E58C8E</td> <td><div class="color-box" style="background: radial-gradient(circle, #F5A6A8, #E58C8E);"></div></td> <td><div class="header-example" style="background: radial-gradient(circle, #F5A6A8, #E58C8E);"></div></td> <td>Text Backgrounds, Form Highlights</td> </tr> <tr> <td rowspan="2">Info</td> <td>Azure Glow, Digital Breeze, Tech Sky</td> <td>#17A2B8</td> <td>Radial Gradient: #17A2B8, #117A8B</td> <td><div class="color-box info"></div></td> <td><div class="header-example info"></div></td> <td>Dialog Headers</td> </tr> <tr> <td>Soft Azure, Pastel Blue</td> <td>#A3D7E8</td> <td>Radial Gradient: #A3D7E8, #8CCDE2</td> <td><div class="color-box" style="background: radial-gradient(circle, #A3D7E8, #8CCDE2);"></div></td> <td><div class="header-example" style="background: radial-gradient(circle, #A3D7E8, #8CCDE2);"></div></td> <td>Text Backgrounds, Form Highlights</td> </tr> <tr> <td rowspan="2">Error</td> <td>Cerise, Critical Red, Alert Crimson</td> <td>#C82333</td> <td>Radial Gradient: #C82333, #9A1F29</td> <td><div class="color-box error"></div></td> <td><div class="header-example error"></div></td> <td>Dialog Headers</td> </tr> <tr> <td>Soft Cerise, Pastel Red</td> <td>#EFA3A5</td> <td>Radial Gradient: #EFA3A5, #D9898A</td> <td><div class="color-box" style="background: radial-gradient(circle, #EFA3A5, #D9898A);"></div></td> <td><div class="header-example" style="background: radial-gradient(circle, #EFA3A5, #D9898A);"></div></td> <td>Text Backgrounds, Form Highlights</td> </tr> </tbody> </table> </body>
|   --- favicon.ico: <image file>
|   --- fonts.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Font Specification</title> <style> body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; } h1 { font-family: 'Roboto', sans-serif; font-size: 2.5em; font-weight: 700; margin-bottom: 10px; color: #0033A0; } h2 { font-family: 'Roboto', sans-serif; font-size: 2em; font-weight: 500; margin-bottom: 10px; color: #4B306A; } h3 { font-family: 'Roboto', sans-serif; font-size: 1.5em; font-weight: 400; margin-bottom: 10px; color: #7D5FB2; } h4, h5, h6 { font-family: 'Roboto', sans-serif; color: #444; } h4 { font-size: 1.2em; font-weight: 500; } h5 { font-size: 1em; font-weight: 400; } h6 { font-size: 0.9em; font-weight: 400; } p, li { font-family: 'Open Sans', sans-serif; font-size: 1em; font-weight: 300; color: #333; line-height: 1.8; } a { font-family: 'Open Sans', sans-serif; font-size: 1em; font-weight: 400; text-decoration: none; color: #00B2A9; } a:hover { text-decoration: underline; color: #007F77; } button { font-family: 'Roboto', sans-serif; font-size: 1em; font-weight: 500; padding: 10px 20px; color: #fff; background-color: #0033A0; border: none; border-radius: 5px; cursor: pointer; } button:hover { background-color: #00297D; } code { font-family: 'Courier New', monospace; background-color: #f4f4f4; padding: 2px 4px; border-radius: 3px; font-size: 0.9em; } small { font-family: 'Open Sans', sans-serif; font-size: 0.8em; color: #666; } b, strong { font-weight: 700; } i, em { font-style: italic; } mark { background-color: #ff0; color: #000; padding: 2px 4px; } del { text-decoration: line-through; color: #dc3545; } ins { text-decoration: underline; color: #28a745; } sub { font-size: 0.8em; vertical-align: sub; } sup { font-size: 0.8em; vertical-align: super; } hr { border: 0; height: 1px; background: #ccc; margin: 20px 0; } ul { list-style-type: disc; margin-left: 20px; } ol { list-style-type: decimal; margin-left: 20px; } dl { margin: 20px 0; } dt { font-weight: 700; color: #0033A0; } dd { margin-left: 20px; color: #555; } table { width: 100%; border-collapse: collapse; } th, td { border: 1px solid #ccc; padding: 10px; text-align: left; } th { background-color: #f4f4f4; } </style> </head> <body> <h1>Font Specification</h1> <h2>Headers</h2> <ul> <h1>H1: Roboto, 2.5em, Bold, Primary Color (#0033A0)</h1> <h2>H2: Roboto, 2em, Semi-Bold, Secondary Color (#4B306A)</h2> <h3>H3: Roboto, 1.5em, Regular, Tertiary Color (#7D5FB2)</h3> <h4>H4-H6: Roboto, Gradually Smaller and Lighter (#444)</h4> <h5>H4-H6: Roboto, Gradually Smaller and Lighter (#444)</h5> <h6>H4-H6: Roboto, Gradually Smaller and Lighter (#444)</h6> </ul> <h2>Text Elements</h2> <p>Example of <b>bold</b> and <strong>important</strong> text.</p> <p>Example of <i>italic</i> and <em>emphasized</em> text.</p> <p>Example of <mark>highlighted</mark>, <del>deleted</del>, and <ins>inserted</ins> text.</p> <p>Example of <sub>subscript</sub> and <sup>superscript</sup> text.</p> <h2>Lists</h2> <ul> <li>Unordered list item 1</li> <li>Unordered list item 2</li> </ul> <ol> <li>Ordered list item 1</li> <li>Ordered list item 2</li> </ol> <h2>Description List</h2> <dl> <dt>Term 1</dt> <dd>Description for Term 1</dd> <dt>Term 2</dt> <dd>Description for Term 2</dd> </dl> <h2>Tables</h2> <table> <thead> <tr> <th>Header 1</th> <th>Header 2</th> </tr> </thead> <tbody> <tr> <td>Data 1</td> <td>Data 2</td> </tr> </tbody> </table> <hr> <h2>Small Text</h2> <p><small>This is small text, often used for footnotes or additional information.</small></p> </body> </html>
|   --- index.html: <!doctype html> <html> <head> <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> <meta charset="utf-8"> <title>Ixtlan Demo</title> <base href="/"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="icon" type="image/x-icon" href="favicon.ico"> </head> <body> <app-root></app-root> </body> </html>
|   --- main.ts: import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module'; platformBrowserDynamic().bootstrapModule(AppModule) .catch(err => console.error(err));
|   --- polyfills.ts: import 'zone.js';
|   --- public-api.ts: // File: src/public-api.ts export * from './components/ixt-table/ixt-table.interfaces'; // Core UI Components export * from './components/ixt-button/ixt-button.index'; export * from './components/ixt-dialog/ixt-dialog.index'; export * from './components/ixt-tabset/ixt-tabset.index'; export * from './components/ixt-panel/ixt-panel.index'; export * from './components/ixt-menu/ixt-menu.index'; export * from './components/ixt-tree/ixt-tree.index'; export * from './components/ixt-accordian/ixt-accordian.index'; // Canvas & Viewport Components export * from './components/ixt-canvas/ixt-canvas.index'; export * from './components/ixt-viewport/ixt-viewport.index'; // Form Components export * from './components/ixt-expression-builder/ixt-expression-builder.index'; // Diagram Components export * from './components/ixt-diagram/ixt-diagram.index'; export * from './components/ixt-diagram/types/clazz/ixt-clazz.index'; export * from './components/ixt-diagram/types/deployment/ixt-deployment.index'; export * from './components/ixt-diagram/types/EBNF/ixt.ebnf.index'; export * from './components/ixt-diagram/types/flow/ixt-flow.index'; export * from './components/ixt-diagram/types/gannt/gannt.index'; export * from './components/ixt-diagram/types/network/ixt-network.index'; export * from './components/ixt-diagram/types/sankey/ixt-sankey.index'; export * from './components/ixt-diagram/types/wireframe/ixt-wireframe.index'; // Layer Management export * from './components/ixt-layer-manager/ixt-layer-manager.index'; // Calendar Component export * from './components/ixt-calendar/ixt-calendar.index'; // Map Component export * from './components/ixt-map/ixt-map.index'; // Split Pane Component export * from './components/ixt-splitpane/index'; // Add to src/public-api.ts export * from './components/theme/theme.types'; export * from './components/theme/theme.colors'; // In src/public-api.ts, add: export interface TableConfig { columns: { [key: string]: { title: string; type?: string; sortable?: boolean; filterable?: boolean; } }; sortable?: boolean; filterable?: boolean; pageSize?: number; }
--- .editorconfig: # Editor configuration, see https://editorconfig.org root = true [*] charset = utf-8 indent_style = space indent_size = 2 insert_final_newline = true trim_trailing_whitespace = true [*.ts] quote_type = single [*.md] max_line_length = off trim_trailing_whitespace = false
--- .gitignore: # Compiled output /dist /tmp /out-tsc /bazel-out # Node modules and logs /node_modules npm-debug.log* yarn-debug.log* yarn-error.log* .pnpm-debug.log* # IDEs and editors .idea/ /.project .classpath .c9/ /.settings/ *.launch *.sublime-workspace # Visual Studio Code .vscode/ !.vscode/settings.json # Optional: Share common workspace settings !.vscode/extensions.json # Optional: Share recommended extensions # Ignore user-specific files .vscode/launch.json # Debug configurations (usually user-specific) .vscode/tasks.json # Build tasks (often user/environment-specific) # History files (from various plugins) .history/ # Angular and TypeScript specific .angular/ .angular/cache .sass-cache/ coverage/ build/ libpeerconnection.log testem.log typings/ *.js *.d.ts *.js.map # Environment files .env .env.local .env.*.local # System files .DS_Store Thumbs.db # Temporary or backup files *.tmp *.bak *.swp *.swo *.~lock.* # GitHub .github/ # Miscellaneous connect.lock
