+-- .angular
|   \-- cache
+-- src
|   +-- app
|   |   +-- accordion
|   |   |   --- accordion.data.ts: import { Injectable } from '@angular/core'; import { AccordionPanel } from '../../components/ixt-accordian/ixt-accordian.component'; @Injectable({ providedIn: 'root' }) export class AccordianDataService { getAccordianPanels(): AccordionPanel[] { return [ { title: 'Section 1', content: 'Content for section 1', isOpen: false }, { title: 'Section 2', content: 'Content for section 2', isOpen: false }, { title: 'Section 3', content: 'Content for section 3', isOpen: false } ]; } }
|   |   +-- dialog
|   |   |   --- ixt-dialog.handler.ts: <empty file>
|   |   +-- expression
|   |   |   --- ixt-expression.helper.ts: // src/app/expression/ixt-expression.helper.ts import { Injectable } from '@angular/core'; // Add this import { Expression, ExpressionGroup } from '../../components/ixt-expression-builder/ixt-expression-builder.interfaces'; @Injectable() export class IxtExpressionHelper { convertToJsonLogic(group: ExpressionGroup): any { if (group.children.length === 0) return {}; const logic: any = { [group.operator]: group.children.map((child: Expression | ExpressionGroup) => { if (child.type === 'group') { return this.convertToJsonLogic(child); } if (child.type === 'expression') { if (child.operator === 'in' || child.operator === 'not_in') { return { [child.operator === 'in' ? 'in' : '!in']: [ { var: child.field }, child.values || [] ] }; } return { [child.operator]: [ { var: child.field }, child.value ] }; } return {}; }) }; return logic; } }
|   |   |   --- ixt-expression.provider.ts: // src/app/expression/ixt-expression.provider.ts import { Injectable } from '@angular/core'; // Add this import { Expression, ExpressionGroup } from '../../components/ixt-expression-builder/ixt-expression-builder.interfaces'; import { IxtExpressionHelper } from './ixt-expression.helper'; @Injectable() // Add this export class IxtExpressionProvider { expressionGroup: ExpressionGroup = { type: 'group', operator: 'and', children: [] }; expressionJsonLogic: any = {}; constructor(private helper: IxtExpressionHelper) {} onExpressionGroupChange(group: ExpressionGroup): void { this.expressionGroup = group; this.expressionJsonLogic = this.helper.convertToJsonLogic(group); } }
|   |   +-- form
|   |   |   --- ixt-employee-form.handler.ts: // src/app/form/ixt-employee-form.handler.ts import { Injectable } from '@angular/core'; import { IxtEmployeeFormProvider } from './ixt-employee-form.provider'; import { IxtDialogService } from '../../components/ixt-dialog/ixt-dialog.service'; import { EmployeeForm } from './ixt-employee-form.provider'; @Injectable() export class IxtEmployeeFormHandler { constructor( private provider: IxtEmployeeFormProvider, private dialogService: IxtDialogService ) {} async submitForm() { const form = this.provider.getCurrentForm(); // Validate form if (!this.validateForm(form)) { // this.dialogService.show({ // title: 'Validation Error', // message: 'Please fill in all required fields.', // type: DialogType.Error, // okText: 'OK', // showCancel: false, // isModal: true // }); return; } try { // Simulate API call await this.saveEmployee(form); // this.dialogService.show({ // title: 'Success', // message: 'Employee information saved successfully!', // type: DialogType.Success, // okText: 'OK', // showCancel: false, // isModal: true // }); this.provider.resetForm(); } catch (error) { // this.dialogService.show({ // title: 'Error', // message: 'Failed to save employee information. Please try again.', // type: DialogType.Error, // okText: 'OK', // showCancel: false, // isModal: true // }); } } confirmDelete(employeeId: number) { // this.dialogService.show({ // title: 'Confirm Delete', // message: 'Are you sure you want to delete this employee record?', // type: DialogType.Question, // okText: 'Yes', // cancelText: 'No', // showCancel: true, // isModal: true // }); } updateField(field: keyof EmployeeForm, value: any) { this.provider.updateForm({ [field]: value }); } private validateForm(form: EmployeeForm): boolean { return !!( form.firstName && form.lastName && form.email && form.department && form.position && form.hireDate ); } private async saveEmployee(form: EmployeeForm): Promise<void> { // Simulate API call return new Promise((resolve, reject) => { setTimeout(() => { // Simulate 90% success rate if (Math.random() > 0.1) { resolve(); } else { reject(new Error('Failed to save employee')); } }, 1000); }); } showUnsavedChangesDialog(): Promise<boolean> { return new Promise((resolve) => { // this.dialogService.show({ // title: 'Unsaved Changes', // message: 'You have unsaved changes. Do you want to continue?', // type: DialogType.Warning, // okText: 'Yes', // cancelText: 'No', // showCancel: true, // isModal: true // }); }); } resetForm() { // this.dialogService.show({ // title: 'Confirm Reset', // message: 'Are you sure you want to reset the form? All unsaved changes will be lost.', // type: DialogType.Warning, // okText: 'Yes', // cancelText: 'No', // showCancel: true, // isModal: true // }); } }
|   |   |   --- ixt-employee-form.provider.ts: // src/app/form/ixt-employee-form.provider.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; export interface EmployeeForm { id?: number; firstName: string; lastName: string; email: string; phone: string; department: string; position: string; hireDate: Date; // Add any other employee fields you need } @Injectable() export class IxtEmployeeFormProvider { private formState = new BehaviorSubject<EmployeeForm>({ firstName: '', lastName: '', email: '', phone: '', department: '', position: '', hireDate: new Date() }); formState$ = this.formState.asObservable(); updateForm(form: Partial<EmployeeForm>) { this.formState.next({ ...this.formState.value, ...form }); } resetForm() { this.formState.next({ firstName: '', lastName: '', email: '', phone: '', department: '', position: '', hireDate: new Date() }); } getCurrentForm(): EmployeeForm { return this.formState.value; } }
|   |   +-- layer
|   |   |   --- ixt-layer.manager.ts: // src/app/layer/ixt-layer.manager.ts import { Injectable } from '@angular/core'; import { Layer } from '../../components/ixt-layer-manager/ixt-layer-manager.component'; @Injectable({ providedIn: 'root' // Makes it a singleton service available app-wide }) export class IxtLayerManager { onLayerChange(layers: any[]) { console.log('Layers updated:', layers); // Implement your layer update logic here } onLayerOrderChange(layers: any[]) { console.log('Layer order changed:', layers); // Implement your layer order update logic here } }
|   |   |   --- ixt-layer.provider.ts: // src/app/layer/ixt-layer.provider.ts import { Injectable } from '@angular/core'; import { Layer } from '../../components/ixt-layer-manager/ixt-layer-manager.component'; @Injectable({ providedIn: 'root' // Makes it a singleton service available app-wide }) export class IxtLayerProvider { mapLayers: Layer[] = [ { id: 'layer1', name: 'Base Map', visible: true, fillColor: '#e3e3e3', strokeColor: '#666666', strokeStyle: 'solid' as const, order: 0 }, { id: 'layer2', name: 'Roads', visible: true, fillColor: '#ffffff', strokeColor: '#333333', strokeStyle: 'solid' as const, order: 1 }, { id: 'layer3', name: 'Points of Interest', visible: true, fillColor: '#ff4444', strokeColor: '#cc0000', strokeStyle: 'dotted' as const, order: 2 } ]; }
|   |   +-- menu
|   |   |   --- ixt-menu.provider.ts: // ixt-menu.provider.ts import { Injectable } from '@angular/core'; //import { MenuNode } from 'src/components/ixt-menu'; @Injectable({ providedIn: 'root' }) export class IxtMenuProvider { }
|   |   +-- table
|   |   |   --- ixt-table.provider.ts: // src/app/matrix/ixt-matrix.provider.ts import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { Observable } from 'rxjs'; import { IxtDialogService } from 'src/components/ixt-dialog/ixt-dialog.service'; import { ColumnConfigs, AirportCodeEditorComponent, CoordinateEditorComponent } from 'src/public-api'; @Injectable({ providedIn: 'root' }) export class IxtTableProvider { constructor( private http: HttpClient, private dialogService: IxtDialogService ) {} getColumnConfigs(): ColumnConfigs { return { code: { type: AirportCodeEditorComponent as any, field: 'code', editable: true, label: 'IATA Code' }, region: { type: 'text', field: 'region', label: 'Region', editable: true }, name: { type: 'text', field: 'name', label: 'Name', editable: true }, city: { type: 'text', field: 'city', label: 'City', editable: true }, country: { type: 'text', field: 'country', label: 'Country', editable: true }, lat: { type: CoordinateEditorComponent, field: 'lat', label: 'LAT', editable: true }, lon: { type: CoordinateEditorComponent, field: 'lon', label: 'LON', editable: true } }; } getAirportData(): Observable<any[]> { return this.http.get<any[]>('assets/Airport.json'); } getAirportColumnConfigs(): ColumnConfigs { return this.getColumnConfigs(); } }
|   |   +-- tree
|   |   |   --- ixt-tree.handler.ts: // src/app/tree/ixt-tree.handler.ts import { Injectable } from '@angular/core'; import { TreeNode } from '../../components/ixt-tree/ixt-tree.component'; @Injectable({ providedIn: 'root' }) export class IxtTreeHandler { onNodeExpanded(node: TreeNode): void { console.log('Node expanded:', node); } onNodeCollapsed(node: TreeNode): void { console.log('Node collapsed:', node); } onNodeSelected(node: TreeNode): void { console.log('Node selected:', node); } }
|   |   |   --- ixt-tree.provider.ts: // src/app/tree/ixt-tree.provider.ts import { Injectable } from '@angular/core'; import { TreeNode } from '../../components/ixt-tree/ixt-tree.component'; @Injectable({ providedIn: 'root' }) export class IxtTreeProvider { treeData: TreeNode[] = [ { id: '1', label: 'Project Files', children: [ { id: '1.1', label: 'src', children: [ { id: '1.1.1', label: 'app', children: [ { id: '1.1.1.1', label: 'components' }, { id: '1.1.1.2', label: 'services' } ] }, { id: '1.1.2', label: 'assets' } ] }, { id: '1.2', label: 'config', children: [ { id: '1.2.1', label: 'tsconfig.json' }, { id: '1.2.2', label: 'package.json' } ] } ] } ]; }
|   |   --- app.component.html: <main> <nav> <ixt-tabset title="Employee Form"> <ixt-tab title="Tab 1"> <ixt-tree [nodes]="treeProvider.treeData" (nodeExpanded)="treeHandler.onNodeExpanded($event)" (nodeCollapsed)="treeHandler.onNodeCollapsed($event)" (nodeSelected)="treeHandler.onNodeSelected($event)"> </ixt-tree> </ixt-tab> <ixt-tab title="Tab 2"> <ixt-accordian [panels]="accordionPanels" [allowMultiple]="true"> </ixt-accordian> </ixt-tab> </ixt-tabset> </nav> <header> <ixt-menu src="./../assets/menu.json" brandName="Your Brand" brandLogo="./../assets/logo.png" brandLink="/" variant="default" [showSearch]="true" searchPlaceholder="Search products..." (searchSubmitted)="onSearch($event)"> </ixt-menu> </header> <section> <ixt-tabset> <ixt-tab title="diagrams"> <ixt-tabset> <ixt-tab title="Clazz"> <ixt-clazz></ixt-clazz> </ixt-tab> <ixt-tab title="Sequence"> <ixt-diagram></ixt-diagram> </ixt-tab> <ixt-tab title="viewport"> <ixt-viewport></ixt-viewport> </ixt-tab> <ixt-tab title="cavas"> <ixt-canvas></ixt-canvas> </ixt-tab> <ixt-tab title="EBNF"> <ixt-ebnf></ixt-ebnf> </ixt-tab> <ixt-tab title="ERD"> <ixt-erd></ixt-erd> </ixt-tab> <ixt-tab title="Network"> <ixt-network></ixt-network> </ixt-tab> <ixt-tab title="Flow"> <ixt-flow></ixt-flow> </ixt-tab> <ixt-tab title="Gannt"> <gannt-diagram></gannt-diagram> </ixt-tab> <ixt-tab title="Sankey"> <ixt-sankey></ixt-sankey> </ixt-tab> <ixt-tab title="Wireframe"> <ixt-wireframe></ixt-wireframe> </ixt-tab> </ixt-tabset> </ixt-tab> <ixt-tab title="D3 Geo"> <ixt-map [width]="'100%'" [height]="'80%'" scale="1" translate="0,0"> <ixt-layer src="./../assets/countries.geojson" stroke="black" fill="gray"></ixt-layer> <ixt-layer src="./../assets/flights.minified.geojson" stroke="red" fill="none" (click)="select($event)"> properties.airlineIata === 'F9' </ixt-layer> <ixt-layer src="./../assets/flights.minified.geojson" stroke="green" fill="none" (click)="select($event)"> properties.airlineIata === 'NK' </ixt-layer> <ixt-layer src="./../assets/lakes.geojson" stroke="black" fill="blue" (click)="select($event)"></ixt-layer> <ixt-layer src="./../assets/rivers.geojson" stroke="purple" fill="none" (hover)="highlight($event)"></ixt-layer> </ixt-map> </ixt-tab> <ixt-tab title="Buttons"> <div class="button-showcase"> <!-- Size Variants --> <div class="section"> <h4>Size Variants</h4> <div class="button-row"> <ixt-button variant="primary" size="sm">Small</ixt-button> <ixt-button variant="primary" size="md">Medium</ixt-button> <ixt-button variant="primary" size="lg">Large</ixt-button> </div> </div> <!-- Theme Variants --> <div class="section"> <h4>Theme Variants</h4> <div class="button-row"> <div class="theme"> <h5>Base Theme</h5> <div class="button-row"> <ixt-button variant="primary">Primary</ixt-button> <ixt-button variant="secondary">Secondary</ixt-button> <ixt-button variant="danger">Danger</ixt-button> </div> </div> <div class="theme"> <h5>United Theme</h5> <div class="button-row"> <ixt-button variant="primary" [theme]="unitedThemeColors">Primary</ixt-button> <ixt-button variant="secondary" [theme]="unitedThemeColors">Secondary</ixt-button> <ixt-button variant="danger" [theme]="unitedThemeColors">Danger</ixt-button> </div> </div> </div> </div> <!-- Examples --> <div class="section"> <h4>Examples</h4> <div class="button-row"> <ixt-button *ngFor="let button of buttonDemos" [variant]="button.variant" [size]="button.size || 'md'" [theme]="button.theme || baseThemeColors" [disabled]="button.disabled" (onClick)="handleButtonClick(button.label)"> <span *ngIf="button.prefix" prefix>{{button.prefix}}</span> {{button.label}} <span *ngIf="button.suffix" suffix>{{button.suffix}}</span> </ixt-button> </div> </div> </div> </ixt-tab> <!-- Dialog Example --> <ixt-tab title="Dialog Example"> <div class="dialog-demo-container flex flex-col gap-4 p-4"> <!-- Service-based dialogs --> <div class="flex flex-col gap-2"> <h3 class="text-lg font-semibold">Service-based Dialogs</h3> <div class="flex flex-wrap gap-2"> <button (click)="showSuccessDialog()" class="px-4 py-2 bg-green-500 text-white rounded"> Success Dialog </button> </div> </div> </div> </ixt-tab> <ixt-tab title="Employee Form"> <form class="form-grid"> <h3>Personal Information</h3> <div class="field"> <label>First Name</label> <input type="text" [(ngModel)]="formData.firstName" name="firstName"> </div> <div class="field"> <label>Last Name</label> <input type="text" [(ngModel)]="formData.lastName" name="lastName"> </div> <div class="field"> <label>Email</label> <input type="email" [(ngModel)]="formData.email" name="email"> </div> <h3>Employment Details</h3> <div class="field"> <label>Department</label> <input type="text" [(ngModel)]="formData.department" name="department"> </div> <div class="field"> <label>Position</label> <input type="text" [(ngModel)]="formData.position" name="position"> </div> <div class="field"> <label>Start Date</label> <input type="date" [(ngModel)]="formData.hireDate" name="hireDate"> </div> <div class="actions"> <button type="button" (click)="employeeFormHandler.submitForm()">Save</button> <button type="button" (click)="employeeFormHandler.resetForm()">Cancel</button> </div> </form> </ixt-tab> <ixt-tab title="Calendar"> <ixt-calendar></ixt-calendar> </ixt-tab> <ixt-tab title="Standard Table"> <ixt-table [data]="tableAirportData" [columnConfigs]="tableColumnConfigs" *ngIf="tableAirportData.length"> </ixt-table> </ixt-tab> <ixt-tab title="IxtSplitPane"> <ixt-split-pane> <div class="left-pane"> <h2>Left</h2> </div> <div class="right-pane"> <h2>Right</h2> </div> </ixt-split-pane> </ixt-tab> <ixt-tab title="Panels"> <h2>Examples</h2> <div class="ixt-panel-container"> <div class="panel-grid"> <ixt-panel title="Basic Panel"> <div class="panel-content"> This is a basic panel with default settings (bordered=true, elevated=false) </div> </ixt-panel> <ixt-panel title="Elevated Panel" [elevated]="true" caption="With caption text"> <div class="panel-content"> This panel has elevation enabled, creating a shadow effect </div> </ixt-panel> <ixt-panel title="No Border Panel" [bordered]="false" [padding]="true"> <div class="panel-content"> This panel has borders disabled but keeps padding </div> </ixt-panel> <ixt-panel [bordered]="false" [padding]="false" [elevated]="false"> <div class="panel-content"> A minimal panel without title, borders, elevation or padding </div> </ixt-panel> </div> </div> </ixt-tab> </ixt-tabset> </section> <aside> <ixt-layer-manager [layers]="layerProvider.mapLayers" (layerChange)="layerManager.onLayerChange($event)" (layerOrderChange)="layerManager.onLayerOrderChange($event)"> </ixt-layer-manager> </aside> <footer>Footer</footer> </main> <app-lunch-form></app-lunch-form>
|   |   --- app.component.ts: import { Component, ViewChild, AfterViewInit } from '@angular/core'; import { IxtLayerProvider } from './layer/ixt-layer.provider'; import { IxtLayerManager } from './layer/ixt-layer.manager'; import { IxtTreeProvider } from './tree/ixt-tree.provider'; import { IxtTreeHandler } from './tree/ixt-tree.handler'; import { IxtExpressionProvider } from './expression/ixt-expression.provider'; import { IxtExpressionHelper } from './expression/ixt-expression.helper'; import { IxtEmployeeFormProvider } from './form/ixt-employee-form.provider'; import { IxtEmployeeFormHandler } from './form/ixt-employee-form.handler'; import { IxtTableProvider } from './table/ixt-table.provider'; import { IxtMenuProvider } from './menu/ixt-menu.provider'; import { AccordianDataService } from './accordion/accordion.data'; import { IxtDialogService } from 'src/components/ixt-dialog/ixt-dialog.service'; import { firstValueFrom } from 'rxjs'; import { NgForm } from '@angular/forms'; import { LunchFormComponent } from './lunch-form.component'; import { ThemeVariant, ThemeColors } from 'src/components/theme/theme.types'; import { baseThemeColors, unitedThemeColors } from 'src/components/theme/theme.colors'; // Add to existing AppComponent class export interface ButtonDemo { label: string; variant: ThemeVariant; size?: 'sm' | 'md' | 'lg'; theme?: ThemeColors; disabled: boolean; prefix?: string; suffix?: string; } @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'], providers: [ IxtLayerProvider, IxtLayerManager, IxtTreeProvider, IxtTreeHandler, IxtExpressionProvider, IxtExpressionHelper, IxtEmployeeFormProvider, IxtEmployeeFormHandler, IxtTableProvider, IxtMenuProvider ] }) export class AppComponent implements AfterViewInit { @ViewChild(LunchFormComponent, { static: true }) lunchForm!: LunchFormComponent; protected baseThemeColors = baseThemeColors; protected unitedThemeColors = unitedThemeColors; formData = this.employeeFormProvider.getCurrentForm(); tableAirportData: any[] = []; tableColumnConfigs = this.tableProvider.getAirportColumnConfigs(); accordionPanels = this.accordianDataService.getAccordianPanels(); constructor( private dialog: IxtDialogService, public layerProvider: IxtLayerProvider, public layerManager: IxtLayerManager, public treeProvider: IxtTreeProvider, public treeHandler: IxtTreeHandler, public expressionProvider: IxtExpressionProvider, public expressionHelper: IxtExpressionHelper, public employeeFormProvider: IxtEmployeeFormProvider, public employeeFormHandler: IxtEmployeeFormHandler, public tableProvider: IxtTableProvider, public menuProvider: IxtMenuProvider, private accordianDataService: AccordianDataService ) { } ngOnInit() { this.tableProvider.getAirportData().subscribe(data => { this.tableAirportData = data; }); } ngAfterViewInit() { } select(event: Event): void { console.log('Selected:', event); } highlight(event: Event): void { console.log('Highlighted:', event); } onSearch(searchTerm: string) { console.log('Search term:', searchTerm); } // Dialog examples using improved service ------------------------------------------------------ async showSuccessDialog() { console.log('Starting dialog test'); await this.dialog.success('Success123!', 'Success Dialog 456'); console.log('Dialog completed'); } buttonDemos: ButtonDemo[] = [ { label: 'Submit Form', variant: 'primary', size: 'lg', suffix: '→', disabled: false }, { label: 'Cancel', variant: 'secondary', size: 'lg', disabled: false }, { label: 'Delete Record', variant: 'danger', prefix: '⚠️', disabled: false }, { label: 'United Theme', variant: 'primary', theme: unitedThemeColors, size: 'lg', disabled: false }, { label: 'Processing...', variant: 'primary', disabled: true }, { label: 'View Details', variant: 'info', size: 'sm', disabled: false } ]; handleButtonClick(label: string) { console.log(`Button clicked: ${label}`); } }
|   |   --- app.module.ts: import { NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { HttpClientModule } from '@angular/common/http'; import { RouterModule } from '@angular/router'; // Import components individually since library isn't published yet import { IxtButtonModule } from 'src/components/ixt-button/ixt-button.module'; import { IxtDialogModule } from 'src/components/ixt-dialog/ixt-dialog.module'; import { IxtTableModule } from 'src/components/ixt-table/ixt-table.module'; import { IxtTabsetModule } from 'src/components/ixt-tabset/ixt-tabset.module'; // Fixed name import { IxtTabComponent } from 'src/components/ixt-tabset/ixt-tab.component'; // Added individual component import { IxtPanelModule } from 'src/components/ixt-panel/ixt-panel.module'; import { IxtMenuModule } from 'src/components/ixt-menu/ixt-menu.module'; import { IxtTreeModule } from 'src/components/ixt-tree/ixt-tree.module'; import { IxtAccordianModule } from 'src/components/ixt-accordian/ixt-accordian.module'; // Fixed path import { IxtCanvasModule } from 'src/components/ixt-canvas/ixt-canvas.module'; import { IxtViewportModule } from 'src/components/ixt-viewport/ixt-viewport.module'; import { IxtExpressionBuilderModule } from 'src/components/ixt-expression-builder/ixt-expression-builder.module'; import { IxtMapModule } from 'src/components/ixt-map/ixt-map.module'; import { IxtLayerModule } from 'src/components/ixt-map/ixt-layer.module'; import { IxtLayerManagerModule } from 'src/components/ixt-layer-manager/ixt-layer-manager.module'; import { IxtSplitPaneModule } from 'src/components/ixt-splitpane/ixt-split-pane.module'; import { IxtCalendarModule } from 'src/components/ixt-calendar/ixt-calendar.module'; // Diagram Modules import { IxtDiagramModule } from 'src/components/ixt-diagram/ixt-diagram.module'; import { IxtClazzModule } from 'src/components/ixt-diagram/types/clazz/ixt-clazz.module'; import { IxtDeploymentModule } from 'src/components/ixt-diagram/types/deployment/ixt-deployment.module'; import { IxtEbnfModule } from 'src/components/ixt-diagram/types/EBNF/ixt-ebnf.module'; // Fixed path import { IxtFlowModule } from 'src/components/ixt-diagram/types/flow/ixt-flow.module'; import { IxtGanntModule } from 'src/components/ixt-diagram/types/gannt/gannt.module'; import { IxtNetworkModule } from 'src/components/ixt-diagram/types/network/ixt-network.module'; import { IxtSankeyModule } from 'src/components/ixt-diagram/types/sankey/ixt-sankey.module'; import { IxtWireframeModule } from 'src/components/ixt-diagram/types/wireframe/ixt-wireframe.module'; // Components import { AppComponent } from './app.component'; import { LunchFormComponent } from './lunch-form.component'; // Providers import { IxtEmployeeFormHandler } from './form/ixt-employee-form.handler'; import { IxtEmployeeFormProvider } from './form/ixt-employee-form.provider'; import { IxtExpressionHelper } from './expression/ixt-expression.helper'; import { IxtExpressionProvider } from './expression/ixt-expression.provider'; import { IxtLayerManager } from './layer/ixt-layer.manager'; import { IxtLayerProvider } from './layer/ixt-layer.provider'; import { IxtTreeHandler } from './tree/ixt-tree.handler'; import { IxtTableProvider } from './table/ixt-table.provider'; import { IxtTreeProvider } from './tree/ixt-tree.provider'; @NgModule({ declarations: [ AppComponent, LunchFormComponent ], imports: [ // Angular Core Modules BrowserModule, BrowserAnimationsModule, FormsModule, ReactiveFormsModule, HttpClientModule, RouterModule.forRoot([]), // Ixtlan Modules IxtAccordianModule, IxtButtonModule, IxtCalendarModule, IxtCanvasModule, IxtDialogModule, IxtDiagramModule, IxtExpressionBuilderModule, IxtLayerModule, // Added Layer module IxtLayerManagerModule, IxtMapModule, IxtMenuModule, IxtPanelModule, IxtSplitPaneModule, IxtTableModule, IxtTreeModule, IxtTabsetModule, IxtViewportModule, // Diagram Type Modules IxtClazzModule, IxtDeploymentModule, IxtEbnfModule, IxtFlowModule, IxtGanntModule, IxtNetworkModule, IxtSankeyModule, IxtWireframeModule ], providers: [ IxtEmployeeFormHandler, IxtEmployeeFormProvider, IxtExpressionHelper, IxtExpressionProvider, IxtLayerManager, IxtLayerProvider, IxtTreeHandler, IxtTreeProvider, IxtTableProvider ], schemas: [ CUSTOM_ELEMENTS_SCHEMA // Added schema for custom elements ], bootstrap: [AppComponent] }) export class AppModule { }
|   |   --- lunch-form.component.html: <button (click)="showLunchOrderDialog()" class="place-order px-4 py-2 rounded"> Place Lunch Order </button> <ng-template #lunchOrderTemplate> <form #orderForm="ngForm"> <div class="space-y-4"> <div class="form-group"> <label class="block text-sm font-medium text-gray-700">Sandwich:</label> <select name="sandwich" [(ngModel)]="orderData.sandwich" required #sandwichField="ngModel" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" > <option value="">Select a sandwich</option> <option>grilled cheese</option> <option>roast beef</option> <option>hamburger</option> </select> <div *ngIf="sandwichField.invalid && sandwichField.touched" class="text-red-500 text-sm"> Please select a sandwich </div> </div> <div class="form-group"> <label class="block text-sm font-medium text-gray-700">Side:</label> <select name="side" [(ngModel)]="orderData.side" required #sideField="ngModel" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" > <option value="">Select a side</option> <option>French fries</option> <option>Onion Rings</option> <option>Salad</option> </select> <div *ngIf="sideField.invalid && sideField.touched" class="text-red-500 text-sm"> Please select a side </div> </div> <div class="form-group"> <label class="block text-sm font-medium text-gray-700">Drink:</label> <select name="drink" [(ngModel)]="orderData.drink" required #drinkField="ngModel" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" > <option value="">Select a drink</option> <option>Coke</option> <option>Coffee</option> <option>Juice</option> </select> <div *ngIf="drinkField.invalid && drinkField.touched" class="text-red-500 text-sm"> Please select a drink </div> </div> <div class="form-group"> <label class="block text-sm font-medium text-gray-700">Name for order:</label> <input name="customerName" [(ngModel)]="orderData.customerName" required minlength="2" #nameField="ngModel" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" placeholder="Enter your name" > <div *ngIf="nameField.invalid && nameField.touched" class="text-red-500 text-sm"> Please enter a name (minimum 2 characters) </div> </div> <div class="form-group"> <label>Takeout?</label> <div> <input type="checkbox" name="isTakeout" [(ngModel)]="orderData.isTakeout" > </div> </div> <!-- Debug info during development --> <div class="mt-4 text-sm text-gray-500"> Form Valid: {{orderForm.valid}} <br> Form Values: {{orderData | json}} </div> </div> </form> </ng-template>
|   |   --- lunch-form.component.ts: import { Component, ViewChild, TemplateRef, OnInit, EventEmitter, Output } from '@angular/core'; import { NgForm } from '@angular/forms'; import { IxtDialogService } from 'src/components/ixt-dialog/ixt-dialog.service'; import { firstValueFrom } from 'rxjs'; interface LunchOrder { sandwich: string; side: string; drink: string; customerName: string; isTakeout: boolean; } @Component({ selector: 'app-lunch-form', templateUrl: './lunch-form.component.html', styleUrls: ['./lunch-form.component.scss'], }) export class LunchFormComponent implements OnInit { @Output() init = new EventEmitter<LunchFormComponent>(); @ViewChild('lunchOrderTemplate') lunchOrderTemplate!: TemplateRef<any>; @ViewChild('orderForm') orderForm!: NgForm; orderData: LunchOrder = { sandwich: '', side: '', drink: '', customerName: '', isTakeout: false }; constructor(private dialogService: IxtDialogService) { } ngOnInit(): void { this.init.emit(this); } private getFormData(): LunchOrder { return { sandwich: this.orderData.sandwich, // Bound to the "Sandwich" field side: this.orderData.side, // Bound to the "Side" field drink: this.orderData.drink, // Bound to the "Drink" field customerName: this.orderData.customerName, // Bound to the "Name for order" field isTakeout: this.orderData.isTakeout, // Bound to the "Takeout?" checkbox }; } private resetForm(): void { // Reset the form fields to default values this.orderData = { sandwich: '', side: '', drink: '', customerName: '', isTakeout: false, }; // Reset the form state if it exists if (this.orderForm) { this.orderForm.resetForm(this.orderData); } } public showLunchOrderDialog(): Promise<{ status: 'OK' | 'Cancel'; data?: LunchOrder }> { // Reset form data and state this.resetForm(); return new Promise((resolve) => { // this.dialogService.template('Lunch Order', this.lunchOrderTemplate, { // buttons: [ // { // text: 'Place Order', // action: () => { // if (this.orderForm?.valid) { // const formData = this.getFormData(); // Get the form data // resolve({ status: 'OK', data: formData }); // Resolve with structured success result // return formData; // Required by the dialogService to process the action // } else { // this.dialogService.warning('Please fill out all required fields'); // return false; // Prevent dialog from closing if validation fails // } // }, // close: true, // Ensure dialog closes // }, // { // text: 'Cancel', // action: () => { // resolve({ status: 'Cancel' }); // Resolve with cancel status // }, // close: true, // Ensure dialog closes // }, // ], // }).subscribe({ // complete: () => { // console.log('Dialog closed'); // Ensure the dialog completes properly // }, // }); }); } }
|   +-- assets
|   |   --- .gitkeep: <empty file>
|   |   --- logo.png: <image file>
|   |   --- logo2.png: <image file>
|   +-- components
|   |   +-- ixt-accordian
|   |   |   --- ixt-accordian.component.html: <!-- ixt-accordian.component.html --> <div class="ixt-accordion"> <div class="accordion-panel" *ngFor="let panel of panels; let i = index"> <div class="panel-header" (click)="togglePanel(i)"> <span class="panel-title">{{panel.title}}</span> <span class="material-icons" [class.open]="panel.isOpen"> expand_more </span> </div> <div class="panel-content" [@slideInOut]="panel.isOpen ? 'open' : 'closed'"> {{panel.content}} </div> </div> </div>
|   |   |   --- ixt-accordian.component.ts: // ixt-accordian.component.ts import { Component, Input } from '@angular/core'; import { animate, state, style, transition, trigger } from '@angular/animations'; export interface AccordionPanel { title: string; content: string; isOpen?: boolean; } @Component({ selector: 'ixt-accordian', templateUrl: './ixt-accordian.component.html', styleUrls: ['./ixt-accordian.component.scss'], animations: [ trigger('slideInOut', [ state('open', style({ height: '*', opacity: 1 })), state('closed', style({ height: '0', opacity: 0 })), transition('closed <=> open', [ animate('200ms ease-in-out') ]) ]) ] }) export class IxtAccordianComponent { @Input() panels: AccordionPanel[] = []; @Input() allowMultiple = false; togglePanel(index: number): void { if (!this.allowMultiple) { this.panels.forEach((panel, i) => { if (i !== index) panel.isOpen = false; }); } this.panels[index].isOpen = !this.panels[index].isOpen; } }
|   |   |   --- ixt-accordian.index.ts: // src/components/ixt-accordian/ixt-accordian.index.ts export * from './ixt-accordian.component'; export * from './ixt-accordian.module'; export interface AccordionPanel { title: string; content: string; isOpen?: boolean; }
|   |   |   --- ixt-accordian.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { IxtAccordianComponent } from './ixt-accordian.component'; @NgModule({ declarations: [ IxtAccordianComponent ], imports: [ CommonModule, BrowserAnimationsModule ], exports: [ IxtAccordianComponent ] }) export class IxtAccordianModule { }
|   |   +-- ixt-breadcrumb
|   |   |   --- breakcrumb.component.html: <empty file>
|   |   |   --- breakcrumb.component.ts: import { Component, OnInit } from '@angular/core'; import { BreadcrumbService, Breadcrumb } from './breadcrumb.service'; @Component({ selector: 'app-breadcrumb', template: ` <nav *ngIf="breadcrumbs.length > 0"> <ul> <li *ngFor="let breadcrumb of breadcrumbs"> <a [routerLink]="breadcrumb.url">{{ breadcrumb.label }}</a> </li> </ul> </nav> `, styles: [] }) export class BreadcrumbComponent implements OnInit { breadcrumbs: Breadcrumb[] = []; constructor(private breadcrumbService: BreadcrumbService) {} ngOnInit() { this.breadcrumbService.breadcrumbs$.subscribe(breadcrumbs => { this.breadcrumbs = breadcrumbs; }); } }
|   |   +-- ixt-button
|   |   |   --- ixt-button.component.html: <button [type]="type" [disabled]="disabled" [attr.aria-disabled]="disabled" [attr.aria-busy]="loading"> <!-- Loading Spinner --> <span *ngIf="loading" class="ixt-button__spinner" aria-hidden="true"> <svg class="animate-spin h-5 w-5" viewBox="0 0 24 24"> <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none"/> <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"/> </svg> </span> <!-- Button Content --> <span class="ixt-button__content" [class.invisible]="loading"> <ng-content></ng-content> </span> </button>
|   |   |   --- ixt-button.component.ts: // button.component.ts import { Component, Input, Output, EventEmitter } from '@angular/core'; import { baseThemeColors } from '../theme/theme.colors'; import { ThemeVariant, ThemeColors } from '../theme/theme.types'; export type ButtonSize = 'sm' | 'md' | 'lg'; @Component({ selector: 'ixt-button', template: ` <button [attr.type]="type" [disabled]="disabled" [ngStyle]="buttonStyles" (click)="onClick.emit($event)" (mouseenter)="isHovered = true" (mouseleave)="isHovered = false" (mousedown)="isActive = true" (mouseup)="isActive = false" (blur)="isActive = false; isHovered = false" > <ng-content select="[prefix]"></ng-content> <ng-content></ng-content> <ng-content select="[suffix]"></ng-content> </button> `, styles: [` :host { display: inline-block; } button { font-family: inherit; border: none; border-radius: 4px; cursor: pointer; display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; transition: background-color 0.2s, opacity 0.2s; &:disabled { cursor: not-allowed; opacity: 0.65; } } `] }) export class IxtButtonComponent { @Input() variant: ThemeVariant = 'primary'; @Input() size: ButtonSize = 'md'; @Input() disabled = false; @Input() type: 'button' | 'submit' | 'reset' = 'button'; @Input() theme: ThemeColors = baseThemeColors; @Output() onClick = new EventEmitter<MouseEvent>(); protected isHovered = false; protected isActive = false; protected get buttonStyles(): Record<string, string> { const variantColors = this.theme[this.variant]; let backgroundColor = variantColors.base; if (this.isActive) { backgroundColor = variantColors.active; } else if (this.isHovered) { backgroundColor = variantColors.hover; } const padding = { sm: '0.25rem 0.5rem', md: '0.5rem 1rem', lg: '0.75rem 1.5rem' }[this.size]; const fontSize = { sm: '0.875rem', md: '1rem', lg: '1.125rem' }[this.size]; return { backgroundColor, color: variantColors.text, padding, fontSize }; } }
|   |   |   --- ixt-button.index.ts: // index.ts export { IxtButtonComponent } from './ixt-button.component'; export { IxtButtonModule } from './ixt-button.module'; export type { ButtonSize } from './ixt-button.component';
|   |   |   --- ixt-button.module.ts: // ixt-button.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { MatButtonModule } from '@angular/material/button'; import { MatIconModule } from '@angular/material/icon'; import { IxtButtonComponent } from './ixt-button.component'; @NgModule({ declarations: [IxtButtonComponent], imports: [ CommonModule, MatButtonModule, MatIconModule, ], exports: [IxtButtonComponent] }) export class IxtButtonModule { }
|   |   +-- ixt-calendar
|   |   |   +-- calculators
|   |   |   |   --- indian-holidays.ts: import { Holiday } from "../models/holiday.interface"; import { HolidayCalculator } from '../models/holiday-calculator'; export class IndianHolidayCalculator extends HolidayCalculator { getHolidays(year: number): Holiday[] { return [ { name: "Diwali", date: this.calculateDiwali(year), type: 'cultural' }, { name: "Holi", date: this.calculateHoli(year), type: 'cultural' }, { name: "Republic Day", date: new Date(year, 0, 26), type: 'cultural' }, { name: "Independence Day", date: new Date(year, 7, 15), type: 'cultural' } ]; } private calculateDiwali(year: number): Date { // Placeholder - needs proper lunar calendar calculation return new Date(year, 9, 24); } private calculateHoli(year: number): Date { // Placeholder - needs proper lunar calendar calculation return new Date(year, 2, 8); } }
|   |   |   |   --- islamic-holidays.ts: import { Holiday } from "../models/holiday.interface"; import { HolidayCalculator } from '../models/holiday-calculator'; export class IslamicHolidayCalculator extends HolidayCalculator { getHolidays(year: number): Holiday[] { // Note: Islamic holidays follow lunar calendar - this needs more complex calculation return [ { name: "Eid al-Fitr", date: this.calculateEidAlFitr(year), type: 'religious' }, { name: "Eid al-Adha", date: this.calculateEidAlAdha(year), type: 'religious' }, { name: "Islamic New Year", date: this.calculateIslamicNewYear(year), type: 'religious' } ]; } private calculateEidAlFitr(year: number): Date { // Placeholder - needs proper Islamic calendar calculation return new Date(year, 5, 15); } private calculateEidAlAdha(year: number): Date { // Placeholder - needs proper Islamic calendar calculation return new Date(year, 7, 22); } private calculateIslamicNewYear(year: number): Date { // Placeholder - needs proper Islamic calendar calculation return new Date(year, 8, 1); } }
|   |   |   |   --- usa-holidays.ts: import { Holiday } from '../models/holiday.interface'; import { HolidayCalculator } from '../models/holiday-calculator'; export class USAHolidayCalculator extends HolidayCalculator { getHolidays(year: number): Holiday[] { return [ { name: "New Year's Day", date: new Date(year, 0, 1), type: 'federal' }, { name: "Martin Luther King Jr. Day", date: this.nthWeekdayOfMonth(year, 0, 1, 3), type: 'federal' }, { name: "Presidents Day", date: this.nthWeekdayOfMonth(year, 1, 1, 3), type: 'federal' }, { name: "Easter", date: this.calculateEaster(year), type: 'federal' }, { name: "Memorial Day", date: this.lastWeekdayOfMonth(year, 4, 1), type: 'federal' }, { name: "Independence Day", date: new Date(year, 6, 4), type: 'federal' }, { name: "Labor Day", date: this.nthWeekdayOfMonth(year, 8, 1, 1), type: 'federal' }, { name: "Columbus Day", date: this.nthWeekdayOfMonth(year, 9, 1, 2), type: 'federal' }, { name: "Veterans Day", date: new Date(year, 10, 11), type: 'federal' }, { name: "Thanksgiving", date: this.nthWeekdayOfMonth(year, 10, 4, 4), type: 'federal' }, { name: "Christmas", date: new Date(year, 11, 25), type: 'federal' } ]; } private calculateEaster(year: number): Date { const a = year % 19; const b = Math.floor(year / 100); const c = year % 100; const d = Math.floor(b / 4); const e = b % 4; const f = Math.floor((b + 8) / 25); const g = Math.floor((b - f + 1) / 3); const h = (19 * a + b - d - g + 15) % 30; const i = Math.floor(c / 4); const k = c % 4; const l = (32 + 2 * e + 2 * i - h - k) % 7; const m = Math.floor((a + 11 * h + 22 * l) / 451); const month = Math.floor((h + l - 7 * m + 114) / 31) - 1; const day = ((h + l - 7 * m + 114) % 31) + 1; return new Date(year, month, day); } }
|   |   |   +-- models
|   |   |   |   --- holiday-calculator.ts: import { Holiday } from "./holiday.interface"; export abstract class HolidayCalculator { abstract getHolidays(year: number): Holiday[]; protected nthWeekdayOfMonth(year: number, month: number, weekday: number, n: number): Date { const date = new Date(year, month, 1); while (date.getDay() !== weekday) { date.setDate(date.getDate() + 1); } date.setDate(date.getDate() + (n - 1) * 7); return date; } protected lastWeekdayOfMonth(year: number, month: number, weekday: number): Date { const date = new Date(year, month + 1, 0); while (date.getDay() !== weekday) { date.setDate(date.getDate() - 1); } return date; } }
|   |   |   |   --- holiday.interface.ts: export interface Holiday { name: string; date: Date; type: 'federal' | 'religious' | 'cultural'; }
|   |   |   --- ixt-calendar.component.html: <div class="calendar-container"> <div class="calendar-controls"> <button (click)="previousMonth()">&lt;</button> <select [formControl]="monthControl"> <option *ngFor="let month of months; let i = index" [value]="i"> {{month}} </option> </select> <input type="number" [formControl]="yearControl" [min]="0" [max]="2100" (blur)="validateYear()" > <button (click)="nextMonth()">&gt;</button> </div> <div class="calendar-grid"> <div class="weekday-header" *ngFor="let day of weekDays">{{day}}</div> <div *ngFor="let day of calendarDays" class="calendar-day" [class.weekend]="day.isWeekend" [class.holiday]="day.holidays.length > 0" > <div class="date">{{day.date.getDate()}}</div> <div class="holiday-name" *ngFor="let holiday of day.holidays"> {{holiday.name}} </div> </div> </div> </div>
|   |   |   --- ixt-calendar.component.ts: import { Component, OnInit } from '@angular/core'; import { FormControl } from '@angular/forms'; import { CalendarDay } from './ixt-calendar.interfaces'; import { USAHolidayCalculator } from './calculators/usa-holidays'; import { IndianHolidayCalculator } from './calculators/indian-holidays'; import { IslamicHolidayCalculator } from './calculators/islamic-holidays'; import { Holiday } from './models/holiday.interface'; @Component({ selector: 'ixt-calendar', templateUrl: './ixt-calendar.component.html', styleUrls: ['./ixt-calendar.component.scss'] }) export class IxtCalendarComponent implements OnInit { private holidayCalculators = [ new USAHolidayCalculator(), new IslamicHolidayCalculator(), new IndianHolidayCalculator() ]; months = [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ]; weekDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']; calendarDays: CalendarDay[] = []; monthControl = new FormControl(0); yearControl = new FormControl(new Date().getFullYear()); private holidays: Holiday[] = []; ngOnInit() { this.monthControl.valueChanges.subscribe(() => this.generateCalendar()); this.yearControl.valueChanges.subscribe(() => { this.updateHolidays(); this.generateCalendar(); }); this.updateHolidays(); this.generateCalendar(); } private updateHolidays() { this.holidays = this.holidayCalculators.flatMap( calc => calc.getHolidays(this.yearControl.value!) ); } generateCalendar() { const year = this.yearControl.value!; const month = this.monthControl.value!; const firstDay = new Date(year, month, 1); const lastDay = new Date(year, month + 1, 0); this.calendarDays = []; // Add padding days from previous month for (let i = 0; i < firstDay.getDay(); i++) { const date = new Date(year, month, -i); this.calendarDays.unshift(this.createCalendarDay(date)); } // Add days of current month for (let date = new Date(firstDay); date <= lastDay; date.setDate(date.getDate() + 1)) { this.calendarDays.push(this.createCalendarDay(new Date(date))); } // Add padding days from next month const remainingDays = 42 - this.calendarDays.length; for (let i = 1; i <= remainingDays; i++) { const date = new Date(year, month + 1, i); this.calendarDays.push(this.createCalendarDay(date)); } } private createCalendarDay(date: Date): CalendarDay { return { date, isWeekend: date.getDay() === 0 || date.getDay() === 6, holidays: this.holidays.filter(h => h.date.getDate() === date.getDate() && h.date.getMonth() === date.getMonth() ) }; } previousMonth() { if (this.monthControl.value === 0) { this.monthControl.setValue(11); this.yearControl.setValue(this.yearControl.value! - 1); } else { this.monthControl.setValue(this.monthControl.value! - 1); } } nextMonth() { if (this.monthControl.value === 11) { this.monthControl.setValue(0); this.yearControl.setValue(this.yearControl.value! + 1); } else { this.monthControl.setValue(this.monthControl.value! + 1); } } validateYear() { const year = this.yearControl.value!; if (year < 0) this.yearControl.setValue(0); if (year > 2100) this.yearControl.setValue(2100); } }
|   |   |   --- ixt-calendar.index.ts: // ixt-calendar.index.ts export * from './ixt-calendar.component'; export * from './ixt-calendar.module'; export interface CalendarDay { date: Date; isWeekend: boolean; holidays: Holiday[]; } export interface Holiday { name: string; date: Date; type: 'federal' | 'religious' | 'cultural'; } export * from './calculators/usa-holidays'; export * from './calculators/indian-holidays'; export * from './calculators/islamic-holidays';
|   |   |   --- ixt-calendar.interfaces.ts: import { Holiday } from "./models/holiday.interface"; export interface CalendarDay { date: Date; isWeekend: boolean; holidays: Holiday[]; }
|   |   |   --- ixt-calendar.module.ts: // ixt-calendar.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { ReactiveFormsModule } from '@angular/forms'; import { IxtCalendarComponent } from './ixt-calendar.component'; @NgModule({ declarations: [IxtCalendarComponent], imports: [CommonModule, ReactiveFormsModule], exports: [IxtCalendarComponent] }) export class IxtCalendarModule { }
|   |   +-- ixt-canvas
|   |   |   --- ixt-canvas.component.html: IxtCanvas Template <!-- ixt-canvas.component.html --> <div class="canvas-container"> <canvas #canvas></canvas> </div>
|   |   |   --- ixt-canvas.component.ts: // ixt-canvas.component.ts import { Component, ElementRef, ViewChild, AfterViewInit, HostListener } from '@angular/core'; interface Point { x: number; y: number; } @Component({ selector: 'ixt-canvas', templateUrl: './ixt-canvas.component.html', styleUrls: ['./ixt-canvas.component.scss'] }) export class IxtCanvasComponent implements AfterViewInit { @ViewChild('canvas') private canvasRef!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; private isDrawing = false; private lastPoint: Point | null = null; // Drawing settings private lineWidth = 2; private strokeStyle = '#000000'; ngAfterViewInit() { const canvas = this.canvasRef.nativeElement; this.ctx = canvas.getContext('2d')!; // Set canvas size to match container this.resizeCanvas(); // Initialize canvas settings this.initializeCanvas(); } @HostListener('window:resize') private resizeCanvas() { const canvas = this.canvasRef.nativeElement; canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; this.initializeCanvas(); } private initializeCanvas() { this.ctx.lineWidth = this.lineWidth; this.ctx.strokeStyle = this.strokeStyle; this.ctx.lineCap = 'round'; this.ctx.lineJoin = 'round'; } @HostListener('mousedown', ['$event']) onMouseDown(event: MouseEvent) { this.isDrawing = true; this.lastPoint = this.getMousePos(event); } @HostListener('mousemove', ['$event']) onMouseMove(event: MouseEvent) { if (!this.isDrawing) return; const currentPoint = this.getMousePos(event); this.draw(this.lastPoint!, currentPoint); this.lastPoint = currentPoint; } @HostListener('mouseup') @HostListener('mouseleave') onMouseUp() { this.isDrawing = false; this.lastPoint = null; } private getMousePos(event: MouseEvent): Point { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); return { x: event.clientX - rect.left, y: event.clientY - rect.top }; } private draw(start: Point, end: Point) { this.ctx.beginPath(); this.ctx.moveTo(start.x, start.y); this.ctx.lineTo(end.x, end.y); this.ctx.stroke(); this.ctx.closePath(); } // Public methods for external control setColor(color: string) { this.strokeStyle = color; this.ctx.strokeStyle = color; } setLineWidth(width: number) { this.lineWidth = width; this.ctx.lineWidth = width; } clear() { const canvas = this.canvasRef.nativeElement; this.ctx.clearRect(0, 0, canvas.width, canvas.height); } }
|   |   |   --- ixt-canvas.index.ts: // ixt-canvas.index.ts export * from './ixt-canvas.component'; export * from './ixt-canvas.module'; // You might want to export interfaces/types if they're needed elsewhere export interface DrawingConfig { color?: string; lineWidth?: number; }
|   |   |   --- ixt-canvas.module.ts: // ixt-canvas.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtCanvasComponent } from './ixt-canvas.component'; @NgModule({ declarations: [ IxtCanvasComponent ], imports: [ CommonModule ], exports: [ IxtCanvasComponent ] }) export class IxtCanvasModule { }
|   |   +-- ixt-chart
|   |   |   +-- types
|   |   |   |   +-- area
|   |   |   |   |   --- ixt-area.chart.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   |   --- ixt-area.chart.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   +-- bar
|   |   |   |   |   --- ixt-bar.chart.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   |   --- ixt-bar.chart.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   +-- line
|   |   |   |   |   --- ixt-line.chart.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   |   --- ixt-line.chart.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   +-- sankey
|   |   |   |   |   --- ixt-sankey.chart.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   |   --- ixt-sankey.chart.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   \-- scatter
|   |   |   |       --- ixt-scatter.chart.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |       --- ixt-scatter.chart.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   --- ixt-chart.component.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   --- ixt-chart.component.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   +-- ixt-colorpalette
|   |   |   --- ixt-canvas.component.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   --- ixt-canvas.component.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   +-- ixt-diagram
|   |   |   +-- types
|   |   |   |   +-- EBNF
|   |   |   |   |   --- ixt-ebnf.diagram.html: <empty file>
|   |   |   |   |   --- ixt-ebnf.diagram.ts: // ixt-ebnf.diagram.ts import { Component, ElementRef, OnInit, ViewChild } from '@angular/core'; import { Point } from './ixt-ebnf.types'; interface Node { id: string; x: number; y: number; width: number; height: number; isDragging: boolean; type: 'terminal' | 'nonterminal' | 'operator'; label: string; } interface Edge { from: string; to: string; type: 'sequence' | 'alternative' | 'optional' | 'repetition'; } @Component({ selector: 'ixt-ebnf', template: ` <div class="diagram-container"> <canvas #canvas (mousedown)="onMouseDown($event)" (mousemove)="onMouseMove($event)" (mouseup)="onMouseUp()" [width]="width" [height]="height"> </canvas> <button class="auto-layout-btn" (click)="autoLayout()">Auto Layout</button> </div> `, styles: [` .diagram-container { position: relative; border: 1px solid #ccc; } .auto-layout-btn { position: absolute; top: 10px; right: 10px; padding: 8px 16px; background: #4a90e2; color: white; border: none; border-radius: 4px; cursor: pointer; } `] }) export class IxtEbnfDiagram implements OnInit { @ViewChild('canvas', { static: true }) canvasRef!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; width = 1200; height = 800; nodes: Node[] = [ // Git command grammar nodes { id: 'git', x: 50, y: 50, width: 80, height: 40, isDragging: false, type: 'terminal', label: 'git' }, { id: 'command', x: 200, y: 50, width: 120, height: 40, isDragging: false, type: 'nonterminal', label: 'command' }, { id: 'commit', x: 400, y: 50, width: 100, height: 40, isDragging: false, type: 'terminal', label: 'commit' }, { id: 'push', x: 400, y: 150, width: 100, height: 40, isDragging: false, type: 'terminal', label: 'push' }, { id: 'pull', x: 400, y: 250, width: 100, height: 40, isDragging: false, type: 'terminal', label: 'pull' }, { id: 'branch', x: 400, y: 350, width: 100, height: 40, isDragging: false, type: 'terminal', label: 'branch' }, { id: 'options', x: 600, y: 50, width: 120, height: 40, isDragging: false, type: 'nonterminal', label: 'options' }, { id: 'args', x: 800, y: 50, width: 100, height: 40, isDragging: false, type: 'nonterminal', label: 'args' } ]; edges: Edge[] = [ { from: 'git', to: 'command', type: 'sequence' }, { from: 'command', to: 'commit', type: 'alternative' }, { from: 'command', to: 'push', type: 'alternative' }, { from: 'command', to: 'pull', type: 'alternative' }, { from: 'command', to: 'branch', type: 'alternative' }, { from: 'commit', to: 'options', type: 'sequence' }, { from: 'options', to: 'args', type: 'optional' } ]; private draggedNode: Node | null = null; private lastX = 0; private lastY = 0; ngOnInit() { this.ctx = this.canvasRef.nativeElement.getContext('2d')!; this.draw(); } private drawNodes() { this.nodes.forEach(node => { this.ctx.beginPath(); // Different styles for different node types switch (node.type) { case 'terminal': this.ctx.rect(node.x, node.y, node.width, node.height); break; case 'nonterminal': this.roundRect(node.x, node.y, node.width, node.height, 10); break; case 'operator': this.ctx.ellipse( node.x + node.width/2, node.y + node.height/2, node.width/2, node.height/2, 0, 0, Math.PI * 2 ); break; } this.ctx.strokeStyle = '#333'; this.ctx.lineWidth = 2; this.ctx.stroke(); // Draw label this.ctx.fillStyle = '#000'; this.ctx.font = '14px Arial'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; this.ctx.fillText( node.label, node.x + node.width/2, node.y + node.height/2 ); }); } private drawEdges() { this.edges.forEach(edge => { const fromNode = this.nodes.find(n => n.id === edge.from)!; const toNode = this.nodes.find(n => n.id === edge.to)!; // Calculate connection points using smart routing const points = this.calculateEdgePoints(fromNode, toNode); this.ctx.beginPath(); this.ctx.moveTo(points[0].x, points[0].y); // Draw curved lines for better aesthetics if (points.length === 3) { this.ctx.quadraticCurveTo( points[1].x, points[1].y, points[2].x, points[2].y ); } this.ctx.strokeStyle = '#666'; this.ctx.lineWidth = 1.5; this.ctx.stroke(); // Draw arrow this.drawArrow(points[points.length-2], points[points.length-1]); // Draw edge type indicator if (edge.type !== 'sequence') { const midPoint = this.getMidPoint(points); this.drawEdgeType(edge.type, midPoint); } }); } private calculateEdgePoints(from: Node, to: Node) { // Smart routing algorithm to avoid crossing nodes const points = []; const fromCenter = { x: from.x + from.width/2, y: from.y + from.height/2 }; const toCenter = { x: to.x + to.width/2, y: to.y + to.height/2 }; // Add intermediate points for better routing if (Math.abs(fromCenter.y - toCenter.y) > 100) { points.push( { x: fromCenter.x + from.width/2, y: fromCenter.y }, { x: (fromCenter.x + toCenter.x)/2, y: fromCenter.y }, { x: (fromCenter.x + toCenter.x)/2, y: toCenter.y }, { x: toCenter.x - to.width/2, y: toCenter.y } ); } else { points.push( { x: fromCenter.x + from.width/2, y: fromCenter.y }, { x: (fromCenter.x + toCenter.x)/2, y: (fromCenter.y + toCenter.y)/2 }, { x: toCenter.x - to.width/2, y: toCenter.y } ); } return points; } private drawArrow(from: {x: number, y: number}, to: {x: number, y: number}) { const angle = Math.atan2(to.y - from.y, to.x - from.x); const length = 10; this.ctx.beginPath(); this.ctx.moveTo(to.x, to.y); this.ctx.lineTo( to.x - length * Math.cos(angle - Math.PI/6), to.y - length * Math.sin(angle - Math.PI/6) ); this.ctx.moveTo(to.x, to.y); this.ctx.lineTo( to.x - length * Math.cos(angle + Math.PI/6), to.y - length * Math.sin(angle + Math.PI/6) ); this.ctx.stroke(); } private drawEdgeType(type: string, point: {x: number, y: number}) { this.ctx.fillStyle = '#fff'; this.ctx.strokeStyle = '#666'; switch (type) { case 'alternative': this.ctx.beginPath(); this.ctx.arc(point.x, point.y, 8, 0, Math.PI * 2); this.ctx.fill(); this.ctx.stroke(); this.ctx.fillStyle = '#666'; this.ctx.fillText('|', point.x, point.y + 1); break; case 'optional': this.ctx.beginPath(); this.ctx.arc(point.x, point.y, 8, 0, Math.PI * 2); this.ctx.fill(); this.ctx.stroke(); this.ctx.fillStyle = '#666'; this.ctx.fillText('?', point.x, point.y + 1); break; case 'repetition': this.ctx.beginPath(); this.ctx.arc(point.x, point.y, 8, 0, Math.PI * 2); this.ctx.fill(); this.ctx.stroke(); this.ctx.fillStyle = '#666'; this.ctx.fillText('*', point.x, point.y + 1); break; } } private roundRect(x: number, y: number, width: number, height: number, radius: number) { this.ctx.beginPath(); this.ctx.moveTo(x + radius, y); this.ctx.lineTo(x + width - radius, y); this.ctx.arcTo(x + width, y, x + width, y + radius, radius); this.ctx.lineTo(x + width, y + height - radius); this.ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius); this.ctx.lineTo(x + radius, y + height); this.ctx.arcTo(x, y + height, x, y + height - radius, radius); this.ctx.lineTo(x, y + radius); this.ctx.arcTo(x, y, x + radius, y, radius); this.ctx.closePath(); } onMouseDown(event: MouseEvent) { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; this.nodes.forEach(node => { if (x >= node.x && x <= node.x + node.width && y >= node.y && y <= node.y + node.height) { node.isDragging = true; this.draggedNode = node; this.lastX = x; this.lastY = y; } }); } onMouseMove(event: MouseEvent) { if (!this.draggedNode) return; const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; const dx = x - this.lastX; const dy = y - this.lastY; this.draggedNode.x += dx; this.draggedNode.y += dy; this.lastX = x; this.lastY = y; this.draw(); } onMouseUp() { if (this.draggedNode) { this.draggedNode.isDragging = false; this.draggedNode = null; } } autoLayout() { // Force-directed layout with hierarchical constraints const iterations = 100; const k = 100; // Spring constant const c = 200; // Repulsion constant for (let i = 0; i < iterations; i++) { // Calculate forces this.nodes.forEach(node1 => { let fx = 0; let fy = 0; // Repulsion between nodes this.nodes.forEach(node2 => { if (node1 !== node2) { const dx = node1.x - node2.x; const dy = node1.y - node2.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < 200) { fx += (c / (distance * distance)) * dx / distance; fy += (c / (distance * distance)) * dy / distance; } } }); // Spring forces for edges this.edges.forEach(edge => { if (edge.from === node1.id || edge.to === node1.id) { const other = this.nodes.find(n => n.id === (edge.from === node1.id ? edge.to : edge.from) )!; const dx = node1.x - other.x; const dy = node1.y - other.y; const distance = Math.sqrt(dx * dx + dy * dy); fx -= k * dx / distance; fy -= k * dy / distance; } }); // Apply forces with damping const damping = 0.9; node1.x += fx * damping; node1.y += fy * damping; // Keep nodes within bounds node1.x = Math.max(node1.width/2, Math.min(this.width - node1.width/2, node1.x)); node1.y = Math.max(node1.height/2, Math.min(this.height - node1.height/2, node1.y)); }); } } private applyHierarchicalConstraints() { // Group nodes by their levels const levels: { [key: number]: Node[] } = {}; const visited = new Set<string>(); const assignLevel = (nodeId: string, level: number) => { if (visited.has(nodeId)) return; visited.add(nodeId); const node = this.nodes.find(n => n.id === nodeId)!; levels[level] = levels[level] || []; levels[level].push(node); // Process children this.edges .filter(e => e.from === nodeId) .forEach(e => assignLevel(e.to, level + 1)); }; // Start with root nodes (nodes with no incoming edges) const rootNodes = this.nodes.filter(node => !this.edges.some(e => e.to === node.id) ); rootNodes.forEach(node => assignLevel(node.id, 0)); // Adjust vertical positions based on levels Object.entries(levels).forEach(([level, nodes]) => { const levelY = Number(level) * 150 + 50; const levelWidth = this.width - 100; const spacing = levelWidth / (nodes.length + 1); nodes.forEach((node, index) => { node.y = levelY; node.x = spacing * (index + 1); }); }); } private minimizeCrossings() { // Barycentric method to reduce edge crossings const levels = this.getLevels(); for (let i = 1; i < Object.keys(levels).length; i++) { const currentLevel = levels[i]; const upperLevel = levels[i - 1]; currentLevel.forEach(node => { // Calculate barycenter const incomingEdges = this.edges.filter(e => e.to === node.id); if (incomingEdges.length > 0) { const avgX = incomingEdges.reduce((sum, edge) => { const sourceNode = upperLevel.find(n => n.id === edge.from)!; return sum + sourceNode.x; }, 0) / incomingEdges.length; node.x = avgX; } }); // Sort nodes horizontally within level currentLevel.sort((a, b) => a.x - b.x); // Space nodes evenly const levelWidth = this.width - 100; const spacing = levelWidth / (currentLevel.length + 1); currentLevel.forEach((node, index) => { node.x = spacing * (index + 1); }); } } private getLevels(): { [key: number]: Node[] } { const levels: { [key: number]: Node[] } = {}; const visited = new Set<string>(); const getNodeLevel = (nodeId: string): number => { if (visited.has(nodeId)) return -1; visited.add(nodeId); const incomingEdges = this.edges.filter(e => e.to === nodeId); if (incomingEdges.length === 0) return 0; const parentLevels = incomingEdges.map(e => getNodeLevel(e.from)); return Math.max(...parentLevels) + 1; }; this.nodes.forEach(node => { visited.clear(); const level = getNodeLevel(node.id); levels[level] = levels[level] || []; levels[level].push(node); }); return levels; } // Add export functionality exportLayout() { const layout = { nodes: this.nodes.map(node => ({ id: node.id, x: node.x, y: node.y, type: node.type, label: node.label })), edges: this.edges }; return JSON.stringify(layout, null, 2); } // Add import functionality importLayout(layoutStr: string) { try { const layout = JSON.parse(layoutStr); // Update node positions layout.nodes.forEach((importedNode: any) => { const node = this.nodes.find(n => n.id === importedNode.id); if (node) { node.x = importedNode.x; node.y = importedNode.y; } }); this.draw(); } catch (error) { console.error('Failed to import layout:', error); } } // Add zoom functionality private scale = 1; zoomIn() { this.scale = Math.min(this.scale * 1.2, 3); this.applyZoom(); } zoomOut() { this.scale = Math.max(this.scale / 1.2, 0.3); this.applyZoom(); } private applyZoom() { this.ctx.setTransform(1, 0, 0, 1, 0, 0); this.ctx.clearRect(0, 0, this.width, this.height); this.ctx.setTransform(this.scale, 0, 0, this.scale, 0, 0); this.draw(); } // Add node selection and highlighting private selectedNode: Node | null = null; selectNode(event: MouseEvent) { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = (event.clientX - rect.left) / this.scale; const y = (event.clientY - rect.top) / this.scale; this.selectedNode = null; for (const node of this.nodes) { if (x >= node.x && x <= node.x + node.width && y >= node.y && y <= node.y + node.height) { this.selectedNode = node; break; } } this.draw(); } private drawSelectedNode() { if (!this.selectedNode) return; this.ctx.strokeStyle = '#4a90e2'; this.ctx.lineWidth = 3; this.ctx.strokeRect( this.selectedNode.x - 2, this.selectedNode.y - 2, this.selectedNode.width + 4, this.selectedNode.height + 4 ); } // Override the original draw method to include selection private draw() { this.ctx.clearRect(0, 0, this.width / this.scale, this.height / this.scale); this.drawEdges(); this.drawNodes(); if (this.selectedNode) { this.drawSelectedNode(); } } private getMidPoint(points: Point[]): Point { if (!points || points.length === 0) { return { x: 0, y: 0 }; } if (points.length === 1) { return points[0]; } const midIndex = Math.floor((points.length - 1) / 2); if (points.length % 2 === 0) { // Even number of points - average the two middle points const point1 = points[midIndex]; const point2 = points[midIndex + 1]; return { x: (point1.x + point2.x) / 2, y: (point1.y + point2.y) / 2 }; } else { // Odd number of points - return the middle point return points[midIndex]; } } private getPointOnCurve(points: Point[], t: number): Point { if (points.length === 2) { // Linear interpolation return { x: points[0].x + (points[1].x - points[0].x) * t, y: points[0].y + (points[1].y - points[0].y) * t }; } else if (points.length === 3) { // Quadratic bezier const mt = 1 - t; return { x: mt * mt * points[0].x + 2 * mt * t * points[1].x + t * t * points[2].x, y: mt * mt * points[0].y + 2 * mt * t * points[1].y + t * t * points[2].y }; } else if (points.length === 4) { // Cubic bezier const mt = 1 - t; return { x: mt * mt * mt * points[0].x + 3 * mt * mt * t * points[1].x + 3 * mt * t * t * points[2].x + t * t * t * points[3].x, y: mt * mt * mt * points[0].y + 3 * mt * mt * t * points[1].y + 3 * mt * t * t * points[2].y + t * t * t * points[3].y }; } // Fall back to linear interpolation between first and last points return this.getPointOnCurve([points[0], points[points.length - 1]], t); } }
|   |   |   |   |   --- ixt-ebnf.module.ts: // ixt-ebnf.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtEbnfDiagram } from './ixt-ebnf.diagram'; @NgModule({ declarations: [ IxtEbnfDiagram ], imports: [ CommonModule ], exports: [ IxtEbnfDiagram ] }) export class IxtEbnfModule {}
|   |   |   |   |   --- ixt-ebnf.types.ts: // ixt-ebnf.types.ts /** * Represents the type of node in the EBNF diagram */ export type NodeType = 'terminal' | 'nonterminal' | 'operator'; /** * Represents the type of edge connection in the EBNF diagram */ export type EdgeType = 'sequence' | 'alternative' | 'optional' | 'repetition'; /** * Represents a position in the 2D space */ export interface Point { x: number; y: number; } /** * Represents the dimensions of a node */ export interface Dimensions { width: number; height: number; } /** * Represents a node in the EBNF diagram */ export interface EbnfNode extends Point, Dimensions { id: string; label: string; type: NodeType; isDragging: boolean; selected?: boolean; data?: Record<string, any>; // Optional custom data } /** * Represents an edge connecting two nodes in the EBNF diagram */ export interface EbnfEdge { id: string; from: string; to: string; type: EdgeType; label?: string; points?: Point[]; // Control points for edge routing selected?: boolean; } /** * Configuration options for the EBNF diagram */ export interface EbnfConfig { width: number; height: number; nodePadding: number; levelSpacing: number; nodeSpacing: number; edgeRadius: number; fontSize: number; fontFamily: string; colors: EbnfColors; animation: EbnfAnimationConfig; } /** * Color configuration for the diagram */ export interface EbnfColors { terminal: { fill: string; stroke: string; text: string; }; nonterminal: { fill: string; stroke: string; text: string; }; operator: { fill: string; stroke: string; text: string; }; edge: { line: string; text: string; arrow: string; }; selection: { fill: string; stroke: string; }; } /** * Animation configuration */ export interface EbnfAnimationConfig { duration: number; easing: 'linear' | 'easeIn' | 'easeOut' | 'easeInOut'; } /** * Layout options for the diagram */ export interface LayoutOptions { type: 'hierarchical' | 'force-directed' | 'radial'; direction?: 'LR' | 'RL' | 'TB' | 'BT'; alignGrid?: boolean; minimizeCrossings?: boolean; nodeSpacing?: number; rankSpacing?: number; } /** * Complete diagram state */ export interface DiagramState { nodes: EbnfNode[]; edges: EbnfEdge[]; config: EbnfConfig; layout: LayoutOptions; selectedItems: { nodes: string[]; edges: string[]; }; } /** * Event types for diagram interactions */ export type DiagramEventType = | 'nodeClick' | 'nodeDoubleClick' | 'nodeDragStart' | 'nodeDrag' | 'nodeDragEnd' | 'edgeClick' | 'canvasClick' | 'selectionChange' | 'layoutChange'; /** * Base event interface for diagram events */ export interface DiagramEvent { type: DiagramEventType; timestamp: number; } /** * Node-specific event interface */ export interface NodeEvent extends DiagramEvent { node: EbnfNode; position: Point; } /** * Edge-specific event interface */ export interface EdgeEvent extends DiagramEvent { edge: EbnfEdge; position: Point; } /** * Selection change event interface */ export interface SelectionChangeEvent extends DiagramEvent { selectedNodes: string[]; selectedEdges: string[]; previousSelection: { nodes: string[]; edges: string[]; }; } /** * Layout change event interface */ export interface LayoutChangeEvent extends DiagramEvent { previousLayout: LayoutOptions; newLayout: LayoutOptions; } /** * View state for handling zoom and pan */ export interface ViewState { scale: number; translation: Point; bounds: { minX: number; minY: number; maxX: number; maxY: number; }; } /** * Service interface for the EBNF diagram */ export interface IxtEbnfService { getLayout(): DiagramState; updateLayout(options: Partial<LayoutOptions>): void; addNode(node: Omit<EbnfNode, 'x' | 'y'>): EbnfNode; removeNode(nodeId: string): void; addEdge(edge: Omit<EbnfEdge, 'id'>): EbnfEdge; removeEdge(edgeId: string): void; selectItems(nodes: string[], edges: string[]): void; exportDiagram(): string; importDiagram(data: string): void; getViewState(): ViewState; setViewState(state: Partial<ViewState>): void; }
|   |   |   |   |   --- ixt.ebnf.index.ts: // ixt-ebnf.index.ts export * from './ixt-ebnf.diagram'; export * from './ixt-ebnf.module'; // Optional: You might also want interfaces for the component // ixt-ebnf.types.ts export interface EbnfNode { id: string; x: number; y: number; width: number; height: number; isDragging: boolean; type: 'terminal' | 'nonterminal' | 'operator'; label: string; } export interface EbnfEdge { from: string; to: string; type: 'sequence' | 'alternative' | 'optional' | 'repetition'; } export interface EbnfLayout { nodes: EbnfNode[]; edges: EbnfEdge[]; } // Update ixt-ebnf.index.ts to include types export * from './ixt-ebnf.types';
|   |   |   |   +-- clazz
|   |   |   |   |   --- ixt-clazz.diagram.html: <empty file>
|   |   |   |   |   --- ixt-clazz.diagram.ts: // uml-diagram.component.ts import { Component, ElementRef, ViewChild, AfterViewInit, OnDestroy } from '@angular/core'; interface UMLClass { id: string; name: string; attributes: string[]; methods: string[]; x: number; y: number; width: number; height: number; } interface Relationship { from: string; to: string; type: 'inheritance' | 'implementation' | 'association' | 'composition'; } @Component({ selector: 'ixt-clazz', template: ` <div class="container"> <button (click)="applyForceDirectedLayout()">Auto Layout</button> <canvas #canvas (mousedown)="onMouseDown($event)" (mousemove)="onMouseMove($event)" (mouseup)="onMouseUp()"> </canvas> </div> `, styles: [` .container { width: 100%; height: 100vh; overflow: hidden; } canvas { border: 1px solid #ccc; } `] }) export class IxtClazzDiagram implements AfterViewInit, OnDestroy { @ViewChild('canvas') canvasRef!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; private classes: UMLClass[] = [ { id: 'book', name: 'Book', attributes: ['- isbn: string', '- title: string', '- author: string'], methods: ['+ getDetails(): string'], x: 100, y: 100, width: 200, height: 150 }, { id: 'library', name: 'Library', attributes: ['- name: string', '- books: Book[]'], methods: ['+ addBook(book: Book): void', '+ removeBook(isbn: string): void'], x: 400, y: 100, width: 200, height: 150 }, // Add more classes as needed ]; private relationships: Relationship[] = [ { from: 'library', to: 'book', type: 'composition' } ]; private isDragging = false; private selectedClass: UMLClass | null = null; private dragOffset = { x: 0, y: 0 }; private animationFrameId: number | null = null; ngAfterViewInit() { const canvas = this.canvasRef.nativeElement; this.ctx = canvas.getContext('2d')!; this.resizeCanvas(); this.draw(); window.addEventListener('resize', this.resizeCanvas.bind(this)); } ngOnDestroy() { window.removeEventListener('resize', this.resizeCanvas.bind(this)); if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); } } private resizeCanvas() { const canvas = this.canvasRef.nativeElement; canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; } private draw() { const canvas = this.canvasRef.nativeElement; this.ctx.clearRect(0, 0, canvas.width, canvas.height); // Draw relationships first (so they appear under the classes) this.drawRelationships(); // Draw classes this.classes.forEach(cls => this.drawClass(cls)); this.animationFrameId = requestAnimationFrame(() => this.draw()); } private drawClass(cls: UMLClass) { // Draw class box this.ctx.strokeStyle = '#000'; this.ctx.fillStyle = '#fff'; this.ctx.lineWidth = 1; // Main rectangle this.ctx.beginPath(); this.ctx.rect(cls.x, cls.y, cls.width, cls.height); this.ctx.fill(); this.ctx.stroke(); // Class name section this.ctx.font = 'bold 14px Arial'; this.ctx.textAlign = 'center'; this.ctx.fillStyle = '#000'; this.ctx.fillText(cls.name, cls.x + cls.width / 2, cls.y + 25); // Separator lines const attributesY = cls.y + 35; const methodsY = attributesY + (cls.attributes.length * 20) + 10; this.ctx.beginPath(); this.ctx.moveTo(cls.x, attributesY); this.ctx.lineTo(cls.x + cls.width, attributesY); this.ctx.stroke(); // Draw attributes this.ctx.font = '12px Arial'; this.ctx.textAlign = 'left'; cls.attributes.forEach((attr, index) => { this.ctx.fillText(attr, cls.x + 10, attributesY + 20 + (index * 20)); }); // Draw methods this.ctx.beginPath(); this.ctx.moveTo(cls.x, methodsY); this.ctx.lineTo(cls.x + cls.width, methodsY); this.ctx.stroke(); cls.methods.forEach((method, index) => { this.ctx.fillText(method, cls.x + 10, methodsY + 20 + (index * 20)); }); } private drawRelationships() { this.relationships.forEach(rel => { const fromClass = this.classes.find(c => c.id === rel.from); const toClass = this.classes.find(c => c.id === rel.to); if (!fromClass || !toClass) return; // Calculate connection points const start = this.getConnectionPoint(fromClass, toClass); const end = this.getConnectionPoint(toClass, fromClass); this.ctx.beginPath(); this.ctx.moveTo(start.x, start.y); this.ctx.lineTo(end.x, end.y); // Draw different arrow heads based on relationship type if (rel.type === 'inheritance') { this.drawInheritanceArrow(end.x, end.y, this.getAngle(start, end)); } else if (rel.type === 'implementation') { this.drawImplementationArrow(end.x, end.y, this.getAngle(start, end)); } else if (rel.type === 'composition') { this.drawCompositionDiamond(end.x, end.y, this.getAngle(start, end)); } this.ctx.stroke(); }); } private getConnectionPoint(from: UMLClass, to: UMLClass): { x: number, y: number } { // Calculate center points const fromCenter = { x: from.x + from.width / 2, y: from.y + from.height / 2 }; const toCenter = { x: to.x + to.width / 2, y: to.y + to.height / 2 }; // Calculate angle between centers const angle = Math.atan2(toCenter.y - fromCenter.y, toCenter.x - fromCenter.x); // Calculate intersection with rectangle const cos = Math.cos(angle); const sin = Math.sin(angle); let x, y; if (Math.abs(cos) > Math.abs(sin)) { // Intersect with vertical sides x = cos > 0 ? from.x + from.width : from.x; y = fromCenter.y + (x - fromCenter.x) * sin / cos; } else { // Intersect with horizontal sides y = sin > 0 ? from.y + from.height : from.y; x = fromCenter.x + (y - fromCenter.y) * cos / sin; } return { x, y }; } private getAngle(start: { x: number, y: number }, end: { x: number, y: number }): number { return Math.atan2(end.y - start.y, end.x - start.x); } private drawInheritanceArrow(x: number, y: number, angle: number) { const size = 15; const angleLeft = angle + Math.PI * 0.8; const angleRight = angle - Math.PI * 0.8; this.ctx.beginPath(); this.ctx.moveTo(x, y); this.ctx.lineTo( x - size * Math.cos(angleLeft), y - size * Math.sin(angleLeft) ); this.ctx.lineTo( x - size * Math.cos(angleRight), y - size * Math.sin(angleRight) ); this.ctx.closePath(); this.ctx.fillStyle = '#fff'; this.ctx.fill(); this.ctx.stroke(); } private drawImplementationArrow(x: number, y: number, angle: number) { // Similar to inheritance but with dashed line this.ctx.setLineDash([5, 5]); this.drawInheritanceArrow(x, y, angle); this.ctx.setLineDash([]); } private drawCompositionDiamond(x: number, y: number, angle: number) { const size = 10; this.ctx.beginPath(); this.ctx.moveTo(x, y); this.ctx.lineTo( x - size * Math.cos(angle + Math.PI / 4), y - size * Math.sin(angle + Math.PI / 4) ); this.ctx.lineTo( x - size * 2 * Math.cos(angle), y - size * 2 * Math.sin(angle) ); this.ctx.lineTo( x - size * Math.cos(angle - Math.PI / 4), y - size * Math.sin(angle - Math.PI / 4) ); this.ctx.closePath(); this.ctx.fillStyle = '#000'; this.ctx.fill(); } onMouseDown(event: MouseEvent) { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; // Check if click is inside any class this.selectedClass = this.classes.find(cls => x >= cls.x && x <= cls.x + cls.width && y >= cls.y && y <= cls.y + cls.height ) || null; if (this.selectedClass) { this.isDragging = true; this.dragOffset = { x: x - this.selectedClass.x, y: y - this.selectedClass.y }; } } onMouseMove(event: MouseEvent) { if (this.isDragging && this.selectedClass) { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); this.selectedClass.x = event.clientX - rect.left - this.dragOffset.x; this.selectedClass.y = event.clientY - rect.top - this.dragOffset.y; } } onMouseUp() { this.isDragging = false; this.selectedClass = null; } applyForceDirectedLayout() { const REPULSION = 50000; // Repulsion force between nodes const ATTRACTION = 0.01; // Attraction force for relationships const DAMPING = 0.95; // Damping factor to prevent oscillation const ITERATIONS = 50; // Number of iterations for the algorithm // Initialize velocities const velocities = new Map(this.classes.map(cls => [cls.id, { x: 0, y: 0 }])); for (let i = 0; i < ITERATIONS; i++) { // Calculate forces this.classes.forEach(cls1 => { let fx = 0; let fy = 0; // Repulsion between all classes this.classes.forEach(cls2 => { if (cls1 !== cls2) { const dx = cls1.x - cls2.x; const dy = cls1.y - cls2.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance > 0) { const force = REPULSION / (distance * distance); fx += (dx / distance) * force; fy += (dy / distance) * force; } } }); // Attraction for related classes this.relationships.forEach(rel => { if (rel.from === cls1.id || rel.to === cls1.id) { const other = this.classes.find(c => c.id === (rel.from === cls1.id ? rel.to : rel.from) ); if (other) { const dx = cls1.x - other.x; const dy = cls1.y - other.y; const distance = Math.sqrt(dx * dx + dy * dy); fx -= dx * ATTRACTION; fy -= dy * ATTRACTION; } } }); // Update velocity const velocity = velocities.get(cls1.id)!; velocity.x = (velocity.x + fx) * DAMPING; velocity.y = (velocity.y + fy) * DAMPING; // Update position cls1.x += velocity.x; cls1.y += velocity.y; }); } // Center the diagram const bounds = this.calculateBounds(); const centerX = this.canvasRef.nativeElement.width / 2; const centerY = this.canvasRef.nativeElement.height / 2; const offsetX = centerX - (bounds.maxX + bounds.minX) / 2; const offsetY = centerY - (bounds.maxY + bounds.minY) / 2; this.classes.forEach(cls => { cls.x += offsetX; cls.y += offsetY; }); } private calculateBounds() { const bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }; this.classes.forEach(cls => { bounds.minX = Math.min(bounds.minX, cls.x); bounds.minY = Math.min(bounds.minY, cls.y); bounds.maxX = Math.max(bounds.maxX, cls.x + cls.width); bounds.maxY = Math.max(bounds.maxY, cls.y + cls.height); }); return bounds; } }
|   |   |   |   |   --- ixt-clazz.index.ts: // ixt-clazz.index.ts export * from './ixt-clazz.diagram'; export * from './ixt-clazz.module'; // You might also want to export your interfaces export interface UMLClass { id: string; name: string; attributes: string[]; methods: string[]; x: number; y: number; width: number; height: number; } export interface Relationship { from: string; to: string; type: 'inheritance' | 'implementation' | 'association' | 'composition'; }
|   |   |   |   |   --- ixt-clazz.module.ts: // ixt-clazz.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtClazzDiagram } from './ixt-clazz.diagram'; @NgModule({ declarations: [ IxtClazzDiagram ], imports: [ CommonModule ], exports: [ IxtClazzDiagram ] }) export class IxtClazzModule { }
|   |   |   |   +-- deployment
|   |   |   |   |   --- ixt-deployment.diagram.html: <empty file>
|   |   |   |   |   --- ixt-deployment.diagram.ts: import { Component, ElementRef, OnInit, ViewChild } from '@angular/core'; import { DeploymentNode, Connection, DeploymentDiagramConfig } from './ixt-deployment.types'; import { fromEvent } from 'rxjs'; import { takeUntil } from 'rxjs/operators'; @Component({ selector: 'ixt-deployment', template: ` <div class="diagram-container"> <canvas #canvas (mousedown)="onMouseDown($event)" (mousemove)="onMouseMove($event)" (mouseup)="onMouseUp()" [width]="width" [height]="height"> </canvas> <button (click)="autoLayout()" class="auto-layout-btn">Auto Layout</button> </div> `, styles: [` .diagram-container { position: relative; border: 1px solid #ccc; } .auto-layout-btn { position: absolute; top: 10px; right: 10px; padding: 8px 16px; background: #4a90e2; color: white; border: none; border-radius: 4px; cursor: pointer; } canvas { cursor: move; } `] }) export class IxtDeploymentDiagram implements OnInit { @ViewChild('canvas', { static: true }) canvasRef!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; width = 800; height = 600; nodes: DeploymentNode[] = [ { id: '1', type: 'server', x: 100, y: 100, width: 120, height: 80, label: 'Web Server' }, { id: '2', type: 'database', x: 400, y: 100, width: 100, height: 100, label: 'Database' }, { id: '3', type: 'service', x: 250, y: 300, width: 150, height: 70, label: 'Message Queue' }, { id: '4', type: 'container', x: 500, y: 300, width: 130, height: 90, label: 'Docker Container' } ]; connections: Connection[] = [ { from: '1', to: '2', type: 'communicates' }, { from: '1', to: '3', type: 'depends' }, { from: '3', to: '4', type: 'deploys' } ]; private draggedNode: DeploymentNode | null = null; private dragStartX = 0; private dragStartY = 0; private nodeOffsetX = 0; private nodeOffsetY = 0; // Force-directed layout parameters private readonly REPULSION = 8000; // Repulsion force between nodes private readonly ATTRACTION = 0.06; // Attraction force along connections private readonly DAMPING = 0.9; // Velocity damping factor private readonly MIN_DISTANCE = 150; // Minimum distance between nodes ngOnInit() { const canvas = this.canvasRef.nativeElement; this.ctx = canvas.getContext('2d')!; this.draw(); } private draw() { const ctx = this.ctx; ctx.clearRect(0, 0, this.width, this.height); // Draw connections first (under nodes) this.drawConnections(); // Draw nodes this.nodes.forEach(node => this.drawNode(node)); } private drawNode(node: DeploymentNode) { const ctx = this.ctx; ctx.save(); // Shadow ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'; ctx.shadowBlur = 5; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2; // Node shape ctx.beginPath(); switch (node.type) { case 'server': this.drawServer(node); break; case 'database': this.drawDatabase(node); break; case 'service': this.drawService(node); break; case 'container': this.drawContainer(node); break; } // Label ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(node.label, node.x + node.width/2, node.y + node.height/2); ctx.restore(); } private drawServer(node: DeploymentNode) { const ctx = this.ctx; ctx.fillStyle = '#e8f4f8'; ctx.strokeStyle = '#4a90e2'; ctx.lineWidth = 2; // Main rectangle ctx.fillRect(node.x, node.y, node.width, node.height); ctx.strokeRect(node.x, node.y, node.width, node.height); // Server rack lines for (let i = 1; i < 4; i++) { const y = node.y + (node.height * i/4); ctx.beginPath(); ctx.moveTo(node.x, y); ctx.lineTo(node.x + node.width, y); ctx.stroke(); } } private drawDatabase(node: DeploymentNode) { const ctx = this.ctx; ctx.fillStyle = '#f8e8f4'; ctx.strokeStyle = '#9c27b0'; ctx.lineWidth = 2; // Cylinder shape const cylinderHeight = node.height * 0.8; const ellipseHeight = node.height * 0.2; // Draw cylinder body ctx.beginPath(); ctx.moveTo(node.x, node.y + ellipseHeight); ctx.lineTo(node.x, node.y + cylinderHeight); ctx.bezierCurveTo( node.x, node.y + node.height, node.x + node.width, node.y + node.height, node.x + node.width, node.y + cylinderHeight ); ctx.lineTo(node.x + node.width, node.y + ellipseHeight); ctx.fill(); ctx.stroke(); // Draw top ellipse ctx.beginPath(); ctx.ellipse( node.x + node.width/2, node.y + ellipseHeight, node.width/2, ellipseHeight, 0, 0, 2 * Math.PI ); ctx.fill(); ctx.stroke(); } private drawService(node: DeploymentNode) { const ctx = this.ctx; ctx.fillStyle = '#f4f8e8'; ctx.strokeStyle = '#8bc34a'; ctx.lineWidth = 2; // Hexagon const side = node.width/4; ctx.beginPath(); ctx.moveTo(node.x + side, node.y); ctx.lineTo(node.x + node.width - side, node.y); ctx.lineTo(node.x + node.width, node.y + node.height/2); ctx.lineTo(node.x + node.width - side, node.y + node.height); ctx.lineTo(node.x + side, node.y + node.height); ctx.lineTo(node.x, node.y + node.height/2); ctx.closePath(); ctx.fill(); ctx.stroke(); } private drawContainer(node: DeploymentNode) { const ctx = this.ctx; ctx.fillStyle = '#f8f0e8'; ctx.strokeStyle = '#ff9800'; ctx.lineWidth = 2; // Container shape with docker-like waves ctx.fillRect(node.x, node.y, node.width, node.height); ctx.strokeRect(node.x, node.y, node.width, node.height); // Wave pattern const waveHeight = 8; const waveWidth = node.width/4; ctx.beginPath(); for (let x = node.x; x < node.x + node.width; x += waveWidth) { ctx.bezierCurveTo( x + waveWidth/3, node.y + waveHeight, x + 2*waveWidth/3, node.y - waveHeight, x + waveWidth, node.y ); } ctx.stroke(); } private drawConnections() { const ctx = this.ctx; ctx.save(); this.connections.forEach(conn => { const fromNode = this.nodes.find(n => n.id === conn.from)!; const toNode = this.nodes.find(n => n.id === conn.to)!; // Calculate connection points using smart routing const points = this.calculateConnectionPoints(fromNode, toNode); ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); // Draw connection line with different styles based on type switch (conn.type) { case 'deploys': ctx.setLineDash([5, 5]); ctx.strokeStyle = '#4a90e2'; break; case 'depends': ctx.setLineDash([]); ctx.strokeStyle = '#ff9800'; break; case 'communicates': ctx.setLineDash([10, 3]); ctx.strokeStyle = '#8bc34a'; break; } ctx.lineWidth = 2; // Draw connection using bezier curves for smooth routing if (points.length === 4) { ctx.bezierCurveTo( points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y ); } else { points.slice(1).forEach(point => { ctx.lineTo(point.x, point.y); }); } ctx.stroke(); // Draw arrow this.drawArrow(points[points.length-2], points[points.length-1]); }); ctx.restore(); } private calculateConnectionPoints(from: DeploymentNode, to: DeploymentNode) { // Smart routing algorithm to avoid crossing nodes const fromCenter = { x: from.x + from.width/2, y: from.y + from.height/2 }; const toCenter = { x: to.x + to.width/2, y: to.y + to.height/2 }; // Calculate intermediate points for bezier curve const dx = toCenter.x - fromCenter.x; const dy = toCenter.y - fromCenter.y; const distance = Math.sqrt(dx*dx + dy*dy); return [ fromCenter, { x: fromCenter.x + dx/3, y: fromCenter.y + dy/3 }, { x: fromCenter.x + 2*dx/3, y: fromCenter.y + 2*dy/3 }, toCenter ]; } private drawArrow(from: {x: number, y: number}, to: {x: number, y: number}) { const ctx = this.ctx; const angle = Math.atan2(to.y - from.y, to.x - from.x); const arrowLength = 10; ctx.beginPath(); ctx.moveTo(to.x, to.y); ctx.lineTo( to.x - arrowLength * Math.cos(angle - Math.PI/6), to.y - arrowLength * Math.sin(angle - Math.PI/6) ); ctx.moveTo(to.x, to.y); ctx.lineTo( to.x - arrowLength * Math.cos(angle + Math.PI/6), to.y - arrowLength * Math.sin(angle + Math.PI/6) ); ctx.stroke(); } onMouseDown(event: MouseEvent) { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; // Find clicked node this.draggedNode = this.nodes.find(node => x >= node.x && x <= node.x + node.width && y >= node.y && y <= node.y + node.height ) || null; if (this.draggedNode) { this.dragStartX = x; this.dragStartY = y; this.nodeOffsetX = x - this.draggedNode.x; this.nodeOffsetY = y - this.draggedNode.y; } } onMouseMove(event: MouseEvent) { if (!this.draggedNode) return; const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; this.draggedNode.x = x - this.nodeOffsetX; this.draggedNode.y = y - this.nodeOffsetY; // Keep node within canvas bounds this.draggedNode.x = Math.max(0, Math.min(this.width - this.draggedNode.width, this.draggedNode.x)); this.draggedNode.y = Math.max(0, Math.min(this.height - this.draggedNode.height, this.draggedNode.y)); this.draw(); } onMouseUp() { this.draggedNode = null; } autoLayout() { const iterations = 50; const nodeVelocities = this.nodes.map(() => ({ x: 0, y: 0 })); // Run force-directed layout algorithm for (let i = 0; i < iterations; i++) { // Calculate forces this.nodes.forEach((node1, i) => { let fx = 0; let fy = 0; // Repulsion between all nodes this.nodes.forEach((node2, j) => { if (i === j) return; const dx = node2.x - node1.x; const dy = node2.y - node1.y; const distance = Math.sqrt(dx*dx + dy*dy); if (distance < this.MIN_DISTANCE) { const force = this.REPULSION / (distance * distance); fx -= (dx / distance) * force; fy -= (dy / distance) * force; } }); // Attraction along connections this.connections.forEach(conn => { if (conn.from === node1.id || conn.to === node1.id) { const other = this.nodes.find(n => n.id === (conn.from === node1.id ? conn.to : conn.from) )!; const dx = other.x - node1.x; const dy = other.y - node1.y; const distance = Math.sqrt(dx*dx + dy*dy); fx += dx * this.ATTRACTION; fy += dy * this.ATTRACTION; } }); // Update velocities with damping nodeVelocities[i].x = (nodeVelocities[i].x + fx) * this.DAMPING; nodeVelocities[i].y = (nodeVelocities[i].y + fy) * this.DAMPING; }); // Update positions this.nodes.forEach((node, i) => { node.x += nodeVelocities[i].x; node.y += nodeVelocities[i].y; // Keep nodes within bounds node.x = Math.max(0, Math.min(this.width - node.width, node.x)); node.y = Math.max(0, Math.min(this.height - node.height, node.y)); }); } // Check for overlaps and adjust if necessary this.resolveOverlaps(); this.draw(); } private resolveOverlaps() { const padding = 20; // Minimum space between nodes let hasOverlap = true; let iterations = 0; const maxIterations = 100; while (hasOverlap && iterations < maxIterations) { hasOverlap = false; iterations++; for (let i = 0; i < this.nodes.length; i++) { for (let j = i + 1; j < this.nodes.length; j++) { const node1 = this.nodes[i]; const node2 = this.nodes[j]; // Check for overlap if (this.isOverlapping(node1, node2, padding)) { hasOverlap = true; // Calculate overlap resolution vector const dx = node2.x - node1.x; const dy = node2.y - node1.y; const distance = Math.sqrt(dx*dx + dy*dy); // Minimum distance needed const minDistance = Math.sqrt( Math.pow(node1.width/2 + node2.width/2 + padding, 2) + Math.pow(node1.height/2 + node2.height/2 + padding, 2) ); // Move nodes apart const moveX = (dx/distance) * (minDistance - distance) / 2; const moveY = (dy/distance) * (minDistance - distance) / 2; node1.x -= moveX; node1.y -= moveY; node2.x += moveX; node2.y += moveY; // Keep within bounds this.nodes.forEach(node => { node.x = Math.max(0, Math.min(this.width - node.width, node.x)); node.y = Math.max(0, Math.min(this.height - node.height, node.y)); }); } } } } } private isOverlapping(node1: DeploymentNode, node2: DeploymentNode, padding: number): boolean { return !( node1.x + node1.width + padding < node2.x || node2.x + node2.width + padding < node1.x || node1.y + node1.height + padding < node2.y || node2.y + node2.height + padding < node1.y ); } // Optional: Add capability to save/load layouts saveLayout(): string { return JSON.stringify({ nodes: this.nodes, connections: this.connections }); } loadLayout(layoutJson: string) { const layout = JSON.parse(layoutJson); this.nodes = layout.nodes; this.connections = layout.connections; this.draw(); } }
|   |   |   |   |   --- ixt-deployment.index.ts: // ixt-deployment.index.ts export * from './ixt-deployment.diagram'; export * from './ixt-deployment.module'; export * from './ixt-deployment.types';
|   |   |   |   |   --- ixt-deployment.module.ts: // ixt-deployment.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtDeploymentDiagram } from './ixt-deployment.diagram'; @NgModule({ declarations: [ IxtDeploymentDiagram ], imports: [ CommonModule ], exports: [ IxtDeploymentDiagram ] }) export class IxtDeploymentModule { }
|   |   |   |   |   --- ixt-deployment.types.ts: export interface DeploymentNode { id: string; type: 'server' | 'database' | 'service' | 'container'; x: number; y: number; width: number; height: number; label: string; } export interface Connection { from: string; to: string; type: 'deploys' | 'depends' | 'communicates'; } export interface DeploymentDiagramConfig { width?: number; height?: number; minDistance?: number; repulsionForce?: number; attractionForce?: number; dampingFactor?: number; }
|   |   |   |   +-- erd
|   |   |   |   |   --- ixt-erd.diagram.html: <empty file>
|   |   |   |   |   --- ixt-erd.diagram.ts: // ixt-erd.diagram.ts import { Component, ElementRef, OnInit, ViewChild } from '@angular/core'; interface Entity { id: string; name: string; attributes: Array<{ name: string; type: string; isPrimaryKey: boolean; isForeignKey: boolean; }>; x: number; y: number; width: number; height: number; } interface Relationship { id: string; sourceId: string; targetId: string; type: 'one-to-many' | 'many-to-many' | 'one-to-one'; } @Component({ selector: 'ixt-erd', template: ` <div class="diagram-container"> <canvas #canvas (mousedown)="onMouseDown($event)" (mousemove)="onMouseMove($event)" (mouseup)="onMouseUp()" [width]="canvasWidth" [height]="canvasHeight"> </canvas> <button (click)="applyForceDirectedLayout()">Auto Layout</button> </div> `, styles: [` .diagram-container { position: relative; width: 100%; height: 100%; } canvas { border: 1px solid #ccc; } `] }) export class IxtErdDiagram implements OnInit { @ViewChild('canvas', { static: true }) canvasRef!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; canvasWidth = 1200; canvasHeight = 800; entities: Entity[] = [ { id: '1', name: 'User', attributes: [ { name: 'id', type: 'uuid', isPrimaryKey: true, isForeignKey: false }, { name: 'email', type: 'varchar', isPrimaryKey: false, isForeignKey: false }, { name: 'password_hash', type: 'varchar', isPrimaryKey: false, isForeignKey: false } ], x: 100, y: 100, width: 200, height: 150 }, { id: '2', name: 'Order', attributes: [ { name: 'id', type: 'uuid', isPrimaryKey: true, isForeignKey: false }, { name: 'user_id', type: 'uuid', isPrimaryKey: false, isForeignKey: true }, { name: 'total_amount', type: 'decimal', isPrimaryKey: false, isForeignKey: false } ], x: 400, y: 100, width: 200, height: 150 }, // Add more sample entities... ]; relationships: Relationship[] = [ { id: '1', sourceId: '1', targetId: '2', type: 'one-to-many' } // Add more relationships... ]; private isDragging = false; private selectedEntity: Entity | null = null; private dragStartX = 0; private dragStartY = 0; ngOnInit() { this.ctx = this.canvasRef.nativeElement.getContext('2d')!; this.draw(); } private draw() { this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight); this.drawRelationships(); this.drawEntities(); } private drawEntities() { this.entities.forEach(entity => { // Draw entity box this.ctx.fillStyle = '#ffffff'; this.ctx.strokeStyle = '#000000'; this.ctx.lineWidth = 2; this.ctx.fillRect(entity.x, entity.y, entity.width, entity.height); this.ctx.strokeRect(entity.x, entity.y, entity.width, entity.height); // Draw entity name this.ctx.fillStyle = '#000000'; this.ctx.font = 'bold 16px Arial'; this.ctx.fillText(entity.name, entity.x + 10, entity.y + 25); // Draw attributes this.ctx.font = '14px Arial'; entity.attributes.forEach((attr, index) => { const y = entity.y + 50 + (index * 20); let prefix = attr.isPrimaryKey ? '🔑 ' : attr.isForeignKey ? '🔗 ' : ''; this.ctx.fillText(`${prefix}${attr.name}: ${attr.type}`, entity.x + 10, y); }); }); } private drawRelationships() { this.relationships.forEach(rel => { const source = this.entities.find(e => e.id === rel.sourceId)!; const target = this.entities.find(e => e.id === rel.targetId)!; // Calculate connection points const [startX, startY] = this.calculateConnectionPoint(source, target); const [endX, endY] = this.calculateConnectionPoint(target, source); // Draw relationship line this.ctx.beginPath(); this.ctx.moveTo(startX, startY); this.ctx.lineTo(endX, endY); this.ctx.stroke(); // Draw relationship type indicators this.drawRelationshipSymbol(rel.type, startX, startY, endX, endY); }); } private calculateConnectionPoint(source: Entity, target: Entity): [number, number] { // Complex logic to determine the best connection points between entities // This is a simplified version - you'd want more sophisticated logic in production const sourceCenter = { x: source.x + source.width / 2, y: source.y + source.height / 2 }; const targetCenter = { x: target.x + target.width / 2, y: target.y + target.height / 2 }; // Calculate angle between centers const angle = Math.atan2(targetCenter.y - sourceCenter.y, targetCenter.x - sourceCenter.x); // Calculate intersection with entity border // This is simplified - you'd want to calculate actual intersection points return [ sourceCenter.x + Math.cos(angle) * (source.width / 2), sourceCenter.y + Math.sin(angle) * (source.height / 2) ]; } private drawRelationshipSymbol(type: string, startX: number, startY: number, endX: number, endY: number) { // Draw different symbols based on relationship type const angle = Math.atan2(endY - startY, endX - startX); if (type === 'one-to-many') { // Draw crow's foot const crowsFootSize = 15; const endPoint = { x: endX - Math.cos(angle) * 20, y: endY - Math.sin(angle) * 20 }; this.ctx.beginPath(); this.ctx.moveTo( endPoint.x + Math.cos(angle + Math.PI/6) * crowsFootSize, endPoint.y + Math.sin(angle + Math.PI/6) * crowsFootSize ); this.ctx.lineTo(endPoint.x, endPoint.y); this.ctx.lineTo( endPoint.x + Math.cos(angle - Math.PI/6) * crowsFootSize, endPoint.y + Math.sin(angle - Math.PI/6) * crowsFootSize ); this.ctx.stroke(); } // Add other relationship symbols as needed } onMouseDown(event: MouseEvent) { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; // Check if clicked on an entity this.selectedEntity = this.entities.find(entity => x >= entity.x && x <= entity.x + entity.width && y >= entity.y && y <= entity.y + entity.height ) || null; if (this.selectedEntity) { this.isDragging = true; this.dragStartX = x - this.selectedEntity.x; this.dragStartY = y - this.selectedEntity.y; } } onMouseMove(event: MouseEvent) { if (this.isDragging && this.selectedEntity) { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; this.selectedEntity.x = x - this.dragStartX; this.selectedEntity.y = y - this.dragStartY; this.draw(); } } onMouseUp() { this.isDragging = false; this.selectedEntity = null; } applyForceDirectedLayout() { // Implement force-directed layout algorithm const iterations = 100; const k = 100; // Optimal distance between nodes const gravity = 0.1; const centerX = this.canvasWidth / 2; const centerY = this.canvasHeight / 2; for (let iter = 0; iter < iterations; iter++) { // Calculate repulsive forces between all pairs of entities for (let i = 0; i < this.entities.length; i++) { for (let j = i + 1; j < this.entities.length; j++) { const dx = this.entities[j].x - this.entities[i].x; const dy = this.entities[j].y - this.entities[i].y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance > 0) { const force = k * k / distance; const fx = (dx / distance) * force; const fy = (dy / distance) * force; this.entities[j].x += fx; this.entities[j].y += fy; this.entities[i].x -= fx; this.entities[i].y -= fy; } } // Apply gravity towards center const dx = centerX - this.entities[i].x; const dy = centerY - this.entities[i].y; this.entities[i].x += dx * gravity; this.entities[i].y += dy * gravity; } // Apply attractive forces along relationships this.relationships.forEach(rel => { const source = this.entities.find(e => e.id === rel.sourceId)!; const target = this.entities.find(e => e.id === rel.targetId)!; const dx = target.x - source.x; const dy = target.y - source.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance > 0) { const force = (distance - k) / 3; const fx = (dx / distance) * force; const fy = (dy / distance) * force; source.x += fx; source.y += fy; target.x -= fx; target.y -= fy; } }); } this.draw(); } }
|   |   |   |   |   --- ixt-erd.indext.ts: // ixt-erd.index.ts export * from './ixt-erd.diagram'; export * from './ixt-erd.module'; // You might want to export additional types/interfaces if they're needed elsewhere export interface ErdEntity { id: string; name: string; attributes: Array<{ name: string; type: string; isPrimaryKey: boolean; isForeignKey: boolean; }>; x: number; y: number; width: number; height: number; } export interface ErdRelationship { id: string; sourceId: string; targetId: string; type: 'one-to-many' | 'many-to-many' | 'one-to-one'; }
|   |   |   |   |   --- ixt-erd.module.ts: // ixt-erd.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtErdDiagram } from './ixt-erd.diagram'; @NgModule({ declarations: [ IxtErdDiagram ], imports: [ CommonModule ], exports: [ IxtErdDiagram ], providers: [ // Add any services specific to the ERD diagram here ] }) export class IxtErdModule { }
|   |   |   |   +-- flow
|   |   |   |   |   --- ixt-flow.diagram.html: <empty file>
|   |   |   |   |   --- ixt-flow.diagram.ts: // ixt-flow-diagram.component.ts import { Component, ElementRef, OnInit, ViewChild, AfterViewInit } from '@angular/core'; interface FlowNode { id: string; x: number; y: number; width: number; height: number; type: 'rectangle' | 'diamond' | 'circle'; label: string; isDragging: boolean; } interface FlowEdge { from: string; to: string; label?: string; } interface Point { x: number; y: number; } @Component({ selector: 'ixt-flow', template: ` <div class="flow-diagram-container"> <canvas #canvas (mousedown)="onMouseDown($event)" (mousemove)="onMouseMove($event)" (mouseup)="onMouseUp()" width="1200" height="800"> </canvas> <button (click)="autoLayout()" class="auto-layout-btn">Auto Layout</button> </div> `, styles: [` .flow-diagram-container { position: relative; border: 1px solid #ccc; } .auto-layout-btn { position: absolute; top: 10px; right: 10px; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; } .auto-layout-btn:hover { background: #45a049; } `] }) export class IxtFlowDiagram implements OnInit, AfterViewInit { @ViewChild('canvas') canvasRef!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; private nodes: FlowNode[] = []; private edges: FlowEdge[] = []; private selectedNode: FlowNode | null = null; private dragOffset: Point = { x: 0, y: 0 }; // Force-directed layout parameters private readonly REPULSION = 8000; // Node repulsion force private readonly ATTRACTION = 0.1; // Edge attraction force private readonly DAMPING = 0.9; // Velocity damping private readonly MIN_DISTANCE = 150; // Minimum distance between nodes constructor() { // Initialize sample deployment pipeline this.initializeGraph(); } ngOnInit(): void {} ngAfterViewInit(): void { const canvas = this.canvasRef.nativeElement; this.ctx = canvas.getContext('2d')!; this.draw(); } private initializeGraph(): void { // Initialize nodes with random positions this.nodes = [ { id: 'source', x: 100, y: 100, width: 120, height: 60, type: 'rectangle', label: 'Source Code', isDragging: false }, { id: 'build', x: 300, y: 100, width: 120, height: 60, type: 'rectangle', label: 'Build', isDragging: false }, { id: 'test', x: 500, y: 100, width: 100, height: 100, type: 'diamond', label: 'Tests', isDragging: false }, { id: 'staging', x: 700, y: 100, width: 120, height: 60, type: 'rectangle', label: 'Staging', isDragging: false }, { id: 'approval', x: 900, y: 100, width: 80, height: 80, type: 'circle', label: 'Approval', isDragging: false }, { id: 'prod', x: 1100, y: 100, width: 120, height: 60, type: 'rectangle', label: 'Production', isDragging: false } ]; // Define relationships this.edges = [ { from: 'source', to: 'build', label: 'commit' }, { from: 'build', to: 'test', label: 'artifact' }, { from: 'test', to: 'staging', label: 'passed' }, { from: 'staging', to: 'approval', label: 'deploy' }, { from: 'approval', to: 'prod', label: 'approved' } ]; } private draw(): void { const canvas = this.canvasRef.nativeElement; this.ctx.clearRect(0, 0, canvas.width, canvas.height); // Draw edges first (so they appear behind nodes) this.edges.forEach(edge => this.drawEdge(edge)); // Draw nodes this.nodes.forEach(node => this.drawNode(node)); } private drawNode(node: FlowNode): void { this.ctx.save(); this.ctx.fillStyle = node.isDragging ? '#e0e0e0' : '#ffffff'; this.ctx.strokeStyle = '#333333'; this.ctx.lineWidth = 2; switch (node.type) { case 'rectangle': this.ctx.beginPath(); this.ctx.rect(node.x, node.y, node.width, node.height); break; case 'diamond': this.ctx.beginPath(); this.ctx.moveTo(node.x + node.width / 2, node.y); this.ctx.lineTo(node.x + node.width, node.y + node.height / 2); this.ctx.lineTo(node.x + node.width / 2, node.y + node.height); this.ctx.lineTo(node.x, node.y + node.height / 2); this.ctx.closePath(); break; case 'circle': this.ctx.beginPath(); this.ctx.arc( node.x + node.width / 2, node.y + node.height / 2, Math.min(node.width, node.height) / 2, 0, Math.PI * 2 ); break; } this.ctx.fill(); this.ctx.stroke(); // Draw label this.ctx.fillStyle = '#000000'; this.ctx.font = '14px Arial'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; this.ctx.fillText( node.label, node.x + node.width / 2, node.y + node.height / 2 ); this.ctx.restore(); } private drawEdge(edge: FlowEdge): void { const fromNode = this.nodes.find(n => n.id === edge.from)!; const toNode = this.nodes.find(n => n.id === edge.to)!; // Calculate edge points using smart routing const points = this.calculateEdgePoints(fromNode, toNode); this.ctx.save(); this.ctx.strokeStyle = '#666666'; this.ctx.lineWidth = 2; // Draw path this.ctx.beginPath(); this.ctx.moveTo(points[0].x, points[0].y); // Draw curved path using bezier curves if (points.length === 4) { this.ctx.bezierCurveTo( points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y ); } this.ctx.stroke(); // Draw arrow this.drawArrow(points[points.length - 2], points[points.length - 1]); // Draw label if exists if (edge.label) { const midPoint = this.getMidPoint(points); this.ctx.fillStyle = '#000000'; this.ctx.font = '12px Arial'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; this.ctx.fillText(edge.label, midPoint.x, midPoint.y - 10); } this.ctx.restore(); } private calculateEdgePoints(from: FlowNode, to: FlowNode): Point[] { const fromCenter = { x: from.x + from.width / 2, y: from.y + from.height / 2 }; const toCenter = { x: to.x + to.width / 2, y: to.y + to.height / 2 }; // Calculate control points for bezier curve const dx = toCenter.x - fromCenter.x; const dy = toCenter.y - fromCenter.y; const distance = Math.sqrt(dx * dx + dy * dy); const control1 = { x: fromCenter.x + dx / 3, y: fromCenter.y + dy / 3 }; const control2 = { x: fromCenter.x + 2 * dx / 3, y: fromCenter.y + 2 * dy / 3 }; return [fromCenter, control1, control2, toCenter]; } private drawArrow(from: Point, to: Point): void { const headLength = 10; const angle = Math.atan2(to.y - from.y, to.x - from.x); this.ctx.beginPath(); this.ctx.moveTo(to.x, to.y); this.ctx.lineTo( to.x - headLength * Math.cos(angle - Math.PI / 6), to.y - headLength * Math.sin(angle - Math.PI / 6) ); this.ctx.moveTo(to.x, to.y); this.ctx.lineTo( to.x - headLength * Math.cos(angle + Math.PI / 6), to.y - headLength * Math.sin(angle + Math.PI / 6) ); this.ctx.stroke(); } private getMidPoint(points: Point[]): Point { const mid = Math.floor(points.length / 2); return points[mid]; } // Mouse event handlers onMouseDown(event: MouseEvent): void { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; // Find clicked node this.selectedNode = this.nodes.find(node => x >= node.x && x <= node.x + node.width && y >= node.y && y <= node.y + node.height ) || null; if (this.selectedNode) { this.selectedNode.isDragging = true; this.dragOffset = { x: x - this.selectedNode.x, y: y - this.selectedNode.y }; } } onMouseMove(event: MouseEvent): void { if (this.selectedNode?.isDragging) { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; this.selectedNode.x = x - this.dragOffset.x; this.selectedNode.y = y - this.dragOffset.y; this.draw(); } } onMouseUp(): void { if (this.selectedNode) { this.selectedNode.isDragging = false; this.selectedNode = null; } } // Auto layout implementation using force-directed algorithm autoLayout(): void { const iterations = 100; const velocities = this.nodes.map(() => ({ x: 0, y: 0 })); for (let i = 0; i < iterations; i++) { // Calculate forces this.nodes.forEach((node1, i) => { velocities[i] = { x: 0, y: 0 }; // Repulsion forces between nodes this.nodes.forEach((node2, j) => { if (i !== j) { const dx = node2.x - node1.x; const dy = node2.y - node1.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < this.MIN_DISTANCE) { const force = this.REPULSION / (distance * distance); velocities[i].x -= (dx / distance) * force; velocities[i].y -= (dy / distance) * force; } } }); // Attraction forces along edges this.edges.forEach(edge => { if (edge.from === node1.id) { const node2 = this.nodes.find(n => n.id === edge.to)!; const dx = node2.x - node1.x; const dy = node2.y - node1.y; const distance = Math.sqrt(dx * dx + dy * dy); velocities[i].x += dx * this.ATTRACTION; velocities[i].y += dy * this.ATTRACTION; } }); }); // Apply velocities with damping this.nodes.forEach((node, i) => { node.x += velocities[i].x * this.DAMPING; node.y += velocities[i].y * this.DAMPING; }); } this.draw(); } }
|   |   |   |   |   --- ixt-flow.index.ts: // ixt-flow.index.ts export * from './ixt-flow.module'; export * from './ixt-flow.diagram'; // You might also want to export these interfaces for external use export interface FlowNode { id: string; x: number; y: number; width: number; height: number; type: 'rectangle' | 'diamond' | 'circle'; label: string; isDragging: boolean; } export interface FlowEdge { from: string; to: string; label?: string; } // export interface Point { // x: number; // y: number; // } // Optional: Add configuration interface if you want to allow customization export interface IxtFlowConfig { canvasWidth?: number; canvasHeight?: number; nodeDefaults?: { width: number; height: number; padding: number; }; layout?: { repulsion: number; attraction: number; damping: number; minDistance: number; }; style?: { nodeFill: string; nodeStroke: string; edgeColor: string; textColor: string; fontFamily: string; fontSize: number; }; }
|   |   |   |   |   --- ixt-flow.module.ts: // ixt-flow.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtFlowDiagram } from './ixt-flow.diagram'; @NgModule({ declarations: [ IxtFlowDiagram ], imports: [ CommonModule ], exports: [ IxtFlowDiagram ], providers: [] }) export class IxtFlowModule { static forRoot() { return { ngModule: IxtFlowModule, providers: [] }; } static forChild() { return { ngModule: IxtFlowModule, providers: [] }; } }
|   |   |   |   +-- gannt
|   |   |   |   |   --- gannt.diagram.html: <empty file>
|   |   |   |   |   --- gannt.diagram.ts: // ixt-gannt.diagram.ts import { Component, OnInit, ViewChild, ElementRef, AfterViewInit } from '@angular/core'; interface FlightPuck { id: string; startTime: Date; endTime: Date; aircraft: number; fromStation: string; toStation: string; x: number; y: number; width: number; } @Component({ selector: 'gannt-diagram', template: ` <div class="scheduler-container" (mousemove)="onMouseMove($event)" (mouseup)="onMouseUp()"> <canvas #schedulerCanvas [width]="canvasWidth" [height]="canvasHeight" (mousedown)="onMouseDown($event)"> </canvas> </div> `, styles: [` .scheduler-container { width: 100%; height: 600px; overflow: auto; position: relative; background: #f5f5f5; } canvas { cursor: default; } `] }) export class IxtGanntDiagram implements OnInit, AfterViewInit { @ViewChild('schedulerCanvas') canvasRef!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; private flights: FlightPuck[] = []; // Canvas dimensions canvasWidth = 2400; // 24 hours * 100 pixels per hour canvasHeight = 500; // 5 aircraft lanes * 100 pixels height // Layout constants private readonly HOUR_WIDTH = 100; private readonly LANE_HEIGHT = 100; private readonly MIN_FLIGHT_DURATION = 60; // 1 hour in minutes private readonly MAX_FLIGHT_DURATION = 240; // 4 hours in minutes private readonly MIN_GROUND_TIME = 30; // 30 minutes between flights // Drag state private isDragging = false; private selectedPuck: FlightPuck | null = null; private dragOffsetX = 0; private dragOffsetY = 0; private isResizing = false; private resizeEdge: 'start' | 'end' | null = null; // Sample airports for domestic routes private airports = ['ORD', 'LAX', 'SFO', 'EWR', 'DEN', 'IAH', 'DFW']; constructor() { this.generateSampleFlights(); } ngOnInit(): void {} ngAfterViewInit(): void { this.ctx = this.canvasRef.nativeElement.getContext('2d')!; this.draw(); } private generateSampleFlights(): void { // Generate sample flights for each aircraft for (let aircraft = 0; aircraft < 5; aircraft++) { let startTime = new Date(); startTime.setHours(6, 0, 0, 0); // Start at 6 AM // Generate 2-3 flights per aircraft const numFlights = 2 + Math.floor(Math.random() * 2); for (let i = 0; i < numFlights; i++) { const duration = 60 + Math.floor(Math.random() * 180); // 1-4 hours const fromStation = this.airports[Math.floor(Math.random() * this.airports.length)]; let toStation; do { toStation = this.airports[Math.floor(Math.random() * this.airports.length)]; } while (toStation === fromStation); const endTime = new Date(startTime.getTime() + duration * 60000); this.flights.push({ id: `${aircraft}-${i}`, startTime: new Date(startTime), endTime: new Date(endTime), aircraft, fromStation, toStation, x: this.timeToX(startTime), y: aircraft * this.LANE_HEIGHT, width: this.calculateWidth(startTime, endTime) }); // Add ground time for next flight startTime = new Date(endTime.getTime() + this.MIN_GROUND_TIME * 60000); } } } private timeToX(time: Date): number { const hours = time.getHours() + time.getMinutes() / 60; return hours * this.HOUR_WIDTH; } private calculateWidth(start: Date, end: Date): number { const durationHours = (end.getTime() - start.getTime()) / (1000 * 60 * 60); return durationHours * this.HOUR_WIDTH; } private draw(): void { this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight); this.drawGrid(); this.drawTimeline(); this.drawFlights(); } private drawGrid(): void { this.ctx.strokeStyle = '#ddd'; this.ctx.lineWidth = 1; // Draw horizontal lines (aircraft lanes) for (let i = 0; i <= 5; i++) { const y = i * this.LANE_HEIGHT; this.ctx.beginPath(); this.ctx.moveTo(0, y); this.ctx.lineTo(this.canvasWidth, y); this.ctx.stroke(); } // Draw vertical lines (hour markers) for (let i = 0; i <= 24; i++) { const x = i * this.HOUR_WIDTH; this.ctx.beginPath(); this.ctx.moveTo(x, 0); this.ctx.lineTo(x, this.canvasHeight); this.ctx.stroke(); } } private drawTimeline(): void { this.ctx.fillStyle = '#333'; this.ctx.font = '12px Arial'; this.ctx.textAlign = 'center'; for (let i = 0; i <= 24; i++) { const x = i * this.HOUR_WIDTH; const timeStr = i === 0 || i === 24 ? '12 MN' : i === 12 ? '12 NN' : i > 12 ? `${i-12} PM` : `${i} AM`; this.ctx.fillText(timeStr, x, 20); } } private drawFlights(): void { this.flights.forEach(flight => { // Draw flight puck this.ctx.fillStyle = '#4a90e2'; this.ctx.strokeStyle = '#2171c7'; this.ctx.lineWidth = 2; const puckHeight = 60; const y = flight.y + (this.LANE_HEIGHT - puckHeight) / 2; // Draw rounded rectangle this.ctx.beginPath(); this.ctx.roundRect(flight.x, y, flight.width, puckHeight, 10); this.ctx.fill(); this.ctx.stroke(); // Draw flight information this.ctx.fillStyle = 'white'; this.ctx.font = '12px Arial'; this.ctx.textAlign = 'center'; const startTime = flight.startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); const endTime = flight.endTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); const flightInfo = `${flight.fromStation} - ${flight.toStation}`; this.ctx.fillText(flightInfo, flight.x + flight.width/2, y + puckHeight/2); this.ctx.fillText(`${startTime} - ${endTime}`, flight.x + flight.width/2, y + puckHeight/2 + 15); }); } onMouseDown(event: MouseEvent): void { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; // Check if clicked on a flight puck const clickedPuck = this.findClickedPuck(x, y); if (clickedPuck) { this.selectedPuck = clickedPuck; this.isDragging = true; this.dragOffsetX = x - clickedPuck.x; this.dragOffsetY = y - clickedPuck.y; } } onMouseMove(event: MouseEvent): void { if (!this.isDragging || !this.selectedPuck) return; const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = event.clientX - rect.left - this.dragOffsetX; const y = event.clientY - rect.top - this.dragOffsetY; // Snap to lanes const newAircraft = Math.floor((y + this.LANE_HEIGHT/2) / this.LANE_HEIGHT); if (newAircraft >= 0 && newAircraft < 5) { this.selectedPuck.aircraft = newAircraft; this.selectedPuck.y = newAircraft * this.LANE_HEIGHT; } // Update x position (time) const minX = 0; const maxX = this.canvasWidth - this.selectedPuck.width; this.selectedPuck.x = Math.max(minX, Math.min(x, maxX)); // Check for conflicts if (this.hasConflict(this.selectedPuck)) { // Revert position if conflict detected this.selectedPuck.x = this.timeToX(this.selectedPuck.startTime); } else { // Update times based on new position const hourOffset = this.selectedPuck.x / this.HOUR_WIDTH; const newStartTime = new Date(); newStartTime.setHours(Math.floor(hourOffset)); newStartTime.setMinutes((hourOffset % 1) * 60); this.selectedPuck.startTime = newStartTime; this.selectedPuck.endTime = new Date(newStartTime.getTime() + (this.selectedPuck.width / this.HOUR_WIDTH) * 60 * 60 * 1000); } this.draw(); } onMouseUp(): void { this.isDragging = false; this.selectedPuck = null; this.resizeEdge = null; } private findClickedPuck(x: number, y: number): FlightPuck | null { return this.flights.find(flight => x >= flight.x && x <= flight.x + flight.width && y >= flight.y && y <= flight.y + this.LANE_HEIGHT ) || null; } private hasConflict(puck: FlightPuck): boolean { return this.flights.some(flight => { if (flight === puck) return false; if (flight.aircraft !== puck.aircraft) return false; const puckStart = puck.x / this.HOUR_WIDTH; const puckEnd = (puck.x + puck.width) / this.HOUR_WIDTH; const flightStart = flight.x / this.HOUR_WIDTH; const flightEnd = (flight.x + flight.width) / this.HOUR_WIDTH; // Check if there's less than minimum ground time between flights return !(puckEnd + (this.MIN_GROUND_TIME / 60) <= flightStart || flightEnd + (this.MIN_GROUND_TIME / 60) <= puckStart); }); } }
|   |   |   |   |   --- gannt.index.ts: // ixt-gannt.index.ts export * from './gannt.diagram'; export * from './gannt.module';
|   |   |   |   |   --- gannt.module.ts: // ixt-gannt.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtGanntDiagram } from './gannt.diagram'; @NgModule({ declarations: [ IxtGanntDiagram ], imports: [ CommonModule ], exports: [ IxtGanntDiagram ] }) export class IxtGanntModule { }
|   |   |   |   +-- network
|   |   |   |   |   --- ixt-network.diagram.html: <empty file>
|   |   |   |   |   --- ixt-network.diagram.ts: import { Component, ElementRef, ViewChild, AfterViewInit, OnDestroy } from '@angular/core'; import { fromEvent, Subscription } from 'rxjs'; import { takeUntil } from 'rxjs/operators'; interface NetworkNode { id: string; label: string; type: 'service' | 'database' | 'loadbalancer' | 'gateway' | 'cache'; x: number; y: number; width: number; height: number; vx: number; // velocity X for force-directed layout vy: number; // velocity Y for force-directed layout } interface NetworkEdge { from: string; to: string; type: 'sync' | 'async' | 'depends'; } @Component({ selector: 'ixt-network-diagram', template: ` <div class="diagram-container"> <canvas #canvas [width]="width" [height]="height" (mousedown)="onMouseDown($event)" (mousemove)="onMouseMove($event)" (mouseup)="onMouseUp()"> </canvas> <button (click)="applyForceDirectedLayout()" class="layout-button"> Auto Layout </button> </div> `, styles: [` .diagram-container { position: relative; border: 1px solid #ccc; margin: 20px; } .layout-button { position: absolute; top: 10px; right: 10px; padding: 8px 16px; background: #4a90e2; color: white; border: none; border-radius: 4px; cursor: pointer; } .layout-button:hover { background: #357abd; } `] }) export class IxtNetworkDiagram implements AfterViewInit, OnDestroy { @ViewChild('canvas') canvasRef!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; private animationFrameId: number = 0; private isDragging: boolean = false; private selectedNode: NetworkNode | null = null; private mouseOffset = { x: 0, y: 0 }; width = 1200; height = 800; // Sample network configuration nodes: NetworkNode[] = [ { id: 'api', label: 'API Gateway', type: 'gateway', x: 200, y: 200, width: 120, height: 60, vx: 0, vy: 0 }, { id: 'auth', label: 'Auth Service', type: 'service', x: 400, y: 150, width: 120, height: 60, vx: 0, vy: 0 }, { id: 'users', label: 'User Service', type: 'service', x: 600, y: 200, width: 120, height: 60, vx: 0, vy: 0 }, { id: 'userdb', label: 'User DB', type: 'database', x: 800, y: 200, width: 100, height: 60, vx: 0, vy: 0 }, { id: 'cache', label: 'Redis Cache', type: 'cache', x: 400, y: 300, width: 100, height: 60, vx: 0, vy: 0 }, { id: 'lb', label: 'Load Balancer', type: 'loadbalancer', x: 200, y: 100, width: 120, height: 60, vx: 0, vy: 0 } ]; edges: NetworkEdge[] = [ { from: 'lb', to: 'api', type: 'sync' }, { from: 'api', to: 'auth', type: 'sync' }, { from: 'api', to: 'users', type: 'sync' }, { from: 'users', to: 'userdb', type: 'sync' }, { from: 'auth', to: 'cache', type: 'async' }, { from: 'users', to: 'cache', type: 'async' } ]; private subscriptions = new Subscription(); ngAfterViewInit() { const canvas = this.canvasRef.nativeElement; this.ctx = canvas.getContext('2d')!; // Set up high DPI canvas const dpr = window.devicePixelRatio || 1; canvas.width = this.width * dpr; canvas.height = this.height * dpr; canvas.style.width = `${this.width}px`; canvas.style.height = `${this.height}px`; this.ctx.scale(dpr, dpr); this.draw(); } ngOnDestroy() { if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); } this.subscriptions.unsubscribe(); } private draw() { this.ctx.clearRect(0, 0, this.width, this.height); // Draw edges first (so they appear under nodes) this.drawEdges(); // Draw nodes this.nodes.forEach(node => this.drawNode(node)); this.animationFrameId = requestAnimationFrame(() => this.draw()); } private drawNode(node: NetworkNode) { const { x, y, width, height, label, type } = node; // Draw shadow this.ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'; this.ctx.shadowBlur = 10; this.ctx.shadowOffsetX = 3; this.ctx.shadowOffsetY = 3; // Draw node background this.ctx.beginPath(); this.ctx.roundRect(x, y, width, height, 8); // Different colors for different node types const colors = { service: '#4a90e2', database: '#50b83c', loadbalancer: '#8c4a9e', gateway: '#f5a623', cache: '#e2725b' }; this.ctx.fillStyle = colors[type]; this.ctx.fill(); // Reset shadow this.ctx.shadowColor = 'transparent'; // Draw node label this.ctx.fillStyle = 'white'; this.ctx.font = '14px Arial'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; this.ctx.fillText(label, x + width/2, y + height/2); } private drawEdges() { this.edges.forEach(edge => { const fromNode = this.nodes.find(n => n.id === edge.from)!; const toNode = this.nodes.find(n => n.id === edge.to)!; // Calculate edge points using smart routing const points = this.calculateEdgePoints(fromNode, toNode); this.ctx.beginPath(); this.ctx.moveTo(points[0].x, points[0].y); // Draw curved lines for a more professional look if (points.length === 3) { this.ctx.quadraticCurveTo( points[1].x, points[1].y, points[2].x, points[2].y ); } // Style based on edge type this.ctx.strokeStyle = edge.type === 'async' ? '#999' : '#666'; this.ctx.setLineDash(edge.type === 'async' ? [5, 5] : []); this.ctx.lineWidth = 2; this.ctx.stroke(); // Draw arrow this.drawArrow(points[points.length-2], points[points.length-1]); }); } private calculateEdgePoints(from: NetworkNode, to: NetworkNode) { // Smart edge routing to avoid node intersections const startPoint = { x: from.x + from.width/2, y: from.y + from.height/2 }; const endPoint = { x: to.x + to.width/2, y: to.y + to.height/2 }; // Calculate control point for curved lines const controlPoint = { x: (startPoint.x + endPoint.x) / 2, y: (startPoint.y + endPoint.y) / 2 }; // Adjust control point based on node positions if (Math.abs(from.y - to.y) < Math.max(from.height, to.height)) { controlPoint.y -= 50; // Curve upward if nodes are at similar heights } return [startPoint, controlPoint, endPoint]; } private drawArrow(from: {x: number, y: number}, to: {x: number, y: number}) { const angle = Math.atan2(to.y - from.y, to.x - from.x); const arrowLength = 10; this.ctx.beginPath(); this.ctx.moveTo( to.x - arrowLength * Math.cos(angle - Math.PI/6), to.y - arrowLength * Math.sin(angle - Math.PI/6) ); this.ctx.lineTo(to.x, to.y); this.ctx.lineTo( to.x - arrowLength * Math.cos(angle + Math.PI/6), to.y - arrowLength * Math.sin(angle + Math.PI/6) ); this.ctx.stroke(); } onMouseDown(event: MouseEvent) { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; // Check if we clicked on a node this.selectedNode = this.nodes.find(node => x >= node.x && x <= node.x + node.width && y >= node.y && y <= node.y + node.height ) || null; if (this.selectedNode) { this.isDragging = true; this.mouseOffset.x = x - this.selectedNode.x; this.mouseOffset.y = y - this.selectedNode.y; } } onMouseMove(event: MouseEvent) { if (this.isDragging && this.selectedNode) { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; this.selectedNode.x = x - this.mouseOffset.x; this.selectedNode.y = y - this.mouseOffset.y; // Keep node within canvas bounds this.selectedNode.x = Math.max(0, Math.min(this.width - this.selectedNode.width, this.selectedNode.x)); this.selectedNode.y = Math.max(0, Math.min(this.height - this.selectedNode.height, this.selectedNode.y)); } } onMouseUp() { this.isDragging = false; this.selectedNode = null; } applyForceDirectedLayout() { const simulation = { alpha: 1, alphaMin: 0.001, alphaDecay: 0.0228, velocityDecay: 0.4, linkDistance: 200, linkStrength: 1, repulsion: -400, iterations: 300 }; const animate = () => { if (simulation.alpha > simulation.alphaMin && simulation.iterations > 0) { this.calculateForces(simulation); simulation.alpha *= 1 - simulation.alphaDecay; simulation.iterations--; requestAnimationFrame(animate); } }; requestAnimationFrame(animate); } private calculateForces(simulation: any) { // Apply forces between all node pairs for (let i = 0; i < this.nodes.length; i++) { for (let j = i + 1; j < this.nodes.length; j++) { const nodeA = this.nodes[i]; const nodeB = this.nodes[j]; const dx = nodeB.x - nodeA.x; const dy = nodeB.y - nodeA.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance === 0) continue; // Repulsive force between all nodes const force = simulation.repulsion / (distance * distance); const forceX = (dx / distance) * force; const forceY = (dy / distance) * force; nodeA.vx -= forceX; nodeA.vy -= forceY; nodeB.vx += forceX; nodeB.vy += forceY; } } // Apply attractive forces along edges this.edges.forEach(edge => { const source = this.nodes.find(n => n.id === edge.from)!; const target = this.nodes.find(n => n.id === edge.to)!; const dx = target.x - source.x; const dy = target.y - source.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance === 0) return; const force = (distance - simulation.linkDistance) * simulation.linkStrength; const forceX = (dx / distance) * force; const forceY = (dy / distance) * force; source.vx += forceX; source.vy += forceY; target.vx -= forceX; target.vy -= forceY; }); // Update positions this.nodes.forEach(node => { node.vx *= simulation.velocityDecay; node.vy *= simulation.velocityDecay; node.x += node.vx; node.y += node.vy; // Constrain to canvas bounds node.x = Math.max(0, Math.min(this.width - node.width, node.x)); node.y = Math.max(0, Math.min(this.height - node.height, node.y)); }); } }
|   |   |   |   |   --- ixt-network.diagrams.css: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   |   --- ixt-network.index.ts: // ixt-network.index.ts export * from './ixt-network.diagram'; export * from './ixt-network.module';
|   |   |   |   |   --- ixt-network.module.ts: // ixt-network.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtNetworkDiagram } from './ixt-network.diagram'; @NgModule({ declarations: [ IxtNetworkDiagram ], imports: [ CommonModule ], exports: [ IxtNetworkDiagram ] }) export class IxtNetworkModule { }
|   |   |   |   +-- sankey
|   |   |   |   |   --- ixt-sankey.diagram.html: <empty file>
|   |   |   |   |   --- ixt-sankey.diagram.ts: import { Component, ElementRef, OnInit, ViewChild } from '@angular/core'; interface SankeyNode { name: string; value: number; } interface SankeyLink { source: number; target: number; value: number; } @Component({ selector: 'ixt-sankey-diagram', template: ` <div class="sankey-container"> <canvas #sankeyCanvas></canvas> </div> `, styles: [` .sankey-container { width: 800px; height: 600px; } canvas { width: 100%; height: 100%; } `] }) export class IxtSankeyDiagram implements OnInit { @ViewChild('sankeyCanvas', { static: true }) canvas!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; // Sample data private nodes: SankeyNode[] = [ { name: 'Total Energy', value: 1000 }, { name: 'Residential', value: 300 }, { name: 'Commercial', value: 400 }, { name: 'Industrial', value: 300 }, { name: 'Electricity', value: 450 }, { name: 'Natural Gas', value: 350 }, { name: 'Oil', value: 200 } ]; private links: SankeyLink[] = [ { source: 0, target: 1, value: 300 }, { source: 0, target: 2, value: 400 }, { source: 0, target: 3, value: 300 }, { source: 1, target: 4, value: 200 }, { source: 1, target: 5, value: 100 }, { source: 2, target: 4, value: 250 }, { source: 2, target: 5, value: 150 }, { source: 3, target: 5, value: 100 }, { source: 3, target: 6, value: 200 } ]; private readonly PADDING = 50; private readonly NODE_WIDTH = 20; private readonly NODE_SPACING = 50; private readonly COLORS = [ '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2' ]; ngOnInit() { this.initializeCanvas(); this.drawSankey(); } private initializeCanvas() { const canvas = this.canvas.nativeElement; this.ctx = canvas.getContext('2d')!; // Handle high DPI displays const dpr = window.devicePixelRatio || 1; canvas.width = canvas.offsetWidth * dpr; canvas.height = canvas.offsetHeight * dpr; this.ctx.scale(dpr, dpr); } private drawSankey() { const canvas = this.canvas.nativeElement; const width = canvas.offsetWidth; const height = canvas.offsetHeight; // Calculate node positions const nodeColumns = this.calculateNodeColumns(); const nodePositions = this.calculateNodePositions(nodeColumns, width, height); // Draw links this.links.forEach((link, index) => { const sourcePos = nodePositions[link.source]; const targetPos = nodePositions[link.target]; const sourceY = sourcePos.y + (sourcePos.height / 2); const targetY = targetPos.y + (targetPos.height / 2); this.drawLink( sourcePos.x + this.NODE_WIDTH, sourceY, targetPos.x, targetY, link.value, this.COLORS[index % this.COLORS.length] ); }); // Draw nodes nodePositions.forEach((pos, index) => { this.drawNode( pos.x, pos.y, this.NODE_WIDTH, pos.height, this.nodes[index].name, this.COLORS[index % this.COLORS.length] ); }); } private calculateNodeColumns(): number[] { const columns: number[] = new Array(this.nodes.length).fill(0); const visited = new Set<number>(); const assignColumn = (nodeIndex: number, column: number) => { if (!visited.has(nodeIndex)) { columns[nodeIndex] = Math.max(columns[nodeIndex], column); visited.add(nodeIndex); this.links .filter(link => link.source === nodeIndex) .forEach(link => assignColumn(link.target, column + 1)); } }; assignColumn(0, 0); return columns; } private calculateNodePositions(columns: number[], width: number, height: number) { const maxColumn = Math.max(...columns); const columnWidth = (width - 2 * this.PADDING) / maxColumn; const positions = this.nodes.map((node, index) => { const x = this.PADDING + columns[index] * columnWidth; const nodeHeight = (node.value / this.nodes[0].value) * (height - 2 * this.PADDING); return { x, y: (height - nodeHeight) / 2, height: nodeHeight }; }); return positions; } private drawNode(x: number, y: number, width: number, height: number, label: string, color: string) { this.ctx.fillStyle = color; this.ctx.fillRect(x, y, width, height); // Draw label this.ctx.fillStyle = '#000'; this.ctx.font = '12px Arial'; this.ctx.textAlign = 'right'; this.ctx.textBaseline = 'middle'; this.ctx.fillText(label, x - 5, y + height / 2); } private drawLink(x1: number, y1: number, x2: number, y2: number, value: number, color: string) { const controlPoint1X = x1 + (x2 - x1) / 3; const controlPoint2X = x1 + 2 * (x2 - x1) / 3; this.ctx.beginPath(); this.ctx.moveTo(x1, y1); this.ctx.bezierCurveTo( controlPoint1X, y1, controlPoint2X, y2, x2, y2 ); this.ctx.strokeStyle = color; this.ctx.lineWidth = Math.max(1, value / 20); this.ctx.stroke(); } }
|   |   |   |   |   --- ixt-sankey.index.ts: // ixt-sankey.index.ts export * from './ixt-sankey.diagram'; export * from './ixt-sankey.module';
|   |   |   |   |   --- ixt-sankey.module.ts: // ixt-sankey.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtSankeyDiagram } from './ixt-sankey.diagram'; @NgModule({ declarations: [ IxtSankeyDiagram ], imports: [ CommonModule ], exports: [ IxtSankeyDiagram ] }) export class IxtSankeyModule { }
|   |   |   |   +-- sequence
|   |   |   |   |   --- model.ts: // src/app/sequence-diagram/models.ts export interface Participant { type: 'actor' | 'component'; name: string; x?: number; } export interface Message { from: string; to: string; text: string; type: 'sync' | 'return'; y?: number; } export interface DiagramData { participants: Participant[]; messages: Message[]; }
|   |   |   |   |   --- parser.service.ts: // src/app/sequence-diagram/parser.service.ts import { Injectable } from '@angular/core'; import { DiagramData, Participant, Message } from './model'; @Injectable({ providedIn: 'root' }) export class DiagramParserService { parse(input: string): DiagramData { const lines = input.trim().split('\n').map(line => line.trim()); const participants: Participant[] = []; const messages: Message[] = []; lines.forEach(line => { if (line.startsWith('actor')) { const name = line.replace('actor', '').trim(); participants.push({ type: 'actor', name }); } else if (line.startsWith('participant')) { const name = line.replace('participant', '').trim(); participants.push({ type: 'component', name }); } else if (line.includes('->')) { const parts = line.split('->'); if (parts.length === 2) { const [from, rest] = parts; const [to, text] = rest.split(':').map(s => s.trim()); messages.push({ from: from.trim(), to: to.trim(), text: text || '', type: 'sync' }); } } else if (line.includes('-->')) { const parts = line.split('-->'); if (parts.length === 2) { const [from, rest] = parts; const [to, text] = rest.split(':').map(s => s.trim()); messages.push({ from: from.trim(), to: to.trim(), text: text || '', type: 'return' }); } } }); return { participants, messages }; } }
|   |   |   |   |   --- sequence-diagram.component.ts: // src/app/sequence-diagram/sequence-diagram.component.ts import { Component, ElementRef, Input, ViewChild, OnInit } from '@angular/core'; import { DiagramParserService } from './parser.service'; import { DiagramData, Participant } from './model'; @Component({ selector: 'app-sequence-diagram', template: ` <canvas #canvas [width]="800" [height]="600" style="border: 1px solid #ccc;"> </canvas> ` }) export class SequenceDiagramComponent implements OnInit { @ViewChild('canvas', { static: true }) private canvas!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; private data!: DiagramData; @Input() set diagram(value: string) { this.data = this.parser.parse(value); this.calculatePositions(); this.render(); } constructor(private parser: DiagramParserService) {} ngOnInit() { const context = this.canvas.nativeElement.getContext('2d'); if (!context) { throw new Error('Canvas 2D context not supported'); } this.ctx = context; } private calculatePositions() { const spacing = 150; this.data.participants.forEach((p, index) => { p.x = 100 + (index * spacing); }); let currentY = 100; this.data.messages.forEach(msg => { msg.y = currentY; currentY += 50; }); } private render() { this.clear(); this.drawParticipants(); this.drawLifelines(); this.drawMessages(); } private clear() { const canvas = this.canvas.nativeElement; this.ctx.clearRect(0, 0, canvas.width, canvas.height); } private drawParticipants() { this.ctx.font = '12px Arial'; this.ctx.textAlign = 'center'; this.data.participants.forEach(p => { if (p.x === undefined) return; if (p.type === 'actor') { this.drawActor(p); } else { this.drawComponent(p); } }); } private drawActor(p: Participant) { if (p.x === undefined) return; const x = p.x; const y = 30; // Head this.ctx.beginPath(); this.ctx.arc(x, y, 10, 0, Math.PI * 2); this.ctx.stroke(); // Body this.ctx.beginPath(); this.ctx.moveTo(x, y + 10); this.ctx.lineTo(x, y + 30); this.ctx.moveTo(x - 15, y + 20); this.ctx.lineTo(x + 15, y + 20); this.ctx.moveTo(x, y + 30); this.ctx.lineTo(x - 10, y + 45); this.ctx.moveTo(x, y + 30); this.ctx.lineTo(x + 10, y + 45); this.ctx.stroke(); // Label this.ctx.fillText(p.name, x, y + 60); } private drawComponent(p: Participant) { if (p.x === undefined) return; const width = 100; const height = 40; const x = p.x - width / 2; const y = 30; this.ctx.strokeRect(x, y, width, height); this.ctx.fillText(p.name, p.x, y + height / 2); } private drawLifelines() { this.ctx.setLineDash([5, 5]); this.data.participants.forEach(p => { if (p.x === undefined) return; this.ctx.beginPath(); this.ctx.moveTo(p.x, 90); this.ctx.lineTo(p.x, 500); this.ctx.stroke(); }); this.ctx.setLineDash([]); } private drawMessages() { this.data.messages.forEach(msg => { const fromX = this.getParticipantX(msg.from); const toX = this.getParticipantX(msg.to); if (fromX === undefined || toX === undefined || msg.y === undefined) return; // Arrow line this.ctx.beginPath(); if (msg.type === 'return') { this.ctx.setLineDash([5, 5]); } else { this.ctx.setLineDash([]); } this.ctx.moveTo(fromX, msg.y); this.ctx.lineTo(toX, msg.y); this.ctx.stroke(); // Arrow head const arrowSize = 10; const direction = fromX < toX ? 1 : -1; this.ctx.beginPath(); this.ctx.moveTo(toX, msg.y); this.ctx.lineTo(toX - direction * arrowSize, msg.y - arrowSize/2); this.ctx.lineTo(toX - direction * arrowSize, msg.y + arrowSize/2); this.ctx.closePath(); if (msg.type === 'sync') { this.ctx.fill(); } else { this.ctx.stroke(); } // Message text this.ctx.fillText(msg.text, (fromX + toX)/2, msg.y - 10); }); } private getParticipantX(name: string): number | undefined { return this.data.participants.find(p => p.name === name)?.x; } }
|   |   |   |   |   --- sequence-diagram.module.ts: // src/app/sequence-diagram/sequence-diagram.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { SequenceDiagramComponent } from './sequence-diagram.component'; import { DiagramParserService } from './parser.service'; @NgModule({ declarations: [SequenceDiagramComponent], imports: [CommonModule], exports: [SequenceDiagramComponent], providers: [DiagramParserService] }) export class SequenceDiagramModule { }
|   |   |   |   \-- wireframe
|   |   |   |       --- ixt-wireframe.diagram.html: <empty file>
|   |   |   |       --- ixt-wireframe.diagram.ts: // ixt-wireframe-diagram.ts import { Component, ElementRef, OnInit, ViewChild } from '@angular/core'; interface WireframeShape { id: string; type: string; x: number; y: number; width: number; height: number; text?: string; layer: number; properties?: any; } interface Point { x: number; y: number; } @Component({ selector: 'ixt-wireframe', template: ` <div class="wireframe-container"> <!-- Left Toolbar --> <div class="toolbar"> <div class="shape-palette"> <div *ngFor="let shape of availableShapes" class="shape-item" draggable="true" (dragstart)="onDragStart($event, shape)"> {{ shape.name }} </div> </div> </div> <!-- Main Canvas Area --> <div class="canvas-container"> <!-- Top Ruler --> <canvas #topRuler class="ruler top-ruler"></canvas> <!-- Left Ruler --> <canvas #leftRuler class="ruler left-ruler"></canvas> <!-- Main Canvas --> <div class="canvas-wrapper"> <canvas #mainCanvas (mousedown)="onMouseDown($event)" (mousemove)="onMouseMove($event)" (mouseup)="onMouseUp($event)" (wheel)="onWheel($event)"> </canvas> </div> </div> <!-- Controls --> <div class="controls"> <button (click)="toggleGrid()">Toggle Grid</button> <button (click)="toggleSnap()">Toggle Snap</button> <button (click)="resetZoom()">Reset Zoom</button> <div class="alignment-controls"> <button (click)="alignSelected('left')">Align Left</button> <button (click)="alignSelected('center')">Align Center</button> <button (click)="alignSelected('right')">Align Right</button> <button (click)="alignSelected('top')">Align Top</button> <button (click)="alignSelected('middle')">Align Middle</button> <button (click)="alignSelected('bottom')">Align Bottom</button> </div> </div> </div> `, styles: [` .wireframe-container { display: flex; height: 100%; } .toolbar { width: 200px; border-right: 1px solid #ccc; padding: 10px; } .canvas-container { flex: 1; position: relative; } .ruler { position: absolute; background: #f5f5f5; } .top-ruler { height: 20px; left: 20px; right: 0; } .left-ruler { width: 20px; top: 20px; bottom: 0; } .canvas-wrapper { position: absolute; top: 20px; left: 20px; right: 0; bottom: 0; overflow: hidden; } .controls { position: absolute; top: 10px; right: 10px; z-index: 100; } .shape-item { padding: 8px; margin: 4px; border: 1px solid #ccc; cursor: move; } `] }) export class IxtWireframeDiagram implements OnInit { @ViewChild('mainCanvas', { static: true }) mainCanvas!: ElementRef<HTMLCanvasElement>; @ViewChild('topRuler', { static: true }) topRuler!: ElementRef<HTMLCanvasElement>; @ViewChild('leftRuler', { static: true }) leftRuler!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; private shapes: WireframeShape[] = []; private selectedShapes: Set<string> = new Set(); private isDragging = false; private dragStart: Point = { x: 0, y: 0 }; private dragOffset: Point = { x: 0, y: 0 }; private scale = 1; private panOffset: Point = { x: 0, y: 0 }; private showGrid = true; private snapEnabled = false; private gridSize = 20; availableShapes = [ { name: 'Button', type: 'button', defaultWidth: 100, defaultHeight: 30 }, { name: 'Text Field', type: 'textfield', defaultWidth: 200, defaultHeight: 30 }, { name: 'Checkbox', type: 'checkbox', defaultWidth: 20, defaultHeight: 20 }, { name: 'Radio Button', type: 'radio', defaultWidth: 20, defaultHeight: 20 }, { name: 'Select', type: 'select', defaultWidth: 200, defaultHeight: 30 }, { name: 'Table', type: 'table', defaultWidth: 400, defaultHeight: 300 }, { name: 'Panel', type: 'panel', defaultWidth: 300, defaultHeight: 200 }, { name: 'Dialog', type: 'dialog', defaultWidth: 400, defaultHeight: 300 }, { name: 'Menu', type: 'menu', defaultWidth: 150, defaultHeight: 200 }, { name: 'Tree', type: 'tree', defaultWidth: 200, defaultHeight: 400 } ]; ngOnInit() { this.initializeCanvas(); this.initializeRulers(); this.draw(); } private initializeCanvas() { const canvas = this.mainCanvas.nativeElement; this.ctx = canvas.getContext('2d')!; this.resizeCanvas(); window.addEventListener('resize', () => this.resizeCanvas()); } private resizeCanvas() { const canvas = this.mainCanvas.nativeElement; const container = canvas.parentElement!; canvas.width = container.clientWidth; canvas.height = container.clientHeight; this.draw(); } private initializeRulers() { // Initialize top ruler const topRuler = this.topRuler.nativeElement; const topCtx = topRuler.getContext('2d')!; topRuler.width = this.mainCanvas.nativeElement.width; topRuler.height = 20; // Initialize left ruler const leftRuler = this.leftRuler.nativeElement; const leftCtx = leftRuler.getContext('2d')!; leftRuler.width = 20; leftRuler.height = this.mainCanvas.nativeElement.height; this.drawRulers(); } private drawRulers() { // Draw top ruler const topCtx = this.topRuler.nativeElement.getContext('2d')!; topCtx.clearRect(0, 0, this.topRuler.nativeElement.width, this.topRuler.nativeElement.height); // Draw left ruler const leftCtx = this.leftRuler.nativeElement.getContext('2d')!; leftCtx.clearRect(0, 0, this.leftRuler.nativeElement.width, this.leftRuler.nativeElement.height); // Draw measurements on rulers // ... (implementation for drawing ruler measurements) } private draw() { this.ctx.clearRect(0, 0, this.mainCanvas.nativeElement.width, this.mainCanvas.nativeElement.height); if (this.showGrid) { this.drawGrid(); } this.shapes.forEach(shape => this.drawShape(shape)); } private drawGrid() { const canvas = this.mainCanvas.nativeElement; this.ctx.strokeStyle = '#eee'; this.ctx.lineWidth = 1; // Draw vertical lines for (let x = 0; x < canvas.width; x += this.gridSize) { this.ctx.beginPath(); this.ctx.moveTo(x, 0); this.ctx.lineTo(x, canvas.height); this.ctx.stroke(); } // Draw horizontal lines for (let y = 0; y < canvas.height; y += this.gridSize) { this.ctx.beginPath(); this.ctx.moveTo(0, y); this.ctx.lineTo(canvas.width, y); this.ctx.stroke(); } } private drawShape(shape: WireframeShape) { const isSelected = this.selectedShapes.has(shape.id); this.ctx.save(); this.ctx.scale(this.scale, this.scale); this.ctx.translate(this.panOffset.x, this.panOffset.y); // Draw shape based on type switch (shape.type) { case 'button': this.drawButton(shape, isSelected); break; case 'textfield': this.drawTextField(shape, isSelected); break; // ... (implement other shape drawing methods) } this.ctx.restore(); } private drawButton(shape: WireframeShape, isSelected: boolean) { this.ctx.fillStyle = '#f0f0f0'; this.ctx.strokeStyle = isSelected ? '#0066ff' : '#000'; this.ctx.lineWidth = isSelected ? 2 : 1; this.ctx.beginPath(); this.ctx.roundRect(shape.x, shape.y, shape.width, shape.height, 5); this.ctx.fill(); this.ctx.stroke(); if (shape.text) { this.ctx.fillStyle = '#000'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; this.ctx.fillText(shape.text, shape.x + shape.width / 2, shape.y + shape.height / 2); } } private drawTextField(shape: WireframeShape, isSelected: boolean) { this.ctx.fillStyle = '#fff'; this.ctx.strokeStyle = isSelected ? '#0066ff' : '#000'; this.ctx.lineWidth = isSelected ? 2 : 1; this.ctx.beginPath(); this.ctx.rect(shape.x, shape.y, shape.width, shape.height); this.ctx.fill(); this.ctx.stroke(); if (shape.text) { this.ctx.fillStyle = '#000'; this.ctx.textAlign = 'left'; this.ctx.textBaseline = 'middle'; this.ctx.fillText(shape.text, shape.x + 5, shape.y + shape.height / 2); } } onDragStart(event: DragEvent, shape: any) { event.dataTransfer?.setData('text/plain', shape.type); } onMouseDown(event: MouseEvent) { const pos = this.getCanvasPosition(event); this.isDragging = true; this.dragStart = pos; // Check if clicked on a shape const clickedShape = this.findShapeAtPosition(pos); if (clickedShape) { if (!event.ctrlKey) { this.selectedShapes.clear(); } this.selectedShapes.add(clickedShape.id); this.dragOffset = { x: pos.x - clickedShape.x, y: pos.y - clickedShape.y }; } else { this.selectedShapes.clear(); } this.draw(); } onMouseMove(event: MouseEvent) { if (!this.isDragging) return; const pos = this.getCanvasPosition(event); const dx = pos.x - this.dragStart.x; const dy = pos.y - this.dragStart.y; if (this.selectedShapes.size > 0) { this.shapes.forEach(shape => { if (this.selectedShapes.has(shape.id)) { shape.x += dx; shape.y += dy; if (this.snapEnabled) { shape.x = Math.round(shape.x / this.gridSize) * this.gridSize; shape.y = Math.round(shape.y / this.gridSize) * this.gridSize; } } }); } else { // Pan the canvas this.panOffset.x += dx; this.panOffset.y += dy; } this.dragStart = pos; this.draw(); } onMouseUp(_event: MouseEvent) { // Add underscore to indicate unused parameter this.isDragging = false; } onWheel(event: WheelEvent) { event.preventDefault(); const pos = this.getCanvasPosition(event); // Calculate zoom const delta = event.deltaY > 0 ? 0.9 : 1.1; const newScale = this.scale * delta; // Limit zoom range if (newScale >= 0.1 && newScale <= 5) { this.scale = newScale; // Adjust pan offset to zoom towards mouse position this.panOffset.x = pos.x - (pos.x - this.panOffset.x) * delta; this.panOffset.y = pos.y - (pos.y - this.panOffset.y) * delta; this.draw(); } } private getCanvasPosition(event: MouseEvent): Point { const rect = this.mainCanvas.nativeElement.getBoundingClientRect(); return { x: (event.clientX - rect.left) / this.scale - this.panOffset.x, y: (event.clientY - rect.top) / this.scale - this.panOffset.y }; } private findShapeAtPosition(pos: Point): WireframeShape | null { // Search shapes in reverse order to find top-most shape first for (let i = this.shapes.length - 1; i >= 0; i--) { const shape = this.shapes[i]; if (pos.x >= shape.x && pos.x <= shape.x + shape.width && pos.y >= shape.y && pos.y <= shape.y + shape.height) { return shape; } } return null; } toggleGrid() { this.showGrid = !this.showGrid; this.draw(); } toggleSnap() { this.snapEnabled = !this.snapEnabled; } resetZoom() { this.scale = 1; this.panOffset = { x: 0, y: 0 }; this.draw(); } alignSelected(alignment: string) { if (this.selectedShapes.size < 2) return; const selectedShapes = this.shapes.filter(s => this.selectedShapes.has(s.id)); switch (alignment) { case 'left': const leftMost = Math.min(...selectedShapes.map(s => s.x)); selectedShapes.forEach(s => s.x = leftMost); break; case 'center': const centerX = selectedShapes.reduce((acc, s) => acc + s.x + s.width / 2, 0) / selectedShapes.length; selectedShapes.forEach(s => s.x = centerX - s.width / 2); break; case 'right': const rightMost = Math.max(...selectedShapes.map(s => s.x + s.width)); selectedShapes.forEach(s => s.x = rightMost - s.width); break; case 'top': const topMost = Math.min(...selectedShapes.map(s => s.y)); selectedShapes.forEach(s => s.y = topMost); break; case 'middle': const centerY = selectedShapes.reduce((acc, s) => acc + s.y + s.height / 2, 0) / selectedShapes.length; selectedShapes.forEach(s => s.y = centerY - s.height / 2); break; case 'bottom': const bottomMost = Math.max(...selectedShapes.map(s => s.y + s.height)); selectedShapes.forEach(s => s.y = bottomMost - s.height); break; } this.draw(); } // Add shape when dropped from palette onDrop(event: DragEvent) { event.preventDefault(); const shapeType = event.dataTransfer?.getData('text/plain'); const pos = this.getCanvasPosition(event as unknown as MouseEvent); if (shapeType) { const template = this.availableShapes.find(s => s.type === shapeType); if (template) { const newShape: WireframeShape = { id: `shape-${Date.now()}`, type: shapeType, x: pos.x, y: pos.y, width: template.defaultWidth, height: template.defaultHeight, text: '', layer: this.shapes.length, properties: {} }; this.shapes.push(newShape); this.selectedShapes.clear(); this.selectedShapes.add(newShape.id); this.draw(); } } } // Handle text editing for shapes onDoubleClick(event: MouseEvent) { const pos = this.getCanvasPosition(event); const shape = this.findShapeAtPosition(pos); if (shape) { const text = prompt('Enter text:', shape.text); if (text !== null) { shape.text = text; this.draw(); } } } // Resize selected shapes private initializeResizeHandles() { const handleSize = 8; const handles = [ { cursor: 'nw-resize', x: 0, y: 0 }, { cursor: 'n-resize', x: 0.5, y: 0 }, { cursor: 'ne-resize', x: 1, y: 0 }, { cursor: 'w-resize', x: 0, y: 0.5 }, { cursor: 'e-resize', x: 1, y: 0.5 }, { cursor: 'sw-resize', x: 0, y: 1 }, { cursor: 's-resize', x: 0.5, y: 1 }, { cursor: 'se-resize', x: 1, y: 1 } ]; this.selectedShapes.forEach(id => { const shape = this.shapes.find(s => s.id === id); if (shape) { handles.forEach(handle => { const x = shape.x + shape.width * handle.x - handleSize / 2; const y = shape.y + shape.height * handle.y - handleSize / 2; this.ctx.fillStyle = '#fff'; this.ctx.strokeStyle = '#0066ff'; this.ctx.fillRect(x, y, handleSize, handleSize); this.ctx.strokeRect(x, y, handleSize, handleSize); }); } }); } // Layer management bringToFront() { if (this.selectedShapes.size === 0) return; const maxLayer = Math.max(...this.shapes.map(s => s.layer)); this.shapes.forEach(shape => { if (this.selectedShapes.has(shape.id)) { shape.layer = maxLayer + 1; } }); this.sortShapesByLayer(); this.draw(); } sendToBack() { if (this.selectedShapes.size === 0) return; const minLayer = Math.min(...this.shapes.map(s => s.layer)); this.shapes.forEach(shape => { if (this.selectedShapes.has(shape.id)) { shape.layer = minLayer - 1; } }); this.sortShapesByLayer(); this.draw(); } private sortShapesByLayer() { this.shapes.sort((a, b) => a.layer - b.layer); } // Save and load functionality saveToJSON(): string { return JSON.stringify({ shapes: this.shapes, scale: this.scale, panOffset: this.panOffset, showGrid: this.showGrid, snapEnabled: this.snapEnabled }); } loadFromJSON(json: string) { try { const data = JSON.parse(json); this.shapes = data.shapes; this.scale = data.scale; this.panOffset = data.panOffset; this.showGrid = data.showGrid; this.snapEnabled = data.snapEnabled; this.selectedShapes.clear(); this.draw(); } catch (error) { console.error('Error loading wireframe:', error); } } // Export functionality exportAsPNG(): string { return this.mainCanvas.nativeElement.toDataURL('image/png'); } // Undo/Redo support private undoStack: any[] = []; private redoStack: any[] = []; private saveState() { this.undoStack.push(this.saveToJSON()); this.redoStack = []; } undo() { if (this.undoStack.length > 0) { const currentState = this.saveToJSON(); this.redoStack.push(currentState); const previousState = this.undoStack.pop()!; this.loadFromJSON(previousState); } } redo() { if (this.redoStack.length > 0) { const currentState = this.saveToJSON(); this.undoStack.push(currentState); const nextState = this.redoStack.pop()!; this.loadFromJSON(nextState); } } }
|   |   |   |       --- ixt-wireframe.index.ts: // ixt-wireframe.index.ts export * from './ixt-wireframe.module'; export * from './ixt-wireframe.diagram';
|   |   |   |       --- ixt-wireframe.module.ts: // ixt-wireframe.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { DragDropModule } from '@angular/cdk/drag-drop'; import { IxtWireframeDiagram } from './ixt-wireframe.diagram'; @NgModule({ declarations: [ IxtWireframeDiagram ], imports: [ CommonModule, FormsModule, DragDropModule ], exports: [ IxtWireframeDiagram ], providers: [] }) export class IxtWireframeModule { // If you need to do any module-level configuration, you can use the forRoot pattern static forRoot() { return { ngModule: IxtWireframeModule, providers: [ // Add any providers that should be singleton across the app ] }; } } // Optional: Add configuration types if needed export interface IxtWireframeConfig { gridSize?: number; snapThreshold?: number; defaultShapes?: Array<{ name: string; type: string; defaultWidth: number; defaultHeight: number; }>; maxUndoSteps?: number; } // Optional: Add service interfaces if needed export interface IxtWireframeService { saveTemplate(name: string, template: any): Promise<void>; loadTemplate(name: string): Promise<any>; listTemplates(): Promise<string[]>; }
|   |   |   --- ixt-diagram.component.html: <empty file>
|   |   |   --- ixt-diagram.component.ts: // ixt-diagram.component.ts import { Component, ElementRef, OnInit, ViewChild } from '@angular/core'; interface Participant { type: 'actor' | 'component'; name: string; x: number; } interface Message { from: string; to: string; text: string; y: number; type: 'sync' | 'return' | 'self'; } interface Activation { participant: string; startY: number; endY: number; } @Component({ selector: 'ixt-diagram', template: ` <canvas #diagramCanvas width="800" height="600" [style.border]="'1px solid #ccc'"> </canvas> ` }) export class IxtDiagramComponent implements OnInit { @ViewChild('diagramCanvas', { static: true }) private canvas!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; // Sample data matching the example diagram private participants: Participant[] = [ { type: 'actor', name: 'SD Login Customer', x: 100 }, { type: 'component', name: 'LoginUI', x: 300 }, { type: 'component', name: 'LoginControl', x: 500 }, { type: 'component', name: 'UserDB', x: 700 } ]; // Update the activation data to match the screenshot private activations: Activation[] = [ { participant: 'LoginUI', startY: 150, endY: 420 }, { participant: 'LoginControl', startY: 200, endY: 420 }, { participant: 'UserDB', startY: 250, endY: 320 } // Adjusted timing ]; // Update message types to ensure sync messages have filled arrowheads private messages: Message[] = [ { from: 'SD Login Customer', to: 'LoginUI', text: 'Login(Un/Pw)', y: 150, type: 'sync' }, { from: 'LoginUI', to: 'LoginControl', text: 'login(Un/Pw)', y: 200, type: 'sync' }, { from: 'LoginControl', to: 'UserDB', text: 'search(Un/Pw)', y: 250, type: 'sync' }, { from: 'UserDB', to: 'LoginControl', text: 'status', y: 300, type: 'return' }, { from: 'LoginControl', to: 'LoginControl', text: 'validateUser', y: 350, type: 'self' }, { from: 'LoginControl', to: 'LoginUI', text: 'status', y: 400, type: 'return' } ]; ngOnInit() { this.initializeCanvas(); this.drawDiagram(); } private initializeCanvas() { const context = this.canvas.nativeElement.getContext('2d'); if (!context) { throw new Error('Canvas 2D context not supported'); } this.ctx = context; this.ctx.font = '12px Arial'; this.ctx.textAlign = 'center'; } private drawDiagram() { this.clearCanvas(); this.drawParticipants(); this.drawLifelines(); this.drawActivations(); this.drawMessages(); } private clearCanvas() { const canvas = this.canvas.nativeElement; this.ctx.clearRect(0, 0, canvas.width, canvas.height); } private drawParticipants() { this.participants.forEach(participant => { if (participant.type === 'actor') { this.drawActor(participant); } else { this.drawComponent(participant); } }); } private drawActor(participant: Participant) { const x = participant.x; const y = 30; this.ctx.strokeStyle = '#000'; // Draw stick figure // Head this.ctx.beginPath(); this.ctx.arc(x, y, 10, 0, Math.PI * 2); this.ctx.stroke(); // Body this.ctx.beginPath(); this.ctx.moveTo(x, y + 10); this.ctx.lineTo(x, y + 30); this.ctx.stroke(); // Arms this.ctx.beginPath(); this.ctx.moveTo(x - 15, y + 20); this.ctx.lineTo(x + 15, y + 20); this.ctx.stroke(); // Legs this.ctx.beginPath(); this.ctx.moveTo(x, y + 30); this.ctx.lineTo(x - 10, y + 45); this.ctx.moveTo(x, y + 30); this.ctx.lineTo(x + 10, y + 45); this.ctx.stroke(); // Label this.ctx.fillStyle = '#000'; this.drawLabel(participant.name, x, y + 60); } private drawComponent(participant: Participant) { const width = 100; const height = 40; const x = participant.x - width / 2; const y = 30; // Draw box this.ctx.strokeStyle = '#000'; this.ctx.fillStyle = '#fff'; this.ctx.beginPath(); this.ctx.rect(x, y, width, height); this.ctx.fill(); this.ctx.stroke(); // Draw text this.ctx.fillStyle = '#000'; this.drawLabel(participant.name, participant.x, y + height / 2); } private drawLifelines() { this.ctx.setLineDash([5, 5]); this.ctx.strokeStyle = '#666'; this.participants.forEach(participant => { this.ctx.beginPath(); this.ctx.moveTo(participant.x, 90); this.ctx.lineTo(participant.x, 500); this.ctx.stroke(); }); this.ctx.setLineDash([]); // Reset line style } private drawMessages() { this.messages.forEach(message => { const fromX = this.getParticipantX(message.from); const toX = this.getParticipantX(message.to); this.ctx.strokeStyle = '#000'; this.ctx.fillStyle = '#000'; if (message.type === 'sync') { this.drawSyncMessage(fromX, toX, message); } else if (message.type === 'return') { this.drawReturnMessage(fromX, toX, message); } else if (message.type === 'self') { this.drawSelfMessage(fromX, message); } }); } private drawReturnMessage(fromX: number, toX: number, message: Message) { // Dashed line with open arrow this.ctx.setLineDash([5, 5]); this.ctx.beginPath(); this.ctx.moveTo(fromX, message.y); this.ctx.lineTo(toX, message.y); this.ctx.stroke(); this.ctx.setLineDash([]); // Open arrowhead this.drawArrowhead(toX, message.y, fromX < toX ? 'right' : 'left', false); // Message text this.drawLabel(message.text, (fromX + toX) / 2, message.y - 10); } private drawSelfMessage(x: number, message: Message) { const offset = 20; this.ctx.beginPath(); this.ctx.moveTo(x, message.y); this.ctx.lineTo(x + offset, message.y); this.ctx.lineTo(x + offset, message.y + 20); this.ctx.lineTo(x, message.y + 20); this.ctx.stroke(); // Filled arrowhead this.drawArrowhead(x, message.y + 20, 'left', true); // Message text this.drawLabel(message.text, x + offset + 20, message.y + 10); } private drawLabel(text: string, x: number, y: number) { this.ctx.fillStyle = '#000'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; this.ctx.fillText(text, x, y); } private getParticipantX(name: string): number { const participant = this.participants.find(p => p.name === name); if (!participant) { throw new Error(`Participant ${name} not found`); } return participant.x; } // Only showing the modified methods - the rest of the component remains the same private drawActivations() { this.ctx.fillStyle = '#fff'; this.ctx.strokeStyle = '#000'; this.activations.forEach(activation => { const participant = this.participants.find(p => p.name === activation.participant); if (participant) { // Make activation bars wider and ensure they're solid const width = 16; // Increased from 10 const x = participant.x - width / 2; // Draw solid white rectangle this.ctx.beginPath(); this.ctx.fillStyle = '#fff'; this.ctx.fillRect(x, activation.startY, width, activation.endY - activation.startY); this.ctx.strokeRect(x, activation.startY, width, activation.endY - activation.startY); } }); } private drawArrowhead(x: number, y: number, direction: 'left' | 'right', filled: boolean) { const size = 10; // Increased from 8 const angle = Math.PI / 6; const dir = direction === 'right' ? 1 : -1; this.ctx.beginPath(); this.ctx.moveTo(x, y); // Calculate arrow points const x1 = x - dir * size * Math.cos(angle); const y1 = y - size * Math.sin(angle); const x2 = x - dir * size * Math.cos(-angle); const y2 = y - size * Math.sin(-angle); this.ctx.lineTo(x1, y1); this.ctx.lineTo(x2, y2); if (filled) { this.ctx.closePath(); this.ctx.fillStyle = '#000'; this.ctx.fill(); } this.ctx.stroke(); } private drawSyncMessage(fromX: number, toX: number, message: Message) { // Draw solid line this.ctx.beginPath(); this.ctx.strokeStyle = '#000'; this.ctx.lineWidth = 1; this.ctx.moveTo(fromX, message.y); this.ctx.lineTo(toX, message.y); this.ctx.stroke(); // Always draw filled arrowhead for sync messages this.drawArrowhead(toX, message.y, fromX < toX ? 'right' : 'left', true); // Message text this.drawLabel(message.text, (fromX + toX) / 2, message.y - 10); } }
|   |   |   --- ixt-diagram.index.ts: // ixt-diagram.index.ts export * from './ixt-diagram.component'; export * from './ixt-diagram.module';
|   |   |   --- ixt-diagram.module.ts: // Later we can add additional exports like: // export * from './ixt-diagram.service'; // export * from './ixt-diagram.models'; // export * from './ixt-diagram.utils'; // ixt-diagram.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtDiagramComponent } from './ixt-diagram.component'; @NgModule({ declarations: [ IxtDiagramComponent ], imports: [ CommonModule ], exports: [ IxtDiagramComponent ] }) export class IxtDiagramModule { } /* Future imports we might need: import { FormsModule } from '@angular/forms'; import { IxtDiagramService } from './ixt-diagram.service'; import { IxtDiagramToolbarComponent } from './components/toolbar/toolbar.component'; */
|   |   |   --- ixt-network.component.html: <empty file>
|   |   +-- ixt-dialog
|   |   |   +-- types
|   |   |   |   +-- color
|   |   |   |   |   --- ixt-color.dialog.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   |   --- ixt-color.dialog.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   +-- confirm
|   |   |   |   |   --- ixt-confirm.dialog.html: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   |   --- ixt-confirm.dialog.ts: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   +-- error
|   |   |   |   |   --- ixt-error.dialog.html: // ixt-error-template.ts export const ERROR_TEMPLATE = ` <div role="alert"> <p>{{message}}</p> </div> `;
|   |   |   |   |   --- ixt-error.dialog.ts: // ixt-error-template.ts export const ERROR_TEMPLATE = ` <div role="alert"> <p>{{message}}</p> </div> `;
|   |   |   |   +-- font
|   |   |   |   |   --- ixt-font.dialog.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   |   --- ixt-font.dialog.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   |   +-- form
|   |   |   |   |   --- ixt-form.dialog.html: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   |   --- ixt-form.dialog.ts: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   +-- info
|   |   |   |   |   --- ixt-confirm.dialog.html: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   |   --- ixt-confirm.dialog.ts: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   |   --- ixt-info-template.component.ts: // ixt-info-template.component.ts import { Component, Input } from '@angular/core'; @Component({ template: ` <div role="status"> <p>{{message}}</p> </div> `, standalone: true }) export class InfoTemplateComponent { @Input() message!: string; }
|   |   |   |   +-- prompt
|   |   |   |   |   --- ixt-prompt.dialog.html: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   |   --- ixt-prompt.dialog.ts: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
|   |   |   |   +-- success
|   |   |   |   |   --- ixt-success-dialog.component.html: <div role="alert"> <p>{{ message || 'Operation completed successfully!' }}</p> </div>
|   |   |   |   |   --- ixt-success-dialog.component.ts: // ixt-success-dialog.component.ts import { Component, Input } from '@angular/core'; import { baseThemeColors } from 'src/components/theme/theme.colors'; import { ThemeVariant, ThemeColors } from 'src/components/theme/theme.types'; @Component({ selector: 'ixt-success-dialog', templateUrl: './ixt-success-dialog.component.html', styleUrls: ['./ixt-success-dialog.component.scss'] }) export class SuccessDialogComponent { @Input() message?: string; @Input() variant: ThemeVariant = 'success'; @Input() theme: ThemeColors = baseThemeColors; get themeStyles() { const colors = this.theme[this.variant]; return { 'background-color': `${colors.base}15`, // 15% opacity 'color': '#0f0', //colors.base, 'border-color': colors.base }; } }
|   |   |   |   \-- warn
|   |   |   |       --- ixt-warn.dialog.html: // ixt-warn-template.ts export const WARN_TEMPLATE = ` <div role="alert"> <p>{{message}}</p> </div> `;
|   |   |   |       --- ixt-warn.dialog.ts: // ixt-warn-template.ts export const WARN_TEMPLATE = ` <div role="alert"> <p>{{message}}</p> </div> `;
|   |   |   |       --- ixt-warn.scss.ts: // ixt-warn-template.ts export const WARN_TEMPLATE = ` <div role="alert"> <p>{{message}}</p> </div> `;
|   |   |   --- ixt-dialog.component.html: <dialog #dialog role="dialog" [ngStyle]="themeStyles"> <div role="document"> <header> <h2>{{ title }}</h2> </header> <section> <ng-template #contentHost></ng-template> </section> <footer> <button type="button" (click)="closeDialog(false)">Cancel</button> <button type="button" (click)="closeDialog(true)">OK</button> </footer> </div> </dialog>
|   |   |   --- ixt-dialog.component.ts: import { Component, ViewChild, ElementRef, Input, Output, EventEmitter, ViewContainerRef, ComponentFactoryResolver, Type, AfterViewInit } from '@angular/core'; import { baseThemeColors } from './../theme/theme.colors'; import { ThemeVariant, ThemeColors } from './../theme/theme.types'; @Component({ selector: 'ixt-dialog', templateUrl: './ixt-dialog.component.html', styleUrls: ['./ixt-dialog.component.scss'] }) export class IxtDialogComponent { @ViewChild('dialog') public dialog!: ElementRef<HTMLDialogElement>; @ViewChild('contentHost', { read: ViewContainerRef, static: true }) contentHost!: ViewContainerRef; @Input() modal: boolean = true; @Input() title: string = ''; @Input() variant: ThemeVariant = 'primary'; @Input() theme: ThemeColors = baseThemeColors; @Output() close = new EventEmitter<boolean>(); constructor() {} open() { if (this.modal) { this.dialog.nativeElement.showModal(); } else { this.dialog.nativeElement.show(); } } closeDialog(result: boolean) { this.dialog.nativeElement.close(); this.close.emit(result); } get themeStyles() { const colors = this.theme[this.variant]; return { 'background-color': colors.base, 'color': colors.text, '--theme-hover': colors.hover, '--theme-active': colors.active, '--theme-text': colors.text }; } }
|   |   |   --- ixt-dialog.index.ts: export * from './ixt-dialog.module'; export { IxtDialogComponent } from './ixt-dialog.component'; export { IxtDialogService } from './ixt-dialog.service';
|   |   |   --- ixt-dialog.module.ts: // ixt-dialog.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { MatButtonModule } from '@angular/material/button'; import { MatIconModule } from '@angular/material/icon'; import { IxtDialogComponent } from './ixt-dialog.component'; import { IxtDialogService } from './ixt-dialog.service'; // Add this import { FormsModule } from '@angular/forms'; import { SuccessDialogComponent } from './types/success/ixt-success-dialog.component'; @NgModule({ declarations: [ IxtDialogComponent, SuccessDialogComponent // Add this ], imports: [ CommonModule, MatButtonModule, MatIconModule, FormsModule ], exports: [IxtDialogComponent], providers: [IxtDialogService] // Add this }) export class IxtDialogModule { }
|   |   |   --- ixt-dialog.service.ts: // ixt-dialog.service.ts import { ApplicationRef, ComponentFactoryResolver, ComponentRef, Injectable, Injector, Type, createComponent } from '@angular/core'; import { IxtDialogComponent } from './ixt-dialog.component'; import { firstValueFrom } from 'rxjs'; import { SuccessDialogComponent } from './types/success/ixt-success-dialog.component'; @Injectable({ providedIn: 'root' }) export class IxtDialogService { private dialogComponentRef!: ComponentRef<IxtDialogComponent>; constructor( private componentFactoryResolver: ComponentFactoryResolver, private appRef: ApplicationRef, private injector: Injector ) { } // async openDialog(component: Type<any>, title: string, message: string, modal: boolean = true): Promise<boolean> { // this.dialogComponentRef = this.componentFactoryResolver // .resolveComponentFactory(IxtDialogComponent) // .create(this.injector); // const instance = this.dialogComponentRef.instance; // instance.title = title; // instance.modal = modal; // this.appRef.attachView(this.dialogComponentRef.hostView); // const domElem = (this.dialogComponentRef.hostView as any).rootNodes[0]; // document.body.appendChild(domElem); // // Allow time for component initialization // await new Promise(resolve => requestAnimationFrame(resolve)); // // Just create once and set message // const contentComponent = instance.contentHost.createComponent(component); // contentComponent.instance.message = message; // instance.open(); // // Wait for dialog result // const result = await firstValueFrom(instance.close); // document.body.removeChild(domElem); // this.appRef.detachView(this.dialogComponentRef.hostView); // this.dialogComponentRef.destroy(); // return result; // } async openDialog(component: Type<any>, title: string, message: string, modal: boolean = true): Promise<boolean> { this.dialogComponentRef = this.componentFactoryResolver .resolveComponentFactory(IxtDialogComponent) .create(this.injector); const instance = this.dialogComponentRef.instance; instance.title = title; instance.modal = modal; this.appRef.attachView(this.dialogComponentRef.hostView); const domElem = (this.dialogComponentRef.hostView as any).rootNodes[0]; document.body.appendChild(domElem); // Ensure ViewContainerRef is ready await new Promise(resolve => requestAnimationFrame(resolve)); // Clear any existing content instance.contentHost.clear(); // Create the component in the ViewContainerRef const contentComponentRef = instance.contentHost.createComponent(component); contentComponentRef.instance.message = message; instance.open(); const result = await firstValueFrom(instance.close); document.body.removeChild(domElem); this.appRef.detachView(this.dialogComponentRef.hostView); this.dialogComponentRef.destroy(); return result; } // async openDialog(component: Type<any>, title: string, message: string, modal: boolean = true): Promise<boolean> { // // Dynamically create the dialog component // this.dialogComponentRef = this.componentFactoryResolver // .resolveComponentFactory(IxtDialogComponent) // .create(this.injector); // // Attach the component to the view // this.appRef.attachView(this.dialogComponentRef.hostView); // // Append the component to the DOM // const componentElement = (this.dialogComponentRef.hostView as any).rootNodes[0]; // document.body.appendChild(componentElement); // // Set inputs on the dialog component // const instance = this.dialogComponentRef.instance; // instance.title = title; // instance.message = message; // Set message input // instance.modal = modal; // // Open the dialog // instance.open(); // // Return a promise that resolves when the dialog emits `close` // return firstValueFrom(instance.close); // } closeDialog(result: boolean): void { if (this.dialogComponentRef) { this.dialogComponentRef.instance.closeDialog(result); } } // async success(message: string, title: string): Promise<boolean> { // return await this.openDialog(SuccessDialogComponent, title, true); // } // async success(message: string, title: string): Promise<boolean> { // const dialogRef = this.componentFactoryResolver // .resolveComponentFactory(SuccessDialogComponent) // .create(this.injector); // // Set the message before creating dialog // dialogRef.instance.message = message; // return await this.openDialog(SuccessDialogComponent, message, title, true); // } async success(message: string, title: string): Promise<boolean> { return await this.openDialog(SuccessDialogComponent, title, message, true); } }
|   |   +-- ixt-expression-builder
|   |   |   --- ixt-expression-builder.component.html: <!-- ixt-expression-builder.component.html --> <div class="expression-builder"> <div class="group-container"> <select [(ngModel)]="group.operator" class="group-operator"> <option value="and">AND</option> <option value="or">OR</option> </select> <div class="expressions-list"> <div *ngFor="let node of rootGroup.children; let i = index" class="expression-row"> <div *ngIf="node.type === 'expression'" class="expression-container"> <select [(ngModel)]="node.field" class="field-select"> <option value="">Select Field</option> <option *ngFor="let field of fields" [value]="field.id"> {{field.label}} </option> </select> <select [(ngModel)]="node.operator" class="operator-select"> <option value="">Select Operator</option> <option *ngFor="let op of getOperators(node.field)" [value]="op.id"> {{op.label}} </option> </select> <ng-container [ngSwitch]="getOperatorType(node.operator)"> <input *ngSwitchCase="'single'" type="text" [(ngModel)]="node.value" class="value-input"> <div *ngSwitchCase="'multiple'" class="multi-value-container"> <div *ngFor="let val of node.values; let j = index" class="multi-value-item"> <input type="text" [(ngModel)]="node.values[j]"> <button (click)="removeValue(node, j)" class="remove-btn">×</button> </div> <button (click)="addValue(node)" class="add-value">+ Add Value</button> </div> </ng-container> <button (click)="removeExpression(i)" class="remove-btn">×</button> </div> <div *ngIf="node.type === 'group'" class="nested-group"> <ixt-expression-builder [group]="node" [level]="level + 1" (groupChange)="onChildGroupChange(i, $event)"> </ixt-expression-builder> </div> </div> </div> <div class="action-buttons"> <button (click)="addExpression()" class="add-btn">Add Expression</button> <button (click)="addGroup()" class="add-btn">Add Group</button> </div> </div> </div>
|   |   |   --- ixt-expression-builder.component.ts: // ixt-expression-builder.component.ts import { Component, Input, Output, EventEmitter, OnInit } from '@angular/core'; import { Field, Operator, Expression, ExpressionGroup } from './ixt-expression-builder.interfaces'; @Component({ selector: 'ixt-expression-builder', templateUrl: './ixt-expression-builder.component.html', styleUrls: ['./ixt-expression-builder.component.scss'], }) export class IxtExpressionBuilderComponent implements OnInit { @Input() group: ExpressionGroup = { type: 'group', operator: 'and', children: [] }; @Input() level = 0; @Output() groupChange = new EventEmitter<ExpressionGroup>(); fields: Field[] = [ { id: 'al', label: 'Airline', type: 'text' }, { id: 'base', label: 'Base', type: 'text' }, { id: 'ref', label: 'Reference', type: 'text' } ]; operators: Record<string, Operator[]> = { text: [ { id: 'eq', label: '=', type: 'single' }, { id: 'neq', label: '≠', type: 'single' }, { id: 'in', label: 'IN', type: 'multiple' }, { id: 'not_in', label: 'NOT IN', type: 'multiple' } ] }; get rootGroup(): ExpressionGroup { return this.group; } ngOnInit(): void { if (!this.group || this.group.children.length === 0) { this.group = { type: 'group', operator: 'and', children: [ { type: 'expression', field: 'al', operator: 'eq', value: 'AA', values: [] }, { type: 'group', operator: 'or', children: [ { type: 'expression', field: 'base', operator: 'in', value: '', values: ['DFW', 'ORD', 'MIA'] }, { type: 'expression', field: 'ref', operator: 'in', value: '', values: ['DFW', 'ORD', 'MIA'] } ] } ] }; this.emitChange(); // Notify parent of the initial value } } // Rest of your code remains the same... addExpression(): void { const newExpression: Expression = { type: 'expression', field: '', operator: '', value: '', values: [] }; this.group.children.push(newExpression); this.emitChange(); } addGroup(): void { const newGroup: ExpressionGroup = { type: 'group', operator: 'and', children: [] }; this.group.children.push(newGroup); this.emitChange(); } removeExpression(index: number): void { this.group.children.splice(index, 1); this.emitChange(); } getOperators(fieldId: string): Operator[] { const field = this.fields.find(f => f.id === fieldId); return field ? this.operators[field.type] || [] : []; } getOperatorType(operatorId: string): 'single' | 'multiple' | null { for (const operators of Object.values(this.operators)) { const operator = operators.find(op => op.id === operatorId); if (operator) { return operator.type; } } return null; } addValue(expression: Expression): void { if (!expression.values) { expression.values = []; } expression.values.push(''); this.emitChange(); } removeValue(expression: Expression, index: number): void { if (expression.values) { expression.values.splice(index, 1); this.emitChange(); } } onChildGroupChange(index: number, childGroup: ExpressionGroup): void { this.group.children[index] = childGroup; this.emitChange(); } toJsonLogic(): any { return this.convertToJsonLogic(this.group); } private convertToJsonLogic(node: Expression | ExpressionGroup): any { if (node.type === 'expression') { if (node.operator === 'in' || node.operator === 'not_in') { return { [node.operator === 'in' ? 'in' : '!in']: [ { var: node.field }, node.values || [] ] }; } return { [node.operator]: [ { var: node.field }, node.value ] }; } if (node.children.length === 0) return true; if (node.children.length === 1) { return this.convertToJsonLogic(node.children[0]); } return { [node.operator]: node.children.map(child => this.convertToJsonLogic(child)) }; } private emitChange(): void { this.groupChange.emit(this.group); } updateValue(expression: Expression, index: number, value: string): void { if (!expression.values) { expression.values = []; } expression.values[index] = value; this.emitChange(); } }
|   |   |   --- ixt-expression-builder.index.ts: // ixt-expression-builder.index.ts export * from './ixt-expression-builder.component'; export * from './ixt-expression-builder.module'; export interface ExpressionNode { id: string; field: string; operator: string; value: string; type: 'expression'; values: string[]; } export interface ExpressionGroup { type: 'group'; operator: 'and' | 'or'; children: (Expression | ExpressionGroup)[]; } export interface Expression { type: 'expression'; field: string; operator: string; value: string; values: string[]; }
|   |   |   --- ixt-expression-builder.interfaces.ts: // ixt-expression-builder.interfaces.ts export interface Field { id: string; label: string; type: string; } export interface Operator { id: string; label: string; type: 'single' | 'multiple'; } // ixt-expression-builder.interfaces.ts - Update the Expression interface export interface Expression { type: 'expression'; field: string; operator: string; value: string; values: string[]; } export interface ExpressionGroup { type: 'group'; operator: 'and' | 'or'; children: (Expression | ExpressionGroup)[]; }
|   |   |   --- ixt-expression-builder.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtExpressionBuilderComponent } from './ixt-expression-builder.component'; @NgModule({ declarations: [ IxtExpressionBuilderComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtExpressionBuilderComponent ] }) export class IxtExpressionBuilderModule { }
|   |   +-- ixt-form
|   |   |   +-- ixt-binary
|   |   |   |   --- ixt-binary..module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTextEditorComponent } from './ixt-text-editor.component'; @NgModule({ declarations: [ IxtTextEditorComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtTextEditorComponent ] }) export class IxtTableModule { }
|   |   |   |   --- ixt-binary.editor.html: <p>ixt-text-editor works!</p>
|   |   |   |   --- ixt-binary.editor.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-text-editor', templateUrl: './ixt-text-editor.component.html', styleUrls: ['./ixt-text-editor.component.scss'] }) export class IxtTextEditorComponent { }
|   |   |   +-- ixt-date
|   |   |   |   --- ixt-date..module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTextEditorComponent } from './ixt-text-editor.component'; @NgModule({ declarations: [ IxtTextEditorComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtTextEditorComponent ] }) export class IxtTableModule { }
|   |   |   |   --- ixt-date.editor.html: <p>ixt-text-editor works!</p>
|   |   |   |   --- ixt-date.editor.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-text-editor', templateUrl: './ixt-text-editor.component.html', styleUrls: ['./ixt-text-editor.component.scss'] }) export class IxtTextEditorComponent { }
|   |   |   +-- ixt-input
|   |   |   |   --- ixt-input.editor.html: <p>ixt-input works!</p>
|   |   |   |   --- ixt-input.editor.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-input', templateUrl: './ixt-input.component.html', styleUrls: ['./ixt-input.component.scss'] }) export class IxtInputComponent { }
|   |   |   |   --- ixt-input.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtInputComponent } from './ixt-input.component'; @NgModule({ declarations: [ IxtInputComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtInputComponent ] }) export class IxtInputModule { }
|   |   |   +-- ixt-select
|   |   |   |   --- ixt-select.editor.html: <p>ixt-select works!</p>
|   |   |   |   --- ixt-select.editor.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-select', templateUrl: './ixt-select.component.html', styleUrls: ['./ixt-select.component.scss'] }) export class IxtSelectComponent { }
|   |   |   |   --- ixt-select.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtSelectComponent } from './ixt-select.component'; @NgModule({ declarations: [ IxtSelectComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtSelectComponent ] }) export class IxtSelectModule { }
|   |   |   +-- ixt-text
|   |   |   |   --- ixt-text.editor.html: <p>ixt-text works!</p>
|   |   |   |   --- ixt-text.editor.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-text', templateUrl: './ixt-text.component.html', styleUrls: ['./ixt-text.component.scss'] }) export class IxtTextComponent { }
|   |   |   |   --- ixt-text.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTableComponent } from './ixt-text.component'; @NgModule({ declarations: [ IxtTextComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtTextComponent ] }) export class IxtTableModule { }
|   |   |   +-- ixt-time
|   |   |   |   --- ixt-time..module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTextEditorComponent } from './ixt-text-editor.component'; @NgModule({ declarations: [ IxtTextEditorComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtTextEditorComponent ] }) export class IxtTableModule { }
|   |   |   |   --- ixt-time.editor.html: <p>ixt-text-editor works!</p>
|   |   |   |   --- ixt-time.editor.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-text-editor', templateUrl: './ixt-text-editor.component.html', styleUrls: ['./ixt-text-editor.component.scss'] }) export class IxtTextEditorComponent { }
|   |   |   --- ixt-form.component.html: <p>ixt-form works!</p>
|   |   |   --- ixt-form.component.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-form', templateUrl: './ixt-form.component.html', styleUrls: ['./ixt-form.component.scss'] }) export class IxtFormComponent { }
|   |   |   --- ixt-form.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtFormComponent } from './ixt-form.component'; @NgModule({ declarations: [ IxtFormComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtFormComponent ] }) export class IxtFormModule { }
|   |   +-- ixt-image
|   |   |   --- ixt-image.component.html: <p>ixt-image works!</p>
|   |   |   --- ixt-image.component.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-image', templateUrl: './ixt-image.component.html', styleUrls: ['./ixt-image.component.scss'] }) export class IxtImageComponent { }
|   |   |   --- ixt-image.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtImageComponent } from './ixt-image.component'; @NgModule({ declarations: [ IxtImageComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtImageComponent ] }) export class IxtImageModule { }
|   |   +-- ixt-layer-manager
|   |   |   --- ixt-layer-manager.component.html: <!-- ixt-layer-manager.component.html --> <div class="layer-manager"> <div class="manager-header"> <div class="header-content"> <span class="header-icon">⟰</span> <h2>Layers</h2> </div> </div> <div class="layer-list" cdkDropList (cdkDropListDropped)="onDrop($event)"> <div class="layer-puck" *ngFor="let layer of layers" cdkDrag> <div class="drag-handle">⋮</div> <span class="layer-name">{{ layer.name }}</span> <div class="layer-controls"> <button class="control-btn" (click)="openColorPicker(layer, 'fill')"> <span class="icon" [style.color]="layer.fillColor">●</span> </button> <button class="control-btn" (click)="openColorPicker(layer, 'stroke')"> <span class="icon" [style.color]="layer.strokeColor">○</span> </button> <button class="control-btn" (click)="openStrokeStylePicker(layer)"> <span class="icon" [ngClass]="layer.strokeStyle">─</span> </button> <button class="control-btn" (click)="toggleVisibility(layer)"> <span class="icon">{{ layer.visible ? '👁' : '👁‍🗨' }}</span> </button> </div> </div> </div> </div>
|   |   |   --- ixt-layer-manager.component.ts: // ixt-layer-manager.component.ts import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core'; import { CdkDragDrop, moveItemInArray } from '@angular/cdk/drag-drop'; export interface Layer { id: string; name: string; visible: boolean; fillColor: string; strokeColor: string; strokeStyle: 'solid' | 'dashed' | 'dotted'; order: number; } @Component({ selector: 'ixt-layer-manager', templateUrl: './ixt-layer-manager.component.html', styleUrls: ['./ixt-layer-manager.component.scss'] }) export class IxtLayerManagerComponent implements OnInit { @Input() layers: Layer[] = []; @Output() layerChange = new EventEmitter<Layer[]>(); @Output() layerOrderChange = new EventEmitter<Layer[]>(); selectedLayer: Layer | null = null; showColorPicker = false; activeProperty: 'fill' | 'stroke' | null = null; showStrokeStylePicker = false; strokeStyles: Array<Layer['strokeStyle']> = ['solid', 'dashed', 'dotted']; ngOnInit(): void { this.sortLayers(); } sortLayers(): void { this.layers.sort((a, b) => a.order - b.order); } onDrop(event: CdkDragDrop<Layer[]>): void { moveItemInArray(this.layers, event.previousIndex, event.currentIndex); this.layers.forEach((layer, index) => { layer.order = index; }); this.layerOrderChange.emit(this.layers); } toggleVisibility(layer: Layer): void { layer.visible = !layer.visible; this.layerChange.emit(this.layers); } openColorPicker(layer: Layer, property: 'fill' | 'stroke'): void { this.selectedLayer = layer; this.activeProperty = property; this.showColorPicker = true; } openStrokeStylePicker(layer: Layer): void { this.selectedLayer = layer; this.showStrokeStylePicker = true; } onColorSelect(color: string): void { if (this.selectedLayer && this.activeProperty) { if (this.activeProperty === 'fill') { this.selectedLayer.fillColor = color; } else { this.selectedLayer.strokeColor = color; } this.layerChange.emit(this.layers); } } onStrokeStyleSelect(style: Layer['strokeStyle']): void { if (this.selectedLayer) { this.selectedLayer.strokeStyle = style; this.layerChange.emit(this.layers); this.closeStrokeStylePicker(); } } closeColorPicker(): void { this.showColorPicker = false; this.selectedLayer = null; this.activeProperty = null; } closeStrokeStylePicker(): void { this.showStrokeStylePicker = false; this.selectedLayer = null; } }
|   |   |   --- ixt-layer-manager.index.ts: // ixt-layer-manager.index.ts export * from './ixt-layer-manager.component'; export * from './ixt-layer-manager.module'; export interface Layer { id: string; name: string; visible: boolean; fillColor: string; strokeColor: string; strokeStyle: 'solid' | 'dashed' | 'dotted'; order: number; }
|   |   |   --- ixt-layer-manager.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { DragDropModule } from '@angular/cdk/drag-drop'; import { IxtLayerManagerComponent } from './ixt-layer-manager.component'; @NgModule({ declarations: [IxtLayerManagerComponent], imports: [ CommonModule, DragDropModule ], exports: [IxtLayerManagerComponent] }) export class IxtLayerManagerModule { }
|   |   +-- ixt-map
|   |   |   +-- models
|   |   |   |   \-- sphere
|   |   |   |       +-- types
|   |   |   |       |   --- GeometryCollection.ts: <empty file>
|   |   |   |       |   --- LineString.ts: <empty file>
|   |   |   |       |   --- MultiLineString.ts: <empty file>
|   |   |   |       |   --- MultiPoint.ts: <empty file>
|   |   |   |       |   --- MultiPolygon.ts: <empty file>
|   |   |   |       |   --- Point.ts: <empty file>
|   |   |   |       |   --- Polygon.ts: <empty file>
|   |   |   |       --- Angle.ts: <empty file>
|   |   |   |       --- Arc.ts: <empty file>
|   |   |   |       --- Azimuth.ts: <empty file>
|   |   |   |       --- Bearing.ts: <empty file>
|   |   |   |       --- Collection.ts: <empty file>
|   |   |   |       --- Coordinate.ts: <empty file>
|   |   |   |       --- Geodesic.ts: <empty file>
|   |   |   |       --- GreatCircle.ts: <empty file>
|   |   |   |       --- Horizon.ts: <empty file>
|   |   |   |       --- Luxodrome.ts: <empty file>
|   |   |   |       --- Nadir.ts: <empty file>
|   |   |   |       --- Point.ts: <empty file>
|   |   |   |       --- Polygon.ts: <empty file>
|   |   |   |       --- Rhumb.ts: <empty file>
|   |   |   |       --- SmallCircle.ts: <empty file>
|   |   |   |       --- Sphere.ts: <empty file>
|   |   |   |       --- Triangle.ts: <empty file>
|   |   |   |       --- Zenith.ts: <empty file>
|   |   |   +-- types
|   |   |   |   +-- azimuthal
|   |   |   |   |   +-- gnomic
|   |   |   |   |   |   --- gnomic.projection.ts: <empty file>
|   |   |   |   |   |   --- gnomicl.projection.html: <empty file>
|   |   |   |   |   +-- orthographic
|   |   |   |   |   |   --- orthographic.projection.html: <empty file>
|   |   |   |   |   |   --- orthographic.projection.ts: <empty file>
|   |   |   |   |   +-- perspective
|   |   |   |   |   |   --- perspective.projection.html: <empty file>
|   |   |   |   |   |   --- perspective.projection.ts: <empty file>
|   |   |   |   |   --- azimuthal.projection.html: <empty file>
|   |   |   |   |   --- azimuthal.projection.ts: <empty file>
|   |   |   |   +-- conical
|   |   |   |   |   \-- lambert
|   |   |   |   |       --- lambert.projection.html: <empty file>
|   |   |   |   |       --- lambert.projection.ts: <empty file>
|   |   |   |   \-- cylindrical
|   |   |   |       \-- utm
|   |   |   |           --- utm.projection.html: <empty file>
|   |   |   |           --- utm.projection.ts: <empty file>
|   |   |   --- geo-processing.service.ts: // Create the GeoJSON processing service (geo-processing.service.ts) import { Injectable } from '@angular/core'; import { Feature, LineString, GeoJsonProperties, Geometry } from 'geojson'; import * as d3 from 'd3'; import { GeoFeatureProperties, GeoProcessingOptions } from './geo.types'; @Injectable({ providedIn: 'root' }) export class GeoProcessingService { processFeatures(features: Feature[], options: GeoProcessingOptions = {}): Feature[] { let processedFeatures = [...features]; // Apply route interpolation if needed if (options.interpolateRoutes) { processedFeatures = this.interpolateRoutes(processedFeatures, { pointsPerRoute: options.pointsPerRoute, minPoints: options.minPointsPerRoute }); } // Apply filtering if expression provided if (options.filterExpression) { processedFeatures = this.filterFeatures(processedFeatures, options.filterExpression); } return processedFeatures; } private interpolateRoutes( features: Feature[], options: { pointsPerRoute?: number; minPoints?: number } = {} ): Feature[] { const minPoints = options.minPoints || 5; return features.map(feature => { if (feature.geometry.type !== 'LineString') { return feature; } const line = feature.geometry as LineString; const coordinates = line.coordinates; if (coordinates.length !== 2) { return feature; } const start = coordinates[0] as [number, number]; const end = coordinates[1] as [number, number]; const route = d3.geoInterpolate(start, end); // Calculate distance and points const distance = d3.geoDistance(start, end) * 3959; // Earth radius in miles const pointsPer5Miles = Math.ceil(distance / 5); const numPoints = Math.max(minPoints, options.pointsPerRoute || pointsPer5Miles); const newCoordinates = Array.from({ length: numPoints }, (_, i) => { const t = i / (numPoints - 1); return route(t); }); return { ...feature, geometry: { ...line, coordinates: newCoordinates } }; }); } private filterFeatures(features: Feature[], expression: string): Feature[] { const filterFn = this.createFilterFunction(expression); return features.filter(feature => { try { return filterFn ? filterFn(feature) : true; } catch (e) { console.error('Error applying filter to feature:', e); return true; } }); } private createFilterFunction(expression: string): Function | null { if (!expression) return null; try { return new Function('feature', ` try { const properties = feature.properties; return ${expression}; } catch (e) { console.error('Filter expression error:', e); return true; } `); } catch (e) { console.error('Error creating filter function:', e); return null; } } // private createFilterFunction(): Function | null { // if (!this.filterExpression) return null; // console.log('Creating filter with expression:', this.filterExpression); // return new Function('feature', ` // try { // const properties = feature.properties; // //console.log('Evaluating:', properties); // return ${this.filterExpression}; // } catch (e) { // console.error('Filter expression error:', e); // return true; // If there's an error, include the feature // } // `); // } }
|   |   |   --- geo.types.ts: // First, let's create the interfaces (geo.types.ts) export interface GeoFeatureProperties { [key: string]: any; } export interface GeoProcessingOptions { interpolateRoutes?: boolean; pointsPerRoute?: number; minPointsPerRoute?: number; filterExpression?: string; }
|   |   |   --- ixt-layer.component.html: <empty file>
|   |   |   --- ixt-layer.component.ts: import { Component, Input, Output, EventEmitter, ElementRef, Host, ChangeDetectionStrategy, ChangeDetectorRef, SimpleChanges } from '@angular/core'; import * as d3 from 'd3'; import { IxtMapComponent } from './ixt-map.component'; import { GeoProcessingService } from './geo-processing.service'; import { LayerRenderService } from './layer-render.service'; import { LayerEventHandlers, LayerEventService } from './layer-event.service'; import { LayerStateService } from './layer-state.service'; import { Feature } from 'geojson'; @Component({ selector: 'ixt-layer', template: ` <svg:g> <ng-content></ng-content> </svg:g> `, changeDetection: ChangeDetectionStrategy.OnPush }) export class IxtLayerComponent { @Input() src: string = ''; @Input() stroke: string = 'black'; @Input() fill: string = 'none'; @Output() click = new EventEmitter<MouseEvent>(); @Output() hover = new EventEmitter<MouseEvent>(); private initialized = false; private pathGenerator!: d3.GeoPath; private filterExpression: string = ''; constructor( @Host() private mapComponent: IxtMapComponent, private elementRef: ElementRef, private cdr: ChangeDetectorRef, private geoProcessingService: GeoProcessingService, private layerRenderService: LayerRenderService, private layerEventService: LayerEventService, private layerStateService: LayerStateService ) { } ngOnChanges(changes: SimpleChanges) { if ((changes['src'] || changes['stroke'] || changes['fill']) && this.initialized) { this.initializeLayer(); } } ngAfterContentInit() { const content = this.elementRef.nativeElement.textContent?.trim(); if (content) { this.filterExpression = content; } } setProjection(pathGenerator: d3.GeoPath): void { this.pathGenerator = pathGenerator; this.initializeLayer(); } async initializeLayer(): Promise<void> { if (this.initialized) return; if (!this.validateContainer()) return; try { const features = await this.loadGeoJsonData(); const handlers = this.createEventHandlers(); this.renderLayer(features, handlers); this.initialized = true; } catch (error) { console.error('Layer initialization failed:', error); } } private validateContainer(): boolean { const container = this.mapComponent.getContainer(); if (!container || !this.pathGenerator) { console.error('Map container or projection not ready'); return false; } return true; } private async loadGeoJsonData(): Promise<Feature[]> { const data = await d3.json(this.src) as { features: Feature[] }; return this.geoProcessingService.processFeatures(data.features, { interpolateRoutes: true, filterExpression: this.filterExpression }); } private async renderLayer(features: any, handlers: any): Promise<void> { const container = this.mapComponent.getContainer(); const selection = this.layerRenderService.createLayer( d3.select(container.nativeElement), features, { stroke: this.stroke, fill: this.fill }, handlers ); this.layerStateService.addSelection(selection); this.cdr.markForCheck(); } private createEventHandlers(): LayerEventHandlers { return { onClick: (event: MouseEvent, datum: any) => { this.layerEventService.handleClick(event, this.mapComponent); this.click.emit(event); }, onMouseOver: (event: MouseEvent) => { this.layerEventService.handleMouseOver(event, this.mapComponent); this.hover.emit(event); }, onMouseOut: () => this.layerEventService.handleMouseOut(), onMouseMove: (event: MouseEvent) => event.stopPropagation() }; } ngOnDestroy(): void { this.layerStateService.clearSelections(); } }
|   |   |   --- ixt-layer.module.ts: // src/components/ixt-map/layer/ixt-layer.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtLayerComponent } from './ixt-layer.component'; @NgModule({ declarations: [ IxtLayerComponent ], imports: [ CommonModule ], exports: [ IxtLayerComponent ] }) export class IxtLayerModule { }
|   |   |   --- ixt-map.component.html: <empty file>
|   |   |   --- ixt-map.component.ts: import { Component, Input, ViewChild, ElementRef, ContentChildren, QueryList, AfterContentInit, OnDestroy, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core'; import * as d3 from 'd3'; import { IxtLayerComponent } from './ixt-layer.component'; import { GeoProjection, GeoPath } from 'd3'; import { BehaviorSubject, Subscription } from 'rxjs'; import { MapService } from './map.service'; import { MapDimensions, MapSelection, PathSelection, MapContainer } from './map.types'; @Component({ selector: 'ixt-map', template: ` <svg #mapSvg [attr.width]="width" [attr.height]="height" [attr.viewBox]="getViewBox()" style="display: block; background: lightgray;"> <g #mapGroup> <ng-content></ng-content> </g> </svg> `, styles: [` :host { display: block; } svg { display: block; } `], changeDetection: ChangeDetectionStrategy.OnPush }) export class IxtMapComponent implements AfterContentInit, OnDestroy { @Input() width: string | number = 800; @Input() height: string | number = 600; @Input() scale: string | number = 1; @Input() translate: string = '0,0'; @ViewChild('mapSvg') mapSvg!: ElementRef<SVGSVGElement>; @ViewChild('mapGroup') mapGroup!: MapContainer; @ContentChildren(IxtLayerComponent) layers!: QueryList<IxtLayerComponent>; private projection!: GeoProjection; private pathGenerator!: GeoPath; private selectedElement: SVGPathElement | null = null; private mapSubscriptions = new Subscription(); private projectionReady = new BehaviorSubject<boolean>(false); projectionReady$ = this.projectionReady.asObservable(); constructor( private cdr: ChangeDetectorRef, private mapService: MapService ) {} private getDimensions(): MapDimensions { return { width: this.mapService.getBaseDimension(this.width), height: this.mapService.getBaseDimension(this.height), scale: Number(this.scale), translate: this.translate }; } getViewBox(): string { const { width, height } = this.getDimensions(); return `0 0 ${width} ${height}`; } private initializeMap(): void { const dimensions = this.getDimensions(); const { projection, pathGenerator } = this.mapService.initializeProjection( dimensions.width, dimensions.height ); this.projection = projection; this.pathGenerator = pathGenerator; this.projectionReady.next(true); if (this.mapGroup) { const mapSelection = d3.select<SVGGElement, unknown>(this.mapGroup.nativeElement); mapSelection.on('click', () => this.clearSelection()); } setTimeout(() => { this.layers.forEach(layer => { layer.setProjection(this.pathGenerator); }); }); } getContainer(): MapContainer { return this.mapGroup; } getPathGenerator(): GeoPath { return this.pathGenerator; } clearSelection(): void { if (this.selectedElement) { d3.select<SVGPathElement, unknown>(this.selectedElement) .attr('stroke', function(this: SVGPathElement) { return this.getAttribute('data-original-stroke') || ''; }) .attr('stroke-width', '1'); this.selectedElement = null; this.cdr.markForCheck(); } } setSelection(element: SVGPathElement | null): void { this.clearSelection(); if (element) { this.selectedElement = element; this.cdr.markForCheck(); } } ngAfterContentInit(): void { this.initializeMap(); this.mapSubscriptions.add( this.layers.changes.subscribe(() => { this.initializeMap(); this.cdr.markForCheck(); }) ); } ngOnDestroy(): void { this.mapSubscriptions.unsubscribe(); this.selectedElement = null; this.projection = null as any; this.pathGenerator = null as any; } }
|   |   |   --- ixt-map.index.ts: // Export all public components from the ixt-map module export * from './ixt-map.component'; export * from './ixt-layer.component'; // Include any additional exports, such as services or interfaces, if they are part of the module
|   |   |   --- ixt-map.module.ts: // src/components/ixt-map/ixt-map.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtMapComponent } from './ixt-map.component'; import { IxtLayerModule } from './ixt-layer.module'; @NgModule({ declarations: [ IxtMapComponent ], imports: [ CommonModule, IxtLayerModule ], exports: [ IxtMapComponent, IxtLayerModule ] }) export class IxtMapModule { }
|   |   |   --- layer-event.service.ts: // layer-event.service.ts import { Injectable } from '@angular/core'; import { MapService } from './map.service'; import * as d3 from 'd3'; export interface LayerEventHandlers { onClick: (event: MouseEvent, datum: any) => void; onMouseOver: (event: MouseEvent) => void; onMouseOut: () => void; onMouseMove: (event: MouseEvent) => void; } @Injectable({ providedIn: 'root' }) export class LayerEventService { private hoveredElement: SVGPathElement | null = null; constructor(private mapService: MapService) {} handleClick(event: MouseEvent, mapRef: any): void { event.stopPropagation(); const clickedPath = event.currentTarget as SVGPathElement; if (clickedPath === mapRef['selectedElement']) { mapRef.setSelection(null); this.applyHoverEffect(clickedPath, false); } else { if (mapRef['selectedElement']) { this.applyHoverEffect(mapRef['selectedElement'], false); } mapRef.setSelection(clickedPath); this.applyHoverEffect(clickedPath, true); } } handleMouseOver(event: MouseEvent, mapRef: any): void { event.stopPropagation(); const currentPath = event.currentTarget as SVGPathElement; if (currentPath !== mapRef['selectedElement']) { this.applyHoverEffect(currentPath, true); this.hoveredElement = currentPath; } } handleMouseOut(): void { if (this.hoveredElement) { this.clearHoverState(this.hoveredElement); this.hoveredElement = null; } } private applyHoverEffect(element: SVGPathElement, isHover: boolean): void { const d3Element = d3.select(element); const currentFill = element.getAttribute('data-original-fill'); if (currentFill && currentFill !== 'none') { d3Element .attr('fill', currentFill) .attr('stroke-width', isHover ? '2' : '1'); } else { d3Element.attr('stroke-width', isHover ? '2' : '1'); } } private clearHoverState(element: SVGPathElement): void { const d3Element = d3.select(element); const originalFill = element.getAttribute('data-original-fill'); d3Element .attr('fill', originalFill) .attr('stroke-width', '1'); } }
|   |   |   --- layer-render.service.ts: // layer-render.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { Feature, GeoJsonProperties, Geometry } from 'geojson'; import { MapService } from './map.service'; export interface LayerRenderOptions { stroke: string; fill: string; } @Injectable({ providedIn: 'root' }) export class LayerRenderService { constructor(private mapService: MapService) {} createLayer( container: d3.Selection<any, any, any, any>, features: Feature[], options: LayerRenderOptions, eventHandlers: { onClick: (event: MouseEvent, datum: any) => void; onMouseOver: (event: MouseEvent) => void; onMouseOut: (event: MouseEvent) => void; onMouseMove: (event: MouseEvent) => void; } ): d3.Selection<any, any, any, any> { const layerGroup = container .append('g') .attr('class', 'map-layer'); return layerGroup .selectAll('path') .data(features) .enter() .append('path') .attr('d', (datum) => this.mapService.getPathGenerator()(datum) || '') .attr('stroke', options.stroke) .attr('fill', options.fill) .attr('stroke-width', '1') .attr('data-original-fill', options.fill) .attr('data-original-stroke', options.stroke) .attr('vector-effect', 'non-scaling-stroke') .style('cursor', 'pointer') .on('click', eventHandlers.onClick) .on('mouseover', eventHandlers.onMouseOver) .on('mouseout', eventHandlers.onMouseOut) .on('mousemove', eventHandlers.onMouseMove); } }
|   |   |   --- layer-state.service.ts: // layer-state.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; export interface LayerState { hoveredElement: SVGPathElement | null; selections: d3.Selection<any, any, any, any>[]; } @Injectable({ providedIn: 'root' }) export class LayerStateService { private state = new BehaviorSubject<LayerState>({ hoveredElement: null, selections: [] }); state$ = this.state.asObservable(); setHoveredElement(element: SVGPathElement | null): void { this.updateState({ hoveredElement: element }); } addSelection(selection: d3.Selection<any, any, any, any>): void { const currentState = this.state.value; this.updateState({ selections: [...currentState.selections, selection] }); } clearSelections(): void { const currentState = this.state.value; currentState.selections.forEach(selection => { if (selection && !selection.empty()) { selection.remove(); } }); this.updateState({ selections: [] }); } private updateState(partialState: Partial<LayerState>): void { this.state.next({ ...this.state.value, ...partialState }); } ngOnDestroy(): void { this.clearSelections(); this.state.complete(); } }
|   |   |   --- map-error.service.ts: // map-error.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; export interface MapError { code: MapErrorCode; message: string; timestamp: Date; context?: any; } export enum MapErrorCode { INITIALIZATION_FAILED = 'INIT_FAILED', PROJECTION_FAILED = 'PROJ_FAILED', DATA_LOAD_FAILED = 'DATA_LOAD_FAILED', SELECTION_FAILED = 'SELECT_FAILED', INVALID_DIMENSIONS = 'INVALID_DIMS' } @Injectable({ providedIn: 'root' }) export class MapErrorService { private errorSubject = new BehaviorSubject<MapError | null>(null); private retryAttemptsMap = new Map<string, number>(); readonly maxRetryAttempts = 3; readonly errors$ = this.errorSubject.asObservable(); reportError(code: MapErrorCode, message: string, context?: any): void { const error: MapError = { code, message, timestamp: new Date(), context }; this.errorSubject.next(error); console.error(`Map Error [${code}]:`, message, context); } clearError(): void { this.errorSubject.next(null); } shouldRetry(operationKey: string): boolean { const attempts = this.retryAttemptsMap.get(operationKey) || 0; if (attempts < this.maxRetryAttempts) { this.retryAttemptsMap.set(operationKey, attempts + 1); return true; } return false; } resetRetryCount(operationKey: string): void { this.retryAttemptsMap.delete(operationKey); } }
|   |   |   --- map.service.ts: // map.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { GeoProjection, GeoPath } from 'd3'; import { BehaviorSubject, Observable } from 'rxjs'; import { MapError, MapErrorCode, MapErrorService } from './map-error.service'; export interface MapDimensions { width: number; height: number; } export interface MapState { projection: GeoProjection; pathGenerator: GeoPath; dimensions: MapDimensions; } @Injectable({ providedIn: 'root' }) export class MapService { private projection!: GeoProjection; private pathGenerator!: GeoPath; private selectedElementSource = new BehaviorSubject<SVGPathElement | null>(null); private dimensions = new BehaviorSubject<MapDimensions>({ width: 800, height: 600 }); readonly selectedElement$ = this.selectedElementSource.asObservable(); readonly dimensions$ = this.dimensions.asObservable(); private errorSubject = new BehaviorSubject<MapError | null>(null); private retryAttemptsMap = new Map<string, number>(); readonly maxRetryAttempts = 3; readonly errors$ = this.errorSubject.asObservable(); constructor(private errorService: MapErrorService) {} initializeProjection(width: number, height: number): { projection: GeoProjection; pathGenerator: d3.GeoPath } { try { if (width <= 0 || height <= 0) { throw new Error('Invalid dimensions'); } this.projection = d3.geoMercator() .fitSize([width, height], { type: 'Sphere' }); this.pathGenerator = d3.geoPath().projection(this.projection); return { projection: this.projection, pathGenerator: this.pathGenerator }; } catch (error) { this.errorService.reportError( MapErrorCode.INITIALIZATION_FAILED, 'Failed to initialize map projection', { width, height, error } ); throw error; } } getProjection(): GeoProjection { return this.projection; } getPathGenerator(): GeoPath { return this.pathGenerator; } getDimensions(): MapDimensions { return this.dimensions.value; } setSelection(element: SVGPathElement | null): void { const previousElement = this.selectedElementSource.value; if (previousElement) { d3.select(previousElement) .attr('stroke', d3.select(previousElement).attr('data-original-stroke')) .attr('stroke-width', '1'); } this.selectedElementSource.next(element); } clearSelection(): void { this.setSelection(null); } getBaseDimension(value: string | number): number { if (typeof value === 'number') return value; const num = parseFloat(value); return isNaN(num) ? 800 : num; } reportError(code: MapErrorCode, message: string, context?: any): void { const error: MapError = { code, message, timestamp: new Date(), context }; this.errorSubject.next(error); console.error(`Map Error [${code}]:`, message, context); } clearError(): void { this.errorSubject.next(null); } shouldRetry(operationKey: string): boolean { const attempts = this.retryAttemptsMap.get(operationKey) || 0; if (attempts < this.maxRetryAttempts) { this.retryAttemptsMap.set(operationKey, attempts + 1); return true; } return false; } resetRetryCount(operationKey: string): void { this.retryAttemptsMap.delete(operationKey); } }
|   |   |   --- map.types.ts: // map.types.ts import { GeoProjection, GeoPath } from 'd3'; import { ElementRef } from '@angular/core'; export interface MapDimensions { width: number; height: number; scale: number; translate: string; } export interface MapState { projection: GeoProjection; pathGenerator: GeoPath; dimensions: MapDimensions; } export interface MapSelection extends d3.Selection<SVGGElement, unknown, null, undefined> {} export interface PathSelection extends d3.Selection<SVGPathElement, unknown, null, undefined> {} export interface MapContainer extends ElementRef<SVGGElement> {}
|   |   |   --- route-processor.service.ts: // route-processor.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { Feature, LineString, GeoJsonProperties } from 'geojson'; export interface RouteProcessingConfig { pointsPerMile?: number; minPoints?: number; earthRadiusMiles?: number; } const DEFAULT_CONFIG: RouteProcessingConfig = { pointsPerMile: 0.2, // 1 point every 5 miles minPoints: 5, earthRadiusMiles: 3959 }; @Injectable({ providedIn: 'root' }) export class RouteProcessorService { private config: RouteProcessingConfig; constructor() { this.config = DEFAULT_CONFIG; } setConfig(config: Partial<RouteProcessingConfig>): void { this.config = { ...DEFAULT_CONFIG, ...config }; } interpolateRoute(feature: Feature<LineString, GeoJsonProperties>): Feature<LineString, GeoJsonProperties> { const line = feature.geometry; const coordinates = line.coordinates; if (coordinates.length !== 2) { return feature; } const start = coordinates[0] as [number, number]; const end = coordinates[1] as [number, number]; const route = d3.geoInterpolate(start, end); const distance = d3.geoDistance(start, end) * this.config.earthRadiusMiles!; const numPoints = Math.max( this.config.minPoints!, Math.ceil(distance * this.config.pointsPerMile!) ); const newCoordinates = Array.from({ length: numPoints }, (_, i) => { const t = i / (numPoints - 1); return route(t); }); return { ...feature, geometry: { ...line, coordinates: newCoordinates } }; } calculateRouteDistance(coordinates: [number, number][]): number { if (coordinates.length < 2) return 0; return coordinates.reduce((total, coord, i) => { if (i === 0) return 0; const distance = d3.geoDistance(coordinates[i - 1], coord) * this.config.earthRadiusMiles!; return total + distance; }, 0); } }
|   |   +-- ixt-menu
|   |   |   --- ixt-menu.component.html: <nav class="navbar" [ngStyle]="themeStyles" fxLayout="row" fxLayoutAlign="start center" fxFill> <div class="navbar-brand" fxFlex="none"> <a [routerLink]="brandLink" class="brand-link"> <img *ngIf="brandLogo" [src]="brandLogo" alt="Brand Logo" class="brand-logo"> <span class="brand-name">{{ brandName }}</span> </a> </div> <div class="nav-items"> <a *ngFor="let item of menuItems" [routerLink]="item.link" class="nav-link"> {{ item.name }} </a> </div> <div *ngIf="showSearch" fxFlex="none" class="search-container"> <form (ngSubmit)="onSearch($event)" class="search-form"> <div class="input-group"> <input type="text" [(ngModel)]="searchTerm" name="search" [placeholder]="searchPlaceholder" class="form-control"> <button type="submit" class="btn"> Search </button> </div> </form> </div> </nav>
|   |   |   --- ixt-menu.component.ts: import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { baseThemeColors, unitedThemeColors } from '../theme/theme.colors'; import { ThemeVariant, ThemeColors } from '../theme/theme.types'; interface MenuItem { name: string; link: string; } interface MenuConfig { items: MenuItem[]; } @Component({ selector: 'ixt-menu', templateUrl: './ixt-menu.component.html', styleUrls: ['./ixt-menu.component.scss'] }) export class IxtMenuComponent implements OnInit { @Input() linkAlignment: string = 'start'; @Input() src: string = ''; @Input() brandName: string = ''; @Input() brandLogo?: string; @Input() brandLink: string = '/'; @Input() showSearch: boolean = false; @Input() searchPlaceholder: string = 'Search...'; // Theme inputs @Input() variant: ThemeVariant = 'tertiary'; @Input() theme: ThemeColors = unitedThemeColors; @Output() searchSubmitted = new EventEmitter<string>(); menuItems: MenuItem[] = []; searchTerm: string = ''; get themeStyles() { const colors = this.theme[this.variant]; return { 'background-color': colors.base, 'color': colors.text, '--theme-hover': colors.hover, '--theme-active': colors.active }; } constructor(private http: HttpClient) { } ngOnInit(): void { if (this.src) { this.loadMenu(); } } loadMenu() { this.http.get<MenuConfig>(this.src).subscribe({ next: (data) => { this.menuItems = data.items; }, error: (error) => { console.error('Error loading menu:', error); } }); } onSearch(event: Event) { event.preventDefault(); if (this.searchTerm.trim()) { this.searchSubmitted.emit(this.searchTerm); } } }
|   |   |   --- ixt-menu.index.ts: // ixt-menu.index.ts export * from './ixt-menu.component'; export * from './ixt-menu.module'; export interface MenuItem { name: string; link: string; } export interface MenuConfig { items: MenuItem[]; brandName?: string; brandLogo?: string; brandLink?: string; showSearch?: boolean; searchPlaceholder?: string; linkAlignment?: 'start' | 'center' | 'end'; }
|   |   |   --- ixt-menu.model.ts: <empty file>
|   |   |   --- ixt-menu.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { RouterModule } from '@angular/router'; import { IxtMenuComponent } from './ixt-menu.component'; @NgModule({ declarations: [ IxtMenuComponent ], imports: [ CommonModule, FormsModule, RouterModule ], exports: [ IxtMenuComponent ] }) export class IxtMenuModule { }
|   |   +-- ixt-panel
|   |   |   --- ixt-panel.component.html: <div class="ixt-panel" [class.bordered]="bordered" [class.elevated]="elevated"> <div class="panel-title" *ngIf="title"> {{ title }} </div> <div class="panel-content" [class.with-padding]="padding"> <ng-content></ng-content> </div> <div class="panel-caption" *ngIf="caption"> {{ caption }} </div> </div>
|   |   |   --- ixt-panel.component.ts: import { Component, Input } from '@angular/core'; @Component({ selector: 'ixt-panel', templateUrl: './ixt-panel.component.html', styleUrls: ['./ixt-panel.component.scss'] }) export class IxtPanelComponent { @Input() title?: string; @Input() caption?: string; @Input() padding = true; @Input() bordered = true; @Input() elevated = false; }
|   |   |   --- ixt-panel.index.ts: export * from './ixt-panel.component'; export * from './ixt-panel.module';
|   |   |   --- ixt-panel.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtPanelComponent } from './ixt-panel.component'; @NgModule({ declarations: [ IxtPanelComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtPanelComponent ] }) export class IxtPanelModule { }
|   |   +-- ixt-progress
|   |   |   +-- types
|   |   |   |   +-- composite
|   |   |   |   |   --- composite.progress.html: <empty file>
|   |   |   |   |   --- composite.progress.ts: <empty file>
|   |   |   |   +-- determinate
|   |   |   |   |   --- determinate.progress.html: <empty file>
|   |   |   |   |   --- determinite.progress.ts: <empty file>
|   |   |   |   \-- indeterminite
|   |   |   |       --- indeterminate.progress.html: <empty file>
|   |   |   |       --- indeterminate.progress.ts: <empty file>
|   |   |   --- ixt-progress.component.html: <ng-container *ngIf="config"> <!-- Modal backdrop --> <div *ngIf="config.displayMode === 'MODAL'" class="progress-backdrop" [class.dark-theme]="config.theme === 'dark'" [class.light-theme]="config.theme === 'light'" [@fadeInOut]> </div> <!-- Main progress container --> <div class="progress-container" [class.modal]="config.displayMode === 'MODAL'" [class.embedded]="config.displayMode === 'EMBEDDED'" [class.dark-theme]="config.theme === 'dark'" [class.light-theme]="config.theme === 'light'" [@slideInOut]> <!-- Header Section --> <div class="progress-header"> <h3 *ngIf="config.title" class="progress-title">{{config.title}}</h3> <button *ngIf="config.cancelable" (click)="cancel()" class="cancel-button" aria-label="Cancel operation"> ✕ </button> </div> <!-- Description --> <p *ngIf="config.description" class="progress-description"> {{config.description}} </p> <!-- Main Progress Section --> <div class="progress-content" [ngSwitch]="config.mode"> <!-- Fixed Duration and Steps Based Progress --> <ng-container *ngSwitchCase="'FIXED_DURATION'"> <div class="progress-bar-container"> <div class="progress-bar" [style.width.%]="(progressService.progress$ | async)?.progress || 0" [class.smoothed]="(config.mode === 'FIXED_DURATION' && config.smoothing)"> </div> </div> </ng-container> <!-- Steps Based Progress with Labels --> <ng-container *ngSwitchCase="'STEPS_BASED'"> <div class="steps-container" *ngIf="config.showStepDetails"> <div class="step" *ngFor="let label of config.stepLabels; let i = index" [class.completed]="(progressService.progress$ | async)?.currentStep > i" [class.active]="(progressService.progress$ | async)?.currentStep === i"> <div class="step-marker">{{i + 1}}</div> <div class="step-label">{{label}}</div> </div> </div> <div class="progress-bar-container"> <div class="progress-bar" [style.width.%]="(progressService.progress$ | async)?.progress || 0"> </div> </div> </ng-container> <!-- Indeterminate Progress --> <ng-container *ngSwitchCase="'INDETERMINATE'"> <div class="indeterminate-container"> <div [ngSwitch]="config.spinnerType"> <div *ngSwitchCase="'circular'" class="spinner-circular"></div> <div *ngSwitchCase="'pulse'" class="spinner-pulse"></div> <div *ngSwitchDefault class="spinner-linear"></div> </div> <div *ngIf="(progressService.progress$ | async)?.currentMessage" class="status-message" [@messageChange]> {{(progressService.progress$ | async)?.currentMessage}} </div> </div> </ng-container> <!-- Historical Progress --> <ng-container *ngSwitchCase="'HISTORICAL'"> <div class="progress-bar-container"> <div class="progress-bar" [style.width.%]="(progressService.progress$ | async)?.progress || 0"> </div> </div> </ng-container> </div> <!-- Progress Details Section --> <div class="progress-details"> <!-- Percentage Display --> <div *ngIf="config.showPercentage && (progressService.progress$ | async)?.progress !== -1" class="percentage"> {{(progressService.progress$ | async)?.progress | number:'1.0-0'}}% </div> <!-- Time Information --> <div class="time-info"> <!-- Elapsed Time --> <span *ngIf="config.showElapsedTime" class="elapsed-time"> Elapsed: {{(progressService.progress$ | async)?.elapsedTime | duration}} </span> <!-- Remaining Time --> <span *ngIf="config.showTimeRemaining && (progressService.progress$ | async)?.estimatedTimeRemaining !== null" class="remaining-time"> Remaining: {{(progressService.progress$ | async)?.estimatedTimeRemaining | duration}} </span> </div> </div> <!-- Controls Section --> <div class="progress-controls" *ngIf="config.pausable || config.cancelable"> <button *ngIf="config.pausable" (click)="(progressService.progress$ | async)?.status === 'PAUSED' ? resume() : pause()" class="control-button" [class.paused]="(progressService.progress$ | async)?.status === 'PAUSED'"> {{(progressService.progress$ | async)?.status === 'PAUSED' ? 'Resume' : 'Pause'}} </button> <button *ngIf="config.cancelable" (click)="cancel()" class="control-button cancel"> Cancel </button> </div> <!-- Error Display --> <div *ngIf="(progressService.progress$ | async)?.status === 'ERROR'" class="error-container" [@fadeInOut]> <div class="error-message"> {{(progressService.progress$ | async)?.error?.message}} </div> <button *ngIf="config.errorRetryCount > 0" (click)="initializeProgress()" class="retry-button"> Retry </button> </div> </div> </ng-container>
|   |   |   --- ixt-progress.component.ts: // progress.component.ts import { Component, Input, Output, EventEmitter, OnInit, OnDestroy } from '@angular/core'; import { ProgressService } from './progress.service'; import { Subject } from 'rxjs'; import { takeUntil } from 'rxjs/operators'; import { BaseProgressConfig, ProgressState } from './progress.types'; @Component({ selector: 'app-progress', templateUrl: './ixt-progress.component.html', styleUrls: ['./ixt-progress.component.scss'] }) export class ProgressComponent implements OnInit, OnDestroy { @Input() config!: BaseProgressConfig; @Output() progressChange = new EventEmitter<ProgressState>(); @Output() completed = new EventEmitter<void>(); @Output() cancelled = new EventEmitter<void>(); @Output() error = new EventEmitter<Error>(); private destroy$ = new Subject<void>(); constructor(private progressService: ProgressService) {} ngOnInit(): void { this.initializeProgress(); this.subscribeToProgress(); } private initializeProgress(): void { try { this.validateConfig(); this.progressService.start(this.config); } catch (error) { this.handleError(error as Error); } } private validateConfig(): void { if (!this.config) { throw new Error('Progress configuration is required'); } // Add more validation as needed } private subscribeToProgress(): void { this.progressService.progress$ .pipe(takeUntil(this.destroy$)) .subscribe({ next: (state) => { this.progressChange.emit(state); if (state.status === ProgressStatus.COMPLETED) { this.handleCompletion(); } }, error: (error) => this.handleError(error) }); } private handleCompletion(): void { this.completed.emit(); if (this.config.autoClose) { setTimeout(() => { this.destroy(); }, this.config.autoCloseDelay || 1000); } } private handleError(error: Error): void { this.error.emit(error); if (this.config.onError) { this.config.onError(error); } } pause(): void { if (this.config.pausable) { this.progressService.pause(); } } resume(): void { this.progressService.resume(); } cancel(): void { if (this.config.cancelable) { this.progressService.cancel(); this.cancelled.emit(); if (this.config.onCancel) { this.config.onCancel(); } } } ngOnDestroy(): void { this.destroy(); } private destroy(): void { this.destroy$.next(); this.destroy$.complete(); this.progressService.destroy(); } } // adaptive-estimator.ts class AdaptiveEstimator { private readonly history: ProgressHistoryEntry[]; private readonly config: HistoricalConfig; private readonly similarityThreshold: number = 0.2; constructor(history: ProgressHistoryEntry[], config: HistoricalConfig) { this.history = history; this.config = config; } estimate(elapsedTime: number): { progress: number; remaining: number } { const similarRuns = this.findSimilarRuns(); if (similarRuns.length === 0) { return this.fallbackEstimate(elapsedTime); } return this.calculateEstimate(similarRuns, elapsedTime); } private findSimilarRuns(): ProgressHistoryEntry[] { return this.history.filter(entry => { const sizeSimilarity = Math.abs(entry.dataSize - this.config.dataSize) / this.config.dataSize; const complexitySimilarity = this.config.complexityFactor && entry.complexityFactor ? Math.abs(entry.complexityFactor - this.config.complexityFactor) / this.config.complexityFactor : 0; return sizeSimilarity <= this.similarityThreshold && complexitySimilarity <= this.similarityThreshold && entry.success; }); } private calculateEstimate(similarRuns: ProgressHistoryEntry[], elapsedTime: number): { progress: number; remaining: number } { const averageDuration = similarRuns.reduce((acc, run) => acc + run.duration, 0) / similarRuns.length; const progress = Math.min((elapsedTime / averageDuration) * 100, 100); const remaining = Math.max(averageDuration - elapsedTime, 0); return { progress, remaining }; } private fallbackEstimate(elapsedTime: number): { progress: number; remaining: number } { const estimatedTotal = this.config.averageTime; const progress = Math.min((elapsedTime / estimatedTotal) * 100, 100); const remaining = Math.max(estimatedTotal - elapsedTime, 0); return { progress, remaining }; } }
|   |   |   --- ixt-progress.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtProgressComponent } from './ixt-progress.component'; @NgModule({ declarations: [ IxtProgressComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtProgressComponent ] }) export class IxtTableModule { }
|   |   |   --- progress.service.ts: // progress.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable, Subject, timer } from 'rxjs'; import { takeUntil, map, filter } from 'rxjs/operators'; import { BaseProgressConfig, FixedDurationConfig, HistoricalConfig, IndeterminateConfig, ProgressHistoryEntry, ProgressMode, ProgressState, ProgressStatus, StepsConfig } from './progress.types'; @Injectable({ providedIn: 'root' }) export class ProgressService { private progressSubject = new BehaviorSubject<ProgressState>({ status: ProgressStatus.IDLE, progress: 0, elapsedTime: 0, estimatedTimeRemaining: null }); private destroySubject = new Subject<void>(); private startTime: number = 0; private historyCache: Map<string, ProgressHistoryEntry[]> = new Map(); progress$ = this.progressSubject.asObservable(); start(config: BaseProgressConfig): void { this.startTime = Date.now(); this.initializeProgress(config); } private initializeProgress(config: BaseProgressConfig): void { switch (config.mode) { case ProgressMode.FIXED_DURATION: this.handleFixedDuration(config as FixedDurationConfig); break; case ProgressMode.STEPS_BASED: this.handleStepsBased(config as StepsConfig); break; case ProgressMode.INDETERMINATE: this.handleIndeterminate(config as IndeterminateConfig); break; case ProgressMode.HISTORICAL: this.handleHistorical(config as HistoricalConfig); break; } } private handleFixedDuration(config: FixedDurationConfig): void { const updateInterval = config.updateInterval || 100; const smoothing = config.smoothing !== false; timer(0, updateInterval) .pipe( takeUntil(this.destroySubject), map(() => { const elapsed = Date.now() - this.startTime; const rawProgress = Math.min((elapsed / config.totalDuration) * 100, 100); return smoothing ? this.smoothProgress(rawProgress) : rawProgress; }), filter(progress => progress <= 100) ) .subscribe(progress => { this.updateProgress({ status: progress === 100 ? ProgressStatus.COMPLETED : ProgressStatus.RUNNING, progress, elapsedTime: Date.now() - this.startTime, estimatedTimeRemaining: this.calculateTimeRemaining(progress, config.totalDuration) }); }); } private handleStepsBased(config: StepsConfig): void { // Implementation for steps-based progress if (config.bytesLoaded !== undefined && config.totalBytes) { this.updateProgress({ status: ProgressStatus.RUNNING, progress: (config.bytesLoaded / config.totalBytes) * 100, currentStep: config.currentStep, elapsedTime: Date.now() - this.startTime, estimatedTimeRemaining: this.estimateTimeFromBytes(config.bytesLoaded, config.totalBytes) }); } else { this.updateProgress({ status: ProgressStatus.RUNNING, progress: ((config.currentStep || 0) / config.totalSteps) * 100, currentStep: config.currentStep, elapsedTime: Date.now() - this.startTime, estimatedTimeRemaining: null }); } } private handleIndeterminate(config: IndeterminateConfig): void { if (config.statusMessages?.length) { timer(0, config.messageRotationInterval || 3000) .pipe(takeUntil(this.destroySubject)) .subscribe(tick => { const messageIndex = tick % config.statusMessages.length; this.updateProgress({ status: ProgressStatus.RUNNING, progress: -1, elapsedTime: Date.now() - this.startTime, estimatedTimeRemaining: null, currentMessage: config.statusMessages[messageIndex] }); }); } } private handleHistorical(config: HistoricalConfig): void { const historicalData = this.getHistoricalData(config); if (config.adaptiveEstimation && historicalData.length > 0) { this.startAdaptiveEstimation(config, historicalData); } else { this.startBasicEstimation(config); } } private startAdaptiveEstimation(config: HistoricalConfig, history: ProgressHistoryEntry[]): void { const estimator = new AdaptiveEstimator(history, config); timer(0, 1000) .pipe(takeUntil(this.destroySubject)) .subscribe(() => { const estimation = estimator.estimate(Date.now() - this.startTime); this.updateProgress({ status: ProgressStatus.RUNNING, progress: estimation.progress, elapsedTime: Date.now() - this.startTime, estimatedTimeRemaining: estimation.remaining }); }); } private smoothProgress(rawProgress: number): number { // Implement smoothing algorithm (e.g., exponential moving average) return rawProgress; } private calculateTimeRemaining(progress: number, totalDuration: number): number { if (progress === 0) return totalDuration; const elapsed = Date.now() - this.startTime; return (elapsed / progress) * (100 - progress); } private estimateTimeFromBytes(loaded: number, total: number): number { const elapsed = Date.now() - this.startTime; const bytesPerMs = loaded / elapsed; return (total - loaded) / bytesPerMs; } private updateProgress(state: Partial<ProgressState>): void { this.progressSubject.next({ ...this.progressSubject.getValue(), ...state }); } pause(): void { if (this.progressSubject.getValue().status === ProgressStatus.RUNNING) { this.updateProgress({ status: ProgressStatus.PAUSED }); this.destroySubject.next(); } } resume(): void { if (this.progressSubject.getValue().status === ProgressStatus.PAUSED) { this.startTime = Date.now() - this.progressSubject.getValue().elapsedTime; this.updateProgress({ status: ProgressStatus.RUNNING }); } } cancel(): void { this.updateProgress({ status: ProgressStatus.CANCELLED }); this.destroy(); } destroy(): void { this.destroySubject.next(); this.destroySubject.complete(); } private getHistoricalData(config: HistoricalConfig): ProgressHistoryEntry[] { const cacheKey = this.generateCacheKey(config); return this.historyCache.get(cacheKey) || []; } private generateCacheKey(config: HistoricalConfig): string { return `${config.dataSize}-${config.complexityFactor || 1}`; } }
|   |   |   --- progress.types.ts: // progress.types.ts export enum ProgressMode { FIXED_DURATION = 'FIXED_DURATION', STEPS_BASED = 'STEPS_BASED', INDETERMINATE = 'INDETERMINATE', HISTORICAL = 'HISTORICAL' } export enum DisplayMode { EMBEDDED = 'EMBEDDED', MODAL = 'MODAL' } export enum ProgressStatus { IDLE = 'IDLE', RUNNING = 'RUNNING', PAUSED = 'PAUSED', COMPLETED = 'COMPLETED', ERROR = 'ERROR', CANCELLED = 'CANCELLED' } export interface BaseProgressConfig { mode: ProgressMode; displayMode: DisplayMode; title?: string; description?: string; theme?: 'light' | 'dark' | 'system'; cancelable?: boolean; pausable?: boolean; autoClose?: boolean; autoCloseDelay?: number; showPercentage?: boolean; showTimeRemaining?: boolean; showElapsedTime?: boolean; errorRetryCount?: number; onComplete?: () => void; onError?: (error: Error) => void; onCancel?: () => void; } export interface FixedDurationConfig extends BaseProgressConfig { mode: ProgressMode.FIXED_DURATION; totalDuration: number; startTime?: number; smoothing?: boolean; updateInterval?: number; } export interface StepsConfig extends BaseProgressConfig { mode: ProgressMode.STEPS_BASED; totalSteps: number; currentStep?: number; stepLabels?: string[]; stepDescriptions?: string[]; bytesLoaded?: number; totalBytes?: number; showStepDetails?: boolean; } export interface IndeterminateConfig extends BaseProgressConfig { mode: ProgressMode.INDETERMINATE; statusMessages?: string[]; spinnerType?: 'circular' | 'linear' | 'pulse'; messageRotationInterval?: number; showSpinner?: boolean; } export interface HistoricalConfig extends BaseProgressConfig { mode: ProgressMode.HISTORICAL; averageTime: number; dataSize: number; complexityFactor?: number; previousRuns?: ProgressHistoryEntry[]; adaptiveEstimation?: boolean; confidenceThreshold?: number; } export interface ProgressHistoryEntry { timestamp: number; duration: number; dataSize: number; complexityFactor?: number; success: boolean; } export interface ProgressState { status: ProgressStatus; progress: number; elapsedTime: number; estimatedTimeRemaining: number | null; currentStep?: number; currentMessage?: string; error?: Error; }
|   |   +-- ixt-splitpane
|   |   |   --- index.ts: // public-api.ts (or index.ts) export * from './ixt-split-pane.component'; export * from './ixt-split-pane.module';
|   |   |   --- ixt-split-pane.component.html: <div class="split-pane-container" #container> <div class="left-pane" #leftPane> <ng-content select=".left-pane"></ng-content> </div> <div class="divider" #divider (mousedown)="onDragStart($event)"> <div class="collapse-buttons"> <button class="collapse-button" (click)="collapseLeft()" [class.hidden]="isLeftCollapsed">◀</button> <button class="collapse-button" (click)="collapseRight()" [class.hidden]="isRightCollapsed">▶</button> </div> </div> <div class="right-pane"> <ng-content select=".right-pane"></ng-content> </div> <button *ngIf="isLeftCollapsed" class="expand-button" (click)="expandLeft()">▶</button> <button *ngIf="isRightCollapsed" class="expand-button right" (click)="expandRight()">◀</button> </div>
|   |   |   --- ixt-split-pane.component.ts: import { Component, ElementRef, HostListener, Input, ViewChild } from '@angular/core'; @Component({ selector: 'ixt-split-pane', template: ` <div class="split-container"> <div class="first-panel" [style.flexBasis.%]="firstPanelSize"> <ng-content select=".left-pane"></ng-content> </div> <div #divider class="divider" (mousedown)="startResize($event)"> </div> <div class="second-panel" [style.flexBasis.%]="100 - firstPanelSize"> <ng-content select=".right-pane"></ng-content> </div> </div> `, styles: [` :host { display: flex; flex: 1; min-height: 0; min-width: 0; font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', Arial, sans-serif; font-size: 14px; color: #2c3e50; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } .split-container { display: flex; flex: 1; min-height: 0; min-width: 0; background: #ffffff; border: 1px solid #e0e4e8; border-radius: 4px; } .first-panel, .second-panel { display: flex; flex: 1; min-height: 0; min-width: 0; overflow: auto; background: white; padding: 16px; /* Table styles for your file list */ ::ng-deep { table { width: 100%; border-collapse: collapse; } th { text-align: left; font-weight: 500; color: #546e7a; padding: 8px 16px; border-bottom: 2px solid #e0e4e8; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px; } td { padding: 12px 16px; border-bottom: 1px solid #f0f2f5; color: #37474f; font-size: 14px; } tr:hover { background-color: #f8fafc; } } /* Scrollbar styling */ &::-webkit-scrollbar { width: 8px; height: 8px; } &::-webkit-scrollbar-track { background: #f5f6f8; border-radius: 4px; } &::-webkit-scrollbar-thumb { background: #dde1e6; border-radius: 4px; &:hover { background: #c7ccd1; } } } .divider { display: flex; justify-content: center; width: 16px; flex-shrink: 0; cursor: col-resize; background: transparent; transition: background-color 0.2s; &:hover { background: #f5f6f8; .divider-line { background: #c7ccd1; } } } .divider { width: 6px; background: #ccc; cursor: col-resize; flex-shrink: 0; border-left: 1px solid #b4b4b4; border-right: 1px solid #b4b4b4; &:hover { background: #999; } } `] }) export class IxtSplitPaneComponent { firstPanelSize = 50; // default size isDragging = false; startPosition = 0; startSize = 0; @ViewChild('divider') divider!: ElementRef; startResize(e: MouseEvent) { this.isDragging = true; this.startPosition = e.pageX; this.startSize = this.firstPanelSize; document.addEventListener('mousemove', this.resize.bind(this)); document.addEventListener('mouseup', this.stopResize.bind(this)); } @HostListener('window:mousemove', ['$event']) resize(e: MouseEvent) { if (!this.isDragging) return; const containerRect = this.divider.nativeElement.parentElement.getBoundingClientRect(); const difference = e.pageX - this.startPosition; let newSize = this.startSize + (difference / containerRect.width * 100); newSize = Math.max(0, Math.min(100, newSize)); this.firstPanelSize = newSize; } stopResize() { this.isDragging = false; document.removeEventListener('mousemove', this.resize.bind(this)); document.removeEventListener('mouseup', this.stopResize.bind(this)); } }
|   |   |   --- ixt-split-pane.module.ts: // ixt-split-pane.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtSplitPaneComponent } from './ixt-split-pane.component'; @NgModule({ declarations: [ IxtSplitPaneComponent ], imports: [ CommonModule ], exports: [ IxtSplitPaneComponent ] }) export class IxtSplitPaneModule { }
|   |   +-- ixt-table
|   |   |   +-- editors
|   |   |   |   +-- airport-code
|   |   |   |   |   --- airport-code-editor.component.ts: import { Component, Input, forwardRef, OnInit, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { IxtDialogService } from '../../../ixt-dialog/ixt-dialog.service'; import { MatrixEditor, MatrixEditorConfig } from '../editor.interface'; @Component({ selector: 'airport-code-editor', template: ` <div class="editor-container"> <input type="text" [formControl]="inputControl" class="w-24 px-2 py-1 border rounded" [class.border-red-500]="hasError" [attr.maxlength]="config?.['maxLength'] || 3" (blur)="onTouched()" /> <div *ngIf="hasError" class="text-red-500 text-sm mt-1"> {{ errorMessage }} </div> </div> `, styles: [` .editor-container { position: relative; } `], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AirportCodeEditorComponent), multi: true } ] }) export class AirportCodeEditorComponent implements ControlValueAccessor, OnInit, MatrixEditor { @Input() config?: MatrixEditorConfig; @Input() existingCodes: string[] = []; @Input() field: string = 'code'; inputControl = new FormControl(''); hasError = false; errorMessage = ''; // MatrixEditor implementation component: Type<any> = AirportCodeEditorComponent; // ControlValueAccessor implementations public onChanged: (value: string) => void = () => {}; public onTouched: () => void = () => {}; constructor(private dialogService: IxtDialogService) {} ngOnInit() { this.setupValueChanges(); } // MatrixEditor methods getEditConfig(): MatrixEditorConfig { return { existingValues: this.existingCodes, maxLength: 3, pattern: /^[A-Z]+$/ }; } getDefaultValue(): string { return ''; } validate(value: any): boolean { if (!value) return false; const code = String(value).toUpperCase(); if (code.length !== 3) return false; if (!/^[A-Z]+$/.test(code)) return false; if (this.existingCodes.includes(code)) return false; return true; } format(value: any): string { return value ? String(value).toUpperCase() : ''; } private async setupValueChanges() { this.inputControl.valueChanges.subscribe(async value => { if (value !== null) { const upperValue = value.toUpperCase(); if (upperValue !== value) { this.inputControl.setValue(upperValue, { emitEvent: false }); } if (await this.validateValue(upperValue)) { console.log('Editor emitting code change:', upperValue); this.onChanged(upperValue); } } }); } private async validateValue(value: string): Promise<boolean> { this.hasError = false; this.errorMessage = ''; if (!value) return false; if (value.length !== (this.config?.['maxLength'] || 3)) { this.hasError = true; this.errorMessage = `Code must be exactly ${this.config?.['maxLength'] || 3} characters`; return false; } const pattern = this.config?.['pattern'] || /^[A-Z]+$/; if (!pattern.test(value)) { this.hasError = true; this.errorMessage = 'Only letters are allowed'; return false; } if (this.config?.existingValues?.includes(value)) { this.hasError = true; this.errorMessage = 'This code already exists'; // await this.dialogService.warning( // `The code "${value}" already exists. Please enter a different code.`, // 'Duplicate Code' // ); return false; } return true; } // ControlValueAccessor interface implementation writeValue(value: string): void { console.log('AirportCodeEditor writeValue:', value); this.inputControl.setValue(value, { emitEvent: false }); } registerOnChange(fn: (value: string) => void): void { console.log('AirportCodeEditor registerOnChange'); this.onChanged = fn; } registerOnTouched(fn: () => void): void { this.onTouched = fn; } setDisabledState(isDisabled: boolean): void { if (isDisabled) { this.inputControl.disable(); } else { this.inputControl.enable(); } } }
|   |   |   |   +-- binary-editor
|   |   |   |   |   --- binary-editor.component.ts: // src/components/ixt-matrix/matrix-editors/binary-editor/binary-editor.component.ts import { Component, Input, forwardRef, Output, EventEmitter, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { MatrixEditor, MatrixEditorConfig } from '../editor.interface'; interface BinaryConfig extends MatrixEditorConfig { trueValue?: any; falseValue?: any; trueDisplay?: string; falseDisplay?: string; rowData?: any; rowIndex?: number; } interface SelectionEvent { selected: boolean; rowData?: any; rowIndex?: number; } @Component({ selector: 'binary-editor', template: ` <div class="editor-container"> <input type="checkbox" [formControl]="inputControl" [checked]="isChecked" (change)="onCheckboxChange($event)" class="w-4 h-4 rounded border-gray-300" /> <span *ngIf="showLabel" class="ml-2"> {{ isChecked ? config.trueDisplay : config.falseDisplay }} </span> </div> `, providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => BinaryEditorComponent), multi: true } ] }) export class BinaryEditorComponent implements ControlValueAccessor, MatrixEditor { @Input() config: BinaryConfig = {}; @Output() selectionChange = new EventEmitter<SelectionEvent>(); inputControl = new FormControl<boolean | null>(false); component: Type<any> = BinaryEditorComponent; showLabel = false; isChecked = false; private onChange: (value: any) => void = () => { }; private onTouch: () => void = () => { }; constructor() { this.setupDefaults(); this.isChecked = false; } ngOnInit() { this.setupDefaults(); this.setupValueChanges(); } private setupDefaults() { this.config = { trueValue: true, falseValue: false, trueDisplay: 'True', falseDisplay: 'False', ...this.config }; } private setupValueChanges(): void { this.inputControl.valueChanges.subscribe((checked: boolean | null) => { if (checked !== null) { const value = checked ? this.config.trueValue : this.config.falseValue; this.isChecked = checked; this.onChange(value); this.selectionChange.emit({ selected: checked, rowData: this.config.rowData, rowIndex: this.config.rowIndex }); } }); } onCheckboxChange(event: Event) { const checkbox = event.target as HTMLInputElement; this.inputControl.setValue(checkbox.checked); this.onTouch(); } getEditConfig(): BinaryConfig { return { trueValue: this.config.trueValue || true, falseValue: this.config.falseValue || false, trueDisplay: this.config.trueDisplay || 'True', falseDisplay: this.config.falseDisplay || 'False' }; } writeValue(value: any): void { const checked = value === this.config.trueValue; this.isChecked = checked; this.inputControl.setValue(checked, { emitEvent: false }); } registerOnChange(fn: any): void { this.onChange = fn; } registerOnTouched(fn: any): void { this.onTouch = fn; } setDisabledState(isDisabled: boolean): void { if (isDisabled) { this.inputControl.disable(); } else { this.inputControl.enable(); } } }
|   |   |   |   +-- coordinate
|   |   |   |   |   --- coordinate-editor.component.ts: // src/components/ixt-matrix/matrix-editors/coordinate/coordinate-editor.component.ts import { Component, Input, forwardRef, OnInit, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { IxtDialogService } from '../../../ixt-dialog/ixt-dialog.service'; import { MatrixEditor, MatrixEditorConfig } from '../editor.interface'; @Component({ selector: 'coordinate-editor', template: ` <div class="editor-container"> <input type="number" step="any" [min]="config?.['type'] === 'lat' ? -90 : -180" [max]="config?.['type'] === 'lat' ? 90 : 180" [formControl]="inputControl" class="w-24 px-2 py-1 border rounded" [class.border-red-500]="hasError" [placeholder]="config?.['type'] === 'lat' ? '(-90 to 90)' : '(-180 to 180)'" (blur)="onBlur()" /> <div *ngIf="hasError" class="text-red-500 text-sm mt-1"> {{ errorMessage }} </div> </div>`, providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => CoordinateEditorComponent), multi: true } ] }) export class CoordinateEditorComponent implements ControlValueAccessor, OnInit, MatrixEditor { @Input() config?: MatrixEditorConfig; inputControl = new FormControl(''); hasError = false; errorMessage = ''; // MatrixEditor implementation component: Type<any> = CoordinateEditorComponent; private onChange: (value: number) => void = () => { }; private onTouch: () => void = () => { }; constructor(private dialogService: IxtDialogService) { } ngOnInit() { this.setupValueChanges(); } getEditConfig(): MatrixEditorConfig { return { type: this.config?.['type'] || 'lat' }; } validate(value: any): boolean { const num = Number(value); const isLat = this.config?.['type'] === 'lat'; return isLat ? (num >= -90 && num <= 90) : (num >= -180 && num <= 180); } // private setupValueChanges() { // this.inputControl.valueChanges.subscribe(value => { // if (value !== null) { // // Convert string to number for validation // const numValue = Number(value); // if (this.validateValue(numValue)) { // this.onChange(numValue); // } // } // }); // } setupValueChanges() { this.inputControl.valueChanges.subscribe(value => { if (value !== null) { const numValue = Number(value); if (!isNaN(numValue) && this.validateValue(numValue)) { this.onChange(numValue); } else { // Reset to last valid value or empty this.inputControl.setValue('', {emitEvent: false}); } } }); } private validateValue(value: number): boolean { this.hasError = false; this.errorMessage = ''; if (isNaN(value)) { this.hasError = true; this.errorMessage = 'Must be a valid number'; return false; } const isLat = this.config?.['type'] === 'lat'; const min = isLat ? -90 : -180; const max = isLat ? 90 : 180; if (value < min || value > max) { this.hasError = true; this.errorMessage = `Must be between ${min} and ${max}`; return false; } return true; } // ControlValueAccessor methods writeValue(value: number): void { this.inputControl.setValue(value?.toString() || '', { emitEvent: false }); } registerOnChange(fn: any): void { this.onChange = fn; } registerOnTouched(fn: any): void { this.onTouch = fn; } onBlur(): void { this.onTouch(); } }
|   |   |   |   --- DatePickerComponent.ts: // matrix-editors/date-picker.component.ts import { Component, Input, Output, EventEmitter } from '@angular/core'; @Component({ selector: 'ixt-date-picker', template: ` <input type="date" [value]="value | date:'yyyy-MM-dd'" (change)="onChange($event)" class="ixt-date-picker__input"> `, styles: [` .ixt-date-picker__input { width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 4px; } `] }) export class DatePickerComponent { @Input() value: Date | null = null; @Output() valueChange = new EventEmitter<Date>(); onChange(event: Event) { const value = (event.target as HTMLInputElement).value; this.valueChange.emit(new Date(value)); } }
|   |   |   |   --- color.editor.ts: <empty file>
|   |   |   |   --- date.editor.ts: import { Injectable } from "@angular/core"; import { MatrixEditor } from "./editor.interface"; import { formatDate } from "@angular/common"; import { DatePickerComponent } from "./DatePickerComponent"; // matrix-editors/date.editor.ts @Injectable() export class DateEditor implements MatrixEditor { component = DatePickerComponent; getEditConfig() { return { format: 'yyyy-MM-dd', showTimeSelect: false }; } format(value: Date): string { return formatDate(value, 'shortDate', 'en-US'); } }
|   |   |   |   --- editor.interface.ts: import { Type } from "@angular/core"; export interface MatrixEditorConfig { existingValues?: any[]; validators?: any[]; field?: string; [key: string]: any; } export interface MatrixEditor { component: Type<any>; getEditConfig(): any; validate?(value: any): boolean; format?(value: any): string; getDefaultValue?(): any; }
|   |   |   +-- services
|   |   |   |   +-- edit
|   |   |   |   |   --- edit.model.ts: // src/components/ixt-matrix/services/edit/edit.model.ts import { FormControl } from '@angular/forms'; export interface RowChanges { [key: string]: any; } export interface EditState { editingRows: Set<number>; newRows: any[]; rowChanges: Map<number, RowChanges>; editControls: Map<string, FormControl>; } export interface EditEvent { rowIndex: number; field: string; value: any; }
|   |   |   |   |   --- edit.service.ts: // src/components/ixt-matrix/services/edit/edit.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { FormControl } from '@angular/forms'; import { EditState, RowChanges, EditEvent } from './edit.model'; import { ColumnConfig } from '../../ixt-table.interfaces'; @Injectable({ providedIn: 'root' }) export class EditService { private readonly initialState: EditState = { editingRows: new Set<number>(), newRows: [], rowChanges: new Map<number, RowChanges>(), editControls: new Map<string, FormControl>() }; private state = new BehaviorSubject<EditState>(this.initialState); public state$ = this.state.asObservable(); private getDefaultValueForType(type: string | any): any { switch (type) { case 'number': return 0; case 'enum': return ''; case 'text': default: return ''; } } public addNewRow(columnConfigs: Record<string, ColumnConfig>): void { const newRow: any = {}; if (columnConfigs) { Object.entries(columnConfigs).forEach(([field, config]) => { newRow[field] = this.getDefaultValueForType(config.type); }); } const currentState = this.state.getValue(); const newRows = [...currentState.newRows]; newRows.unshift(newRow); // Start editing the new row const editingRows = new Set(currentState.editingRows); editingRows.add(-newRows.length); this.state.next({ ...currentState, newRows, editingRows }); } public startEditing(rowIndex: number): void { const currentState = this.state.getValue(); const editingRows = new Set(currentState.editingRows); editingRows.add(rowIndex); this.state.next({ ...currentState, editingRows }); } public cancelEditing(rowIndex: number): void { const currentState = this.state.getValue(); const editingRows = new Set(currentState.editingRows); const rowChanges = new Map(currentState.rowChanges); editingRows.delete(rowIndex); rowChanges.delete(rowIndex); this.state.next({ ...currentState, editingRows, rowChanges }); } public onValueChange(event: EditEvent): void { const { rowIndex, field, value } = event; const currentState = this.state.getValue(); const rowChanges = new Map(currentState.rowChanges); let changes = rowChanges.get(rowIndex) || {}; changes = { ...changes, [field]: value }; rowChanges.set(rowIndex, changes); this.state.next({ ...currentState, rowChanges }); } public getEditControl(rowIndex: number, field: string): FormControl { const key = `${rowIndex}-${field}`; const currentState = this.state.getValue(); let control = currentState.editControls.get(key); if (!control) { control = new FormControl(''); const editControls = new Map(currentState.editControls); editControls.set(key, control); this.state.next({ ...currentState, editControls }); } return control; } public saveChanges(data: any[]): any[] { const currentState = this.state.getValue(); const updatedData = [...data]; // Apply changes to existing rows currentState.rowChanges.forEach((changes, rowIndex) => { if (rowIndex >= 0) { updatedData[rowIndex] = { ...updatedData[rowIndex], ...changes }; } }); // Add new rows if (currentState.newRows.length) { // Apply any changes to new rows const processedNewRows = currentState.newRows.map((row, index) => { const changes = currentState.rowChanges.get(-index - 1); return changes ? { ...row, ...changes } : row; }); updatedData.unshift(...processedNewRows); } // Reset state this.state.next(this.initialState); return updatedData; } public isNewRow(index: number): boolean { return index < this.state.getValue().newRows.length; } public isEditing(rowIndex: number): boolean { return this.state.getValue().editingRows.has(rowIndex); } public hasChanges(): boolean { const currentState = this.state.getValue(); return currentState.rowChanges.size > 0 || currentState.newRows.length > 0; } public getNewRows(): any[] { return this.state.getValue().newRows; } public getRowChanges(rowIndex: number): RowChanges | undefined { return this.state.getValue().rowChanges.get(rowIndex); } public getRowIndex(displayIndex: number): number { return displayIndex - this.state.getValue().newRows.length; } public clearEditing(): void { this.state.next(this.initialState); } }
|   |   |   |   +-- filter
|   |   |   |   |   --- filter.model.ts: // src/components/ixt-matrix/services/filter/filter.model.ts import { FormControl } from '@angular/forms'; export type FilterOperator = 'equals' | 'startsWith' | 'contains' | 'between' | '>' | '<' | '>=' | '<=' | '!='; export interface FilterState { field: string; operator: FilterOperator; value: any; secondaryValue?: any; } export interface FilterControls { value: FormControl; operator?: FormControl<string>; }
|   |   |   |   |   --- filter.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; import { FormControl } from '@angular/forms'; import { FilterState, FilterOperator, FilterControls } from './filter.model'; import { ColumnConfig } from '../../ixt-table.interfaces'; @Injectable({ providedIn: 'root' }) export class FilterService { private activeFilters = new Map<string, FilterState>(); private filterControls = new Map<string, FilterControls>(); private activeFilterColumn?: string; private showFilters = false; private filtersChanged = new BehaviorSubject<Map<string, FilterState>>(new Map()); public filtersChanged$ = this.filtersChanged.asObservable(); public initializeFilter(field: string, config: ColumnConfig): void { const controls: FilterControls = { value: new FormControl('') }; if (config.type === 'number') { // Fix: Explicitly type the FormControl controls.operator = new FormControl<string>('=', { nonNullable: true }); } this.filterControls.set(field, controls); } public getFilterControl(field: string): FormControl | undefined { return this.filterControls.get(field)?.value; } public getOperatorControl(field: string): FormControl<string> | undefined { return this.filterControls.get(field)?.operator; } public onFilterChange(field: string, value: any, config?: ColumnConfig): void { if (value || value === 0) { const defaultOperator: FilterOperator = config?.type === 'number' ? 'equals' : 'contains'; const operator = this.getOperatorControl(field)?.value || defaultOperator; this.activeFilters.set(field, { field, operator: operator as FilterOperator, value: config?.type === 'number' ? Number(value) : value }); } else { this.activeFilters.delete(field); } this.filtersChanged.next(this.activeFilters); } public onOperatorChange(field: string): void { const currentValue = this.getFilterControl(field)?.value; if (currentValue || currentValue === 0) { this.onFilterChange(field, currentValue); } } public clearAllFilters(): void { this.activeFilters.clear(); this.filterControls.forEach(controls => { controls.value.reset(); controls.operator?.reset('='); }); this.filtersChanged.next(this.activeFilters); } public toggleFilters(column: string): void { if (this.activeFilterColumn === column) { this.activeFilterColumn = undefined; this.showFilters = false; } else { this.activeFilterColumn = column; this.showFilters = true; } } public matchesFilter(item: any, filter: FilterState): boolean { if (item === undefined || item === null) return false; // Handle numeric comparisons if (typeof item === 'number' || !isNaN(Number(item))) { const numValue = Number(item); const numFilterValue = Number(filter.value); return this.handleNumericComparison(numValue, numFilterValue, filter.operator); } // String handling const itemValue = String(item).toLowerCase(); const filterValue = String(filter.value).toLowerCase(); switch (filter.operator) { case 'startsWith': return itemValue.startsWith(filterValue); case 'equals': return itemValue === filterValue; case '!=': return itemValue !== filterValue; default: return itemValue.includes(filterValue); } } private handleNumericComparison(numValue: number, numFilterValue: number, operator: FilterOperator): boolean { switch (operator) { case '>': return numValue > numFilterValue; case '<': return numValue < numFilterValue; case '>=': return numValue >= numFilterValue; case '<=': return numValue <= numFilterValue; case '!=': return numValue !== numFilterValue; case 'equals': return numValue === numFilterValue; default: return false; } } public get isShowingFilters(): boolean { return this.showFilters; } public get activeColumn(): string | undefined { return this.activeFilterColumn; } public getActiveFilters(): Map<string, FilterState> { return this.activeFilters; } public hasActiveFilters(): boolean { return this.activeFilters.size > 0; } }
|   |   |   |   +-- selection
|   |   |   |   |   --- selection.model.ts: // src/components/ixt-matrix/services/selection/selection.model.ts export interface SelectionState { selectedRows: Set<number>; allSelected: boolean; }
|   |   |   |   |   --- selection.service.ts: // src/components/ixt-matrix/services/selection/selection.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { SelectionState } from './selection.model'; @Injectable({ providedIn: 'root' }) export class SelectionService { private state = new BehaviorSubject<SelectionState>({ selectedRows: new Set<number>(), allSelected: false }); public state$ = this.state.asObservable(); public selectRow(index: number, selected: boolean = true): void { const currentState = this.state.getValue(); const newSelectedRows = new Set(currentState.selectedRows); if (selected) { newSelectedRows.add(index); } else { newSelectedRows.delete(index); } this.state.next({ selectedRows: newSelectedRows, allSelected: currentState.allSelected }); } public toggleAllRows(selected: boolean, totalRows: number): void { const newSelectedRows = new Set<number>(); if (selected) { // Add all row indices for (let i = 0; i < totalRows; i++) { newSelectedRows.add(i); } } this.state.next({ selectedRows: newSelectedRows, allSelected: selected }); } public clearSelection(): void { this.state.next({ selectedRows: new Set<number>(), allSelected: false }); } public getSelectedRows(): Set<number> { return this.state.getValue().selectedRows; } public isSelected(index: number): boolean { return this.state.getValue().selectedRows.has(index); } public isAllSelected(): boolean { return this.state.getValue().allSelected; } public getSelectedCount(): number { return this.state.getValue().selectedRows.size; } public setSelectedRows(indices: number[]): void { const newSelectedRows = new Set(indices); this.state.next({ selectedRows: newSelectedRows, allSelected: false // Reset all selected state when manually setting rows }); } public isPartiallySelected(totalRows: number): boolean { const selectedCount = this.getSelectedCount(); return selectedCount > 0 && selectedCount < totalRows; } }
|   |   |   |   +-- sort
|   |   |   |   |   --- sort.model.ts: // src/components/ixt-matrix/services/sort/sort.model.ts export type SortDirection = 'asc' | 'desc' | null; export interface SortState { column: string | null; direction: SortDirection; }
|   |   |   |   |   --- sort.service.ts: // src/components/ixt-matrix/services/sort/sort.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { SortState, SortDirection } from './sort.model'; @Injectable({ providedIn: 'root' }) export class SortService { private readonly initialState: SortState = { column: null, direction: null }; private state = new BehaviorSubject<SortState>(this.initialState); public state$ = this.state.asObservable(); public toggleSort(column: string): void { const currentState = this.state.getValue(); let newDirection: SortDirection = null; if (currentState.column === column) { // Cycle through: null -> asc -> desc -> null if (currentState.direction === null) { newDirection = 'asc'; } else if (currentState.direction === 'asc') { newDirection = 'desc'; } else { newDirection = null; } } else { // New column, start with ascending newDirection = 'asc'; } this.state.next({ column: newDirection ? column : null, direction: newDirection }); } public getSortIcon(column: string): string { const { column: sortColumn, direction } = this.state.getValue(); if (sortColumn !== column) { return 'unfold_more'; } return direction === 'asc' ? 'arrow_upward' : 'arrow_downward'; } public sortData<T>(data: T[]): T[] { const { column, direction } = this.state.getValue(); if (!column || !direction) { return data; } return [...data].sort((a, b) => { const aVal = a[column as keyof T]; const bVal = b[column as keyof T]; if (aVal == null) return 1; if (bVal == null) return -1; let comparison: number; if (typeof aVal === 'string') { comparison = String(aVal).toLowerCase().localeCompare(String(bVal).toLowerCase()); } else { comparison = aVal < bVal ? -1 : (aVal > bVal ? 1 : 0); } return direction === 'asc' ? comparison : -comparison; }); } public clearSort(): void { this.state.next(this.initialState); } public getCurrentSort(): SortState { return this.state.getValue(); } public isColumnSorted(column: string): boolean { return this.state.getValue().column === column; } public getSortDirection(column: string): SortDirection { const { column: sortColumn, direction } = this.state.getValue(); return sortColumn === column ? direction : null; } }
|   |   |   |   --- pagination.model.ts: // src/components/ixt-matrix/services/pagination/pagination.model.ts export interface PaginationState { currentPage: number; pageSize: number | 'all'; totalItems: number; } export interface PageSize { value: number | 'all'; label: string; }
|   |   |   |   --- pagination.service.ts: // src/components/ixt-matrix/services/pagination/pagination.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; import { PageSize, PaginationState } from './pagination.model'; @Injectable({ providedIn: 'root' }) export class PaginationService { private readonly DEFAULT_PAGE_SIZES: PageSize[] = [ { value: 10, label: '10' }, { value: 100, label: '100' }, { value: 'all', label: 'All' } ]; private readonly MINIMUM_ROWS_FOR_PAGINATION = 50; private state = new BehaviorSubject<PaginationState>({ currentPage: 1, pageSize: 10, totalItems: 0 }); public state$ = this.state.asObservable(); public initialize(totalItems: number): void { this.updateState({ currentPage: 1, pageSize: 10, totalItems }); } public shouldShowPagination(): boolean { return this.state.getValue().totalItems > this.MINIMUM_ROWS_FOR_PAGINATION; } public getCurrentPage(): number { return this.state.getValue().currentPage; } public getPageSize(): number | 'all' { return this.state.getValue().pageSize; } public getPageSizes(): PageSize[] { return this.DEFAULT_PAGE_SIZES; } public getTotalPages(): number { const { totalItems, pageSize } = this.state.getValue(); if (pageSize === 'all' || totalItems <= this.MINIMUM_ROWS_FOR_PAGINATION) { return 1; } return Math.ceil(totalItems / +pageSize); } public getVisiblePages(): number[] { const totalPages = this.getTotalPages(); const currentPage = this.getCurrentPage(); if (totalPages <= 1) return []; const pages: number[] = [1]; const WINDOW_SIZE = 4; let start = Math.max(2, currentPage - WINDOW_SIZE); let end = Math.min(totalPages - 1, currentPage + WINDOW_SIZE); if (start > 2) { pages.push(-1); } for (let i = start; i <= end; i++) { pages.push(i); } if (end < totalPages - 1) { pages.push(-1); } if (totalPages > 1) { pages.push(totalPages); } return pages; } public onPageChange(page: number): void { const totalPages = this.getTotalPages(); if (page >= 1 && page <= totalPages) { this.updateState({ ...this.state.getValue(), currentPage: page }); } } public onPageSizeChange(newSize: number | 'all'): void { this.updateState({ ...this.state.getValue(), pageSize: newSize, currentPage: 1 }); } public getPaginatedData<T>(data: T[]): T[] { const { pageSize, currentPage } = this.state.getValue(); if (pageSize === 'all' || data.length <= this.MINIMUM_ROWS_FOR_PAGINATION) { return data; } const start = (currentPage - 1) * (+pageSize); const end = start + (+pageSize); return data.slice(start, end); } private updateState(newState: Partial<PaginationState>): void { this.state.next({ ...this.state.getValue(), ...newState }); } }
|   |   |   --- ixt-table.component.html: <div class="ixt-table__toolbar"> <button class="ixt-table__action-button" (click)="addNewRow()"> <span class="material-icons">add</span> </button> <button class="ixt-table__action-button" [disabled]="!hasChanges && newRowsLength === 0" (click)="saveChanges()"> <span class="material-icons">save</span> </button> </div> <ng-container *ngIf="hasData; else noData"> <div class="ixt-table"> <!-- Header --> <div class="ixt-table__header"> <div class="ixt-table__cell"> <binary-editor [config]="{ rowIndex: -1 }" [(ngModel)]="allSelected" (selectionChange)="toggleAllRows($event.selected)"> </binary-editor> </div> <div class="ixt-table__cell" *ngFor="let col of columns" [class.ixt-table__cell--first]="col === columns[0]"> <div class="ixt-table__cell-content"> {{columnConfigs?.[col]?.label || col}} <div class="ixt-table__cell-actions"> <button class="ixt-table__sort-toggle" (click)="toggleSort(col)"> <span class="material-icons">{{getSortIcon(col)}}</span> </button> <button class="ixt-table__filter-toggle" (click)="toggleFilters(col)"> <span class="material-icons">filter_alt</span> </button> </div> </div> </div> <div class="ixt-table__cell">Actions</div> </div> <!-- Filter Row --> <div class="ixt-table__header" *ngIf="showFilters"> <div class="ixt-table__cell"></div> <div class="ixt-table__cell" *ngFor="let col of columns" [class.ixt-table__cell--first]="col === columns[0]"> <ng-container *ngIf="activeFilterColumn === col && columnConfigs?.[col]"> <ng-container [ngSwitch]="getEditorType(columnConfigs?.[col]?.type)"> <!-- Text Filter --> <input *ngSwitchCase="'text'" [formControl]="getFilterControl(col)" [placeholder]="columnConfigs?.[col]?.placeholder || ''" class="ixt-table__filter-input"> <!-- Number Filter --> <div *ngSwitchCase="'number'" class="ixt-table__number-filter"> <select [formControl]="getOperatorControl(col)" (change)="onOperatorChange(col)"> <option value="=">=</option> <option value=">">&gt;</option> <option value="<">&lt;</option> <option value=">=">&gt;=</option> <option value="<=">&lt;=</option> <option value="!=">!=</option> </select> <input type="number" [formControl]="getFilterControl(col)" [placeholder]="columnConfigs?.[col]?.placeholder || ''" class="ixt-table__filter-input"> </div> <!-- Enum Filter --> <div *ngSwitchCase="'enum'"> <select [formControl]="getFilterControl(col)" class="ixt-table__filter-input"> <option value="">All</option> <option *ngFor="let opt of columnConfigs?.[col]?.enumValues" [value]="opt.value"> {{opt.label}} </option> </select> </div> </ng-container> </ng-container> </div> <div class="ixt-table__cell"></div> </div> <!-- Data Rows --> <div class="ixt-table__row" *ngFor="let row of paginatedData; let i = index" [class.ixt-table__row--selected]="isRowSelected(getRowIndex(i))"> <div class="ixt-table__cell"> <binary-editor [config]="{ rowIndex: getRowIndex(i), rowData: row }" [ngModel]="isRowSelected(getRowIndex(i))" (selectionChange)="selectRow(getRowIndex(i), $event.selected)"> </binary-editor> </div> <div class="ixt-table__cell" *ngFor="let col of columns" [class.ixt-table__cell--first]="col === columns[0]"> <ng-container *ngIf="isNewRow(i) || isEditing(getRowIndex(i)); else displayValue"> <ng-container [ngSwitch]="getEditorType(columnConfigs?.[col]?.type)"> <!-- Text Input --> <input *ngSwitchCase="'text'" type="text" [ngModel]="row[col]" (ngModelChange)="onValueChange(getRowIndex(i), col, $event)"> <!-- Number Input --> <input *ngSwitchCase="'number'" type="number" [ngModel]="row[col]" (ngModelChange)="onValueChange(getRowIndex(i), col, $event)"> <!-- Enum Select --> <select *ngSwitchCase="'enum'" [ngModel]="row[col]" (ngModelChange)="onValueChange(getRowIndex(i), col, $event)"> <option *ngFor="let opt of columnConfigs?.[col]?.enumValues" [ngValue]="opt.value"> {{opt.label}} </option> </select> <!-- Custom Editor --> <ng-container *ngSwitchCase="'custom'"> <ng-container *ngTemplateOutlet="customEditorTpl; context: { $implicit: getEditorComponent(columnConfigs?.[col]?.type), row: row, col: col, index: i, control: getEditControl(getRowIndex(i), col) }"> </ng-container> </ng-container> </ng-container> </ng-container> <ng-template #displayValue> <ng-container [ngSwitch]="columnConfigs?.[col]?.type"> <ng-container *ngSwitchCase="CoordinateEditorComponent"> {{formatCoordinate(row[col])}} </ng-container> <ng-container *ngSwitchDefault> {{row[col]}} </ng-container> </ng-container> </ng-template> </div> <div class="ixt-table__cell"> <ng-container *ngIf="!isNewRow(i) && !isEditing(getRowIndex(i))"> <button class="ixt-table__action-button" (click)="startEditing(getRowIndex(i))"> <span class="material-icons">edit</span> </button> </ng-container> <ng-container *ngIf="isNewRow(i) || isEditing(getRowIndex(i))"> <button class="ixt-table__action-button" (click)="cancelEditing(getRowIndex(i))"> <span class="material-icons">close</span> </button> </ng-container> </div> </div> <!-- Pagination --> <div class="ixt-table__footer" *ngIf="showPagination"> <div class="ixt-table__pagination"> <div class="ixt-table__page-size"> <select [formControl]="pageSizeControl"> <option *ngFor="let size of pageSizes" [value]="size.value"> {{size.label}} </option> </select> rows per page </div> <div class="ixt-table__controls"> <button (click)="onPageChange(1)" [disabled]="currentPage === 1"> <span class="material-icons">first_page</span> </button> <button (click)="onPageChange(currentPage - 1)" [disabled]="currentPage === 1"> <span class="material-icons">chevron_left</span> </button> <button *ngFor="let page of visiblePages" [class.active]="page === currentPage" [class.ellipsis]="page === -1" [disabled]="page === -1" (click)="onPageChange(page)"> {{page === -1 ? '...' : page}} </button> <button (click)="onPageChange(currentPage + 1)" [disabled]="currentPage === totalPages"> <span class="material-icons">chevron_right</span> </button> <button (click)="onPageChange(totalPages)" [disabled]="currentPage === totalPages"> <span class="material-icons">last_page</span> </button> </div> </div> </div> </div> </ng-container> <!-- Custom Editor Template --> <ng-template #customEditorTpl let-editor let-row="row" let-col="col" let-index="index" let-control="control"> <coordinate-editor *ngIf="editor?.component === CoordinateEditorComponent" [formControl]="control" [config]="{ type: col === 'lat' ? 'lat' : 'lon' }"> </coordinate-editor> <airport-code-editor *ngIf="editor?.component === AirportCodeEditorComponent" [formControl]="control" [config]="editor.getEditConfig()" [existingCodes]="getCodes(data)"> </airport-code-editor> </ng-template> <!-- No Data Template --> <ng-template #noData> <div class="ixt-table__empty"> No data available </div> </ng-template>
|   |   |   --- ixt-table.component.ts: import { ChangeDetectorRef, Component, Input, OnInit, TemplateRef, ViewChild, Type } from '@angular/core'; import { FormControl } from '@angular/forms'; import { ColumnConfig, FilterOperator, FilterState, MatrixNode, PageSize, RowChanges } from './ixt-table.interfaces'; import { debounceTime, distinctUntilChanged } from 'rxjs/operators'; import { IxtDialogService } from '../ixt-dialog/ixt-dialog.index'; import { PaginationService } from './services/pagination.service'; import { FilterService } from './services/filter/filter.service'; import { SortService } from './services/sort/sort.service'; import { SelectionService } from './services/selection/selection.service'; import { EditService } from './services/edit/edit.service'; import { MatrixEditor } from './editors/editor.interface'; import { AirportCodeEditorComponent, CoordinateEditorComponent } from './ixt-table.index'; export type SortDirection = 'asc' | 'desc' | null; @Component({ selector: 'ixt-table', templateUrl: './ixt-table.component.html', styleUrls: ['./ixt-table.component.scss'] }) export class IxtTableComponent implements OnInit { @Input() data: MatrixNode[] = []; @Input() columnConfigs?: Record<string, ColumnConfig>; @ViewChild('noData') noDataTemplate!: TemplateRef<any>; @ViewChild('customEditorTpl') customEditorTpl!: TemplateRef<any>; columns: string[] = []; pageSizeControl = new FormControl<number | 'all'>(10); readonly AirportCodeEditorComponent = AirportCodeEditorComponent; readonly CoordinateEditorComponent = CoordinateEditorComponent; constructor( private dialogService: IxtDialogService, private changeDetectorRef: ChangeDetectorRef, private paginationService: PaginationService, private filterService: FilterService, private sortService: SortService, private selectionService: SelectionService, private editService: EditService ) { } ngOnInit() { this.columns = this.getColumns(this.data); // Initialize pagination this.paginationService.initialize(this.data.length); // Initialize filters if (this.columnConfigs) { Object.entries(this.columnConfigs).forEach(([field, config]) => { this.filterService.initializeFilter(field, config); // Get the control from service and subscribe to changes const control = this.filterService.getFilterControl(field); if (control) { control.valueChanges.pipe( debounceTime(config.debounceTime || 300), distinctUntilChanged() ).subscribe(value => { this.filterService.onFilterChange(field, value, config); }); } }); } // Subscribe to filter changes this.filterService.filtersChanged$.subscribe(() => { this.changeDetectorRef.markForCheck(); }); // Subscribe to pagination changes this.paginationService.state$.subscribe(() => { this.changeDetectorRef.markForCheck(); }); // Subscribe to page size changes this.pageSizeControl.valueChanges.subscribe(value => { if (value) { this.paginationService.onPageSizeChange(value); } }); } // edit logic start addNewRow(): void { this.editService.addNewRow(this.columnConfigs || {}); } cancelEditing(rowIndex: number): void { this.editService.cancelEditing(rowIndex); } getEditorComponent(type: any): MatrixEditor | null { console.log('getEditorComponent called with:', { type, isCoordinate: type === CoordinateEditorComponent, isAirport: type === AirportCodeEditorComponent }); if (type === AirportCodeEditorComponent) { return new AirportCodeEditorComponent(this.dialogService); } if (type === CoordinateEditorComponent) { return new CoordinateEditorComponent(this.dialogService); } return null; } getEditorType(type: any): string { console.log('getEditorType called with:', { type, isString: typeof type === 'string', isCoordinate: type === CoordinateEditorComponent, isAirport: type === AirportCodeEditorComponent }); if (typeof type === 'string') { return type; } if (type === AirportCodeEditorComponent || type === CoordinateEditorComponent) { console.log('Returning custom for editor type'); return 'custom'; } console.log('Falling back to text type'); return 'text'; } getEditControl(rowIndex: number, field: string): FormControl { return this.editService.getEditControl(rowIndex, field); } getRowIndex(displayIndex: number): number { return this.editService.getRowIndex(displayIndex); } get hasChanges(): boolean { return this.editService.hasChanges(); } isEditing(index: number): boolean { return this.editService.isEditing(index); } isNewRow(displayIndex: number): boolean { return this.editService.isNewRow(displayIndex); } get newRowsLength(): number { return this.editService.getNewRows().length; } onValueChange(rowIndex: number, field: string, value: any): void { this.editService.onValueChange({ rowIndex, field, value }); } saveChanges(): void { this.data = this.editService.saveChanges(this.data); this.changeDetectorRef.markForCheck(); } startEditing(rowIndex: number): void { this.editService.startEditing(rowIndex); } // edit logic end // filter logic start get activeFilterColumn(): string | undefined { return this.filterService.activeColumn; } getFilterControl(col: string): FormControl<any> { return this.filterService.getFilterControl(col)!; } getOperatorControl(col: string): FormControl<string> { return this.filterService.getOperatorControl(col)!; } onOperatorChange(field: string): void { this.filterService.onOperatorChange(field); } get showFilters(): boolean { return this.filterService.isShowingFilters; } toggleFilters(col: string): void { this.filterService.toggleFilters(col); } // filter logic end // pagination logic start get currentPage(): number { return this.paginationService.getCurrentPage(); } onPageChange(page: number): void { this.paginationService.onPageChange(page); } onPageSizeChange(size: number | 'all'): void { this.paginationService.onPageSizeChange(size); } get paginatedData(): MatrixNode[] { // Start with combined data let allData = [...this.editService.getNewRows(), ...this.data]; // Apply filters if (this.filterService.hasActiveFilters()) { const activeFilters = this.filterService.getActiveFilters(); const filteredExisting = this.data.filter(item => Array.from(activeFilters.values()).every(filter => this.filterService.matchesFilter(item[filter.field], filter) ) ); allData = [...this.editService.getNewRows(), ...filteredExisting]; } // Apply sorting allData = this.sortService.sortData(allData); // Apply pagination return this.paginationService.getPaginatedData(allData); } get pageSizes(): PageSize[] { return this.paginationService.getPageSizes(); } get showPagination(): boolean { return this.paginationService.shouldShowPagination(); } get totalPages(): number { return this.paginationService.getTotalPages(); } get visiblePages(): number[] { return this.paginationService.getVisiblePages(); } // pagination logic end // selection logic start get allSelected(): boolean { return this.selectionService.isAllSelected(); } set allSelected(value: boolean) { this.selectionService.toggleAllRows(value, this.data.length); } getSelectedRows(): MatrixNode[] { return Array.from(this.selectionService.getSelectedRows()) .map(index => this.data[index]) .filter(row => row !== undefined); } get hasSelectedRows(): boolean { return this.selectionService.getSelectedCount() > 0; } isRowSelected(index: number): boolean { return this.selectionService.isSelected(index); } selectRow(index: number, selected = true): void { this.selectionService.selectRow(index, selected); } setSelectedRows(indices: number[]): void { this.selectionService.setSelectedRows(indices); } toggleAllRows(selected: boolean): void { this.selectionService.toggleAllRows(selected, this.data.length); } // selection logic end // sort logic start getSortIcon(column: string): string { return this.sortService.getSortIcon(column); } toggleSort(column: string): void { this.sortService.toggleSort(column); } // sort logic end // i/o logic start formatCoordinate(value: number): string { return value.toFixed(1); } getCodes(data: MatrixNode[]): string[] { if (!data) return []; return data.map(row => row['code']?.toString() || ''); } // i/o logic end // config logic start getColumns(data: MatrixNode[]): string[] { if (!data?.length) return []; const firstRow = data[0]; return Object.keys(firstRow); } get hasData(): boolean { return !!this.data?.length; } // config logic end }
|   |   |   --- ixt-table.index.ts: // src/components/ixt-matrix/index.ts // Fix these import paths to match your folder structure export * from './ixt-table.component'; export * from './ixt-table.interfaces'; export * from './ixt-table.module'; export interface MatrixNode { [key: string]: any; children?: MatrixNode[]; } export * from './editors/airport-code/airport-code-editor.component'; export * from './editors/binary-editor/binary-editor.component'; export * from './editors/coordinate/coordinate-editor.component';
|   |   |   --- ixt-table.interfaces.ts: // File: src/components/ixt-table/ixt-table.interfaces.ts import { Type } from "@angular/core"; import { MatrixEditor } from "./editors/editor.interface"; export interface MatrixNode { code?: string; // Add this property [key: string]: any; } export interface PageSize { value: number | 'all'; label: string; } export type FilterOperator = 'equals' | 'startsWith' | 'contains' | 'between' | '>' | '<' | '>=' | '<=' | '!='; export interface FilterState { field: string; operator: FilterOperator; value: any; secondaryValue?: any; } export interface ColumnConfig { type: 'text' | 'number' | 'enum' | Type<MatrixEditor> | MatrixEditor; field: string; label?: string; operator?: FilterOperator; enumValues?: { value: any, label: string }[]; placeholder?: string; debounceTime?: number; editable?: boolean; config?: any; } export interface RowChanges { [key: string]: any; } export type ColumnConfigs = Record<string, ColumnConfig>;
|   |   |   --- ixt-table.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { MatIconModule } from '@angular/material/icon'; import { MatAutocompleteModule } from '@angular/material/autocomplete'; import { IxtTableComponent } from './ixt-table.component'; import { AirportCodeEditorComponent } from './editors/airport-code/airport-code-editor.component'; import { CoordinateEditorComponent } from './editors/coordinate/coordinate-editor.component'; import { BinaryEditorComponent } from './editors/binary-editor/binary-editor.component'; @NgModule({ declarations: [ IxtTableComponent, AirportCodeEditorComponent, CoordinateEditorComponent, BinaryEditorComponent ], imports: [ CommonModule, FormsModule, // Make sure this is here ReactiveFormsModule, MatIconModule, MatAutocompleteModule ], exports: [IxtTableComponent] }) export class IxtTableModule { }
|   |   |   --- ixt-table.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject, combineLatest, Observable } from 'rxjs'; import { map } from 'rxjs/operators'; import { MatrixRow } from './matrix-base.type'; import { PageSize } from './ixt-matrix.interfaces'; export interface PaginationState { currentPage: number; pageSize: number | 'all'; totalPages: number; } @Injectable({ providedIn: 'root' }) export class MatrixDataService { private dataSubject = new BehaviorSubject<MatrixRow[]>([]); private newRowsSubject = new BehaviorSubject<MatrixRow[]>([]); private paginationStateSubject = new BehaviorSubject<PaginationState>({ currentPage: 1, pageSize: 10, totalPages: 1 }); readonly pageSizes: PageSize[] = [ { value: 10, label: '10' }, { value: 100, label: '100' }, { value: 'all', label: 'All' } ]; constructor() { } // Data operations setData(data: MatrixRow[]): void { this.dataSubject.next(data); this.updateTotalPages(); } getData(): Observable<MatrixRow[]> { return this.dataSubject.asObservable(); } // New rows operations addNewRow(row: MatrixRow): void { const currentNewRows = this.newRowsSubject.value; this.newRowsSubject.next([row, ...currentNewRows]); } getNewRows(): Observable<MatrixRow[]> { return this.newRowsSubject.asObservable(); } commitNewRows(): void { const currentData = this.dataSubject.value; const newRows = this.newRowsSubject.value; this.dataSubject.next([...newRows, ...currentData]); this.newRowsSubject.next([]); this.updateTotalPages(); } // Pagination operations setPaginationState(state: Partial<PaginationState>): void { const currentState = this.paginationStateSubject.value; this.paginationStateSubject.next({ ...currentState, ...state }); this.updateTotalPages(); } getPaginationState(): Observable<PaginationState> { return this.paginationStateSubject.asObservable(); } getPaginatedData(): Observable<MatrixRow[]> { return this.combineData().pipe( map(allData => this.paginateData(allData)) ); } private combineData(): Observable<MatrixRow[]> { return combineLatest([ this.dataSubject, this.newRowsSubject ]).pipe( map(([data, newRows]) => [...newRows, ...data]) ); } private paginateData(data: MatrixRow[]): MatrixRow[] { const state = this.paginationStateSubject.value; if (state.pageSize === 'all' || data.length <= 50) { return data; } const start = (state.currentPage - 1) * (+state.pageSize); const end = start + (+state.pageSize); return data.slice(start, end); } private updateTotalPages(): void { const currentState = this.paginationStateSubject.value; const totalItems = this.dataSubject.value.length + this.newRowsSubject.value.length; const totalPages = currentState.pageSize === 'all' || totalItems <= 50 ? 1 : Math.ceil(totalItems / +currentState.pageSize); this.paginationStateSubject.next({ ...currentState, totalPages }); } }
|   |   |   --- ixt-table.type.ts: export interface MatrixRow { [key: string]: any; }
|   |   +-- ixt-tabset
|   |   |   --- ixt-tab.component.html: <ng-template> <ng-content></ng-content> </ng-template>
|   |   |   --- ixt-tab.component.ts: import { Component, Input, TemplateRef, ViewChild } from '@angular/core'; @Component({ selector: 'ixt-tab', templateUrl: './ixt-tab.component.html', styleUrls: ['./ixt-tab.component.scss'] }) export class IxtTabComponent { @Input() title: string = ''; @ViewChild(TemplateRef, { static: true }) implicitContent!: TemplateRef<any>; }
|   |   |   --- ixt-tabset.component.html: <div class="button-row"> <button *ngFor="let tab of tabs; let idx = index" [class.selected]="selectedIndex === idx" (click)="selectTab(tab)"> {{ tab.title }} </button> </div> <div class="content"> <div class="top-band"> <span>🔔</span> <span>{{ notificationText }}</span> </div> <div *ngFor="let tab of tabs; let idx = index" [id]="'tab' + (idx + 1)" class="main-content" [class.active]="selectedIndex === idx"> <ng-container *ngTemplateOutlet="tab.implicitContent"></ng-container> </div> </div>
|   |   |   --- ixt-tabset.component.ts: import { Component, ContentChildren, QueryList, AfterContentInit } from '@angular/core'; import { IxtTabComponent } from './ixt-tab.component'; @Component({ selector: 'ixt-tabset', templateUrl: './ixt-tabset.component.html', styleUrls: ['./ixt-tabset.component.scss'] }) export class IxtTabsetComponent implements AfterContentInit { @ContentChildren(IxtTabComponent) tabs!: QueryList<IxtTabComponent>; selectedIndex: number = 0; notificationText: string = 'Content Band Icons or Info'; ngAfterContentInit() { // Set initial active tab if there are tabs if (this.tabs?.first) { this.selectTab(this.tabs.first); } // Listen for dynamic tab changes this.tabs?.changes.subscribe(() => { if (this.tabs.length && this.selectedIndex >= this.tabs.length) { this.selectTab(this.tabs.last); } }); } selectTab(tab: IxtTabComponent) { this.selectedIndex = this.tabs.toArray().indexOf(tab); } }
|   |   |   --- ixt-tabset.index.ts: export * from './ixt-tabset.component'; export * from './ixt-tab.component'; // Updated path export * from './ixt-tabset.interfaces'; export * from './ixt-tabset.module';
|   |   |   --- ixt-tabset.interfaces.ts: export interface ITabContent { id: string; title: string; content: string; active: boolean; } export interface ITabsetConfig { notificationText?: string; showNotificationBand?: boolean; animationDuration?: number; }
|   |   |   --- ixt-tabset.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtTabsetComponent } from './ixt-tabset.component'; import { IxtTabComponent } from './ixt-tab.component'; // Updated path @NgModule({ declarations: [ IxtTabsetComponent, IxtTabComponent ], imports: [ CommonModule ], exports: [ IxtTabsetComponent, IxtTabComponent ] }) export class IxtTabsetModule { }
|   |   +-- ixt-textra
|   |   |   --- ixt-textra.component.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   |   --- ixt-textra.component.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
|   |   +-- ixt-tree
|   |   |   --- ixt-tree.component.html: <ul class="tree-container"> <ng-container *ngFor="let node of nodes; trackBy: trackByFn"> <li class="tree-node" (click)="selectNode(node, $event)"> <div class="node-content"> <span class="icon-container" (click)="toggleNode(node, $event)"> <ng-container *ngIf="node.children && node.children.length > 0"> <span class="expand-icon" [class.expanded]="node.expanded"> {{node.expanded ? '▼' : '▶'}} </span> </ng-container> <span class="node-icon"> {{(node.children && node.children.length > 0) ? '📁' : '📄'}} </span> </span> <span class="node-label">{{node.label}}</span> </div> <ul *ngIf="node.expanded && node.children" class="tree-children"> <ixt-tree [nodes]="node.children" (nodeExpanded)="nodeExpanded.emit($event)" (nodeCollapsed)="nodeCollapsed.emit($event)" (nodeSelected)="nodeSelected.emit($event)"> </ixt-tree> </ul> </li> </ng-container> </ul>
|   |   |   --- ixt-tree.component.ts: // ixt-tree.component.ts import { Component, Input, Output, EventEmitter } from '@angular/core'; export interface TreeNode { id: string; label: string; expanded?: boolean; children?: TreeNode[]; isLeaf?: boolean; } @Component({ selector: 'ixt-tree', templateUrl: './ixt-tree.component.html', styleUrls: ['./ixt-tree.component.scss'] }) export class IxtTreeComponent { @Input() nodes: TreeNode[] = []; @Output() nodeExpanded = new EventEmitter<TreeNode>(); @Output() nodeCollapsed = new EventEmitter<TreeNode>(); @Output() nodeSelected = new EventEmitter<TreeNode>(); toggleNode(node: TreeNode, event: Event): void { event.stopPropagation(); if (node.children && node.children.length > 0) { node.expanded = !node.expanded; if (node.expanded) { this.nodeExpanded.emit(node); } else { this.nodeCollapsed.emit(node); } } } selectNode(node: TreeNode, event: Event): void { event.stopPropagation(); this.nodeSelected.emit(node); } trackByFn(index: number, item: TreeNode): string { return item.id; } }
|   |   |   --- ixt-tree.index.ts: // ixt-tree.index.ts export * from './ixt-tree.component'; export * from './ixt-tree.module'; export interface TreeNode { id: string; label: string; expanded?: boolean; children?: TreeNode[]; isLeaf?: boolean; }
|   |   |   --- ixt-tree.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTreeComponent } from './ixt-tree.component'; @NgModule({ declarations: [ IxtTreeComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtTreeComponent ] }) export class IxtTreeModule { }
|   |   +-- ixt-viewport
|   |   |   --- ixt-viewport.component.html: <!-- ixt-canvas.component.html --> <div class="viewport-container"> <canvas #canvas></canvas> </div>
|   |   |   --- ixt-viewport.component.ts: // ixt-canvas.component.ts import { Component, ElementRef, ViewChild, AfterViewInit, HostListener } from '@angular/core'; interface Point { x: number; y: number; } interface Rect { x: number; y: number; width: number; height: number; } @Component({ selector: 'ixt-viewport', templateUrl: './ixt-viewport.component.html', styleUrls: ['./ixt-viewport.component.scss'] }) export class IxtViewportComponent implements AfterViewInit { @ViewChild('canvas') private canvasRef!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; // Drawing state private isDrawing = false; private lastPoint: Point | null = null; // Zooming state private isZooming = false; private zoomStart: Point | null = null; private zoomRect: Rect | null = null; private transform = { scale: 1, offsetX: 0, offsetY: 0 }; // Drawing settings private lineWidth = 2; private strokeStyle = '#000000'; ngAfterViewInit() { const canvas = this.canvasRef.nativeElement; this.ctx = canvas.getContext('2d')!; this.resizeCanvas(); this.initializeCanvas(); this.drawTestGraphics(); } private drawTestGraphics() { // Clear canvas this.clear(); // Draw some shapes this.ctx.save(); // Apply current transform this.ctx.scale(this.transform.scale, this.transform.scale); this.ctx.translate(this.transform.offsetX, this.transform.offsetY); // Rectangle this.ctx.fillStyle = '#ff0000'; this.ctx.fillRect(50, 50, 100, 100); // Circle this.ctx.beginPath(); this.ctx.fillStyle = '#0000ff'; this.ctx.arc(250, 100, 50, 0, Math.PI * 2); this.ctx.fill(); // Star this.drawStar(400, 100, 5, 50, 25); // Text this.ctx.fillStyle = '#000000'; this.ctx.font = '20px Arial'; this.ctx.fillText('Test Graphics', 50, 200); // Grid pattern this.drawGrid(); this.ctx.restore(); } private drawGrid() { this.ctx.strokeStyle = '#cccccc'; this.ctx.lineWidth = 0.5; // Draw vertical lines for (let x = 0; x < 800; x += 50) { this.ctx.beginPath(); this.ctx.moveTo(x, 0); this.ctx.lineTo(x, 600); this.ctx.stroke(); } // Draw horizontal lines for (let y = 0; y < 600; y += 50) { this.ctx.beginPath(); this.ctx.moveTo(0, y); this.ctx.lineTo(800, y); this.ctx.stroke(); } } private drawStar(cx: number, cy: number, spikes: number, outerRadius: number, innerRadius: number) { this.ctx.beginPath(); this.ctx.fillStyle = '#ffff00'; let rot = Math.PI / 2 * 3; let x = cx; let y = cy; let step = Math.PI / spikes; this.ctx.moveTo(cx, cy - outerRadius); for (let i = 0; i < spikes; i++) { x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; this.ctx.lineTo(x, y); rot += step; x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; this.ctx.lineTo(x, y); rot += step; } this.ctx.lineTo(cx, cy - outerRadius); this.ctx.closePath(); this.ctx.fill(); } @HostListener('window:resize') private resizeCanvas() { const canvas = this.canvasRef.nativeElement; canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; this.initializeCanvas(); this.drawTestGraphics(); } private initializeCanvas() { this.ctx.lineWidth = this.lineWidth; this.ctx.strokeStyle = this.strokeStyle; this.ctx.lineCap = 'round'; this.ctx.lineJoin = 'round'; } @HostListener('mousedown', ['$event']) onMouseDown(event: MouseEvent) { if (event.shiftKey) { // Start zooming when shift is held this.isZooming = true; this.zoomStart = this.getMousePos(event); this.zoomRect = null; } else { this.isDrawing = true; this.lastPoint = this.getMousePos(event); } } @HostListener('mousemove', ['$event']) onMouseMove(event: MouseEvent) { if (this.isZooming && this.zoomStart) { const currentPoint = this.getMousePos(event); // Calculate rubber band rectangle this.zoomRect = { x: Math.min(this.zoomStart.x, currentPoint.x), y: Math.min(this.zoomStart.y, currentPoint.y), width: Math.abs(currentPoint.x - this.zoomStart.x), height: Math.abs(currentPoint.y - this.zoomStart.y) }; // Redraw scene with rubber band this.drawTestGraphics(); this.drawRubberBand(); } else if (this.isDrawing && this.lastPoint) { const currentPoint = this.getMousePos(event); this.draw(this.lastPoint, currentPoint); this.lastPoint = currentPoint; } } @HostListener('mouseup', ['$event']) onMouseUp(event: MouseEvent) { if (this.isZooming && this.zoomRect) { // Calculate new transform based on zoom rectangle const canvas = this.canvasRef.nativeElement; const scaleX = canvas.width / this.zoomRect.width; const scaleY = canvas.height / this.zoomRect.height; const newScale = Math.min(scaleX, scaleY); // Update transform this.transform.scale *= newScale; this.transform.offsetX -= this.zoomRect.x / this.transform.scale; this.transform.offsetY -= this.zoomRect.y / this.transform.scale; // Redraw with new transform this.drawTestGraphics(); } this.isDrawing = false; this.isZooming = false; this.lastPoint = null; this.zoomStart = null; this.zoomRect = null; } @HostListener('mouseleave') onMouseLeave() { this.isDrawing = false; this.isZooming = false; this.lastPoint = null; this.zoomStart = null; this.zoomRect = null; } private drawRubberBand() { if (!this.zoomRect) return; this.ctx.save(); this.ctx.strokeStyle = '#000000'; this.ctx.lineWidth = 1; this.ctx.setLineDash([5, 5]); // Draw rubber band rectangle this.ctx.strokeRect( this.zoomRect.x, this.zoomRect.y, this.zoomRect.width, this.zoomRect.height ); this.ctx.restore(); } private getMousePos(event: MouseEvent): Point { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); return { x: event.clientX - rect.left, y: event.clientY - rect.top }; } private draw(start: Point, end: Point) { this.ctx.save(); this.ctx.scale(this.transform.scale, this.transform.scale); this.ctx.translate(this.transform.offsetX, this.transform.offsetY); this.ctx.beginPath(); this.ctx.moveTo(start.x / this.transform.scale, start.y / this.transform.scale); this.ctx.lineTo(end.x / this.transform.scale, end.y / this.transform.scale); this.ctx.stroke(); this.ctx.closePath(); this.ctx.restore(); } // Public methods setColor(color: string) { this.strokeStyle = color; this.ctx.strokeStyle = color; } setLineWidth(width: number) { this.lineWidth = width; this.ctx.lineWidth = width; } clear() { const canvas = this.canvasRef.nativeElement; this.ctx.clearRect(0, 0, canvas.width, canvas.height); } resetZoom() { this.transform = { scale: 1, offsetX: 0, offsetY: 0 }; this.drawTestGraphics(); } }
|   |   |   --- ixt-viewport.index.ts: // ixt-canvas.index.ts export * from './ixt-viewport.component'; export * from './ixt-viewport.module'; // // You might want to export interfaces/types if they're needed elsewhere // export interface DrawingConfig { // color?: string; // lineWidth?: number; // }
|   |   |   --- ixt-viewport.module.ts: // ixt-canvas.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtViewportComponent } from './ixt-viewport.component'; @NgModule({ declarations: [ IxtViewportComponent ], imports: [ CommonModule ], exports: [ IxtViewportComponent ] }) export class IxtViewportModule { }
|   |   \-- theme
|   |       +-- styles
|   |       |   \-- themes
|   |       --- indext.ts: // src/components/theme/index.ts export * from './theme.types'; export * from './theme.colors';
|   |       --- theme.colors.ts: import { ThemeColors } from "./theme.types"; // src/app/theme/theme.colors.ts export const baseThemeColors: ThemeColors = { primary: { base: '#4169E1', // Royal Blue hover: '#2850c9', active: '#1e40af', text: '#ffffff' }, secondary: { base: '#6c757d', hover: '#5c636a', active: '#4d5154', text: '#ffffff' }, tertiary: { base: '#003057', // Rhapsody Blue (Pantone 289) hover: '#002649', // Darker shade for hover state active: '#001C3B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, success: { base: '#28a745', hover: '#218838', active: '#1e7e34', text: '#ffffff' }, danger: { base: '#dc3545', hover: '#c82333', active: '#bd2130', text: '#ffffff' }, warning: { base: '#ffc107', hover: '#e0a800', active: '#d39e00', text: '#000000' }, info: { base: '#17a2b8', hover: '#138496', active: '#117a8b', text: '#ffffff' }, light: { base: '#f8f9fa', hover: '#e2e6ea', active: '#dae0e5', text: '#000000' }, dark: { base: '#343a40', hover: '#23272b', active: '#1d2124', text: '#ffffff' }, default: { base: '#ffffff', hover: '#f8f9fa', active: '#e9ecef', text: '#000000' } }; // src/app/theme/theme.colors.ts export const unitedThemeColors: ThemeColors = { primary: { base: '#0033A0', // United Blue hover: '#00297A', // Darker shade for hover state active: '#002060', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, secondary: { base: '#6D2077', // Atlantic Amethyst hover: '#5A1A63', // Darker shade for hover state active: '#48154F', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, tertiary: { base: '#003057', // Rhapsody Blue (Pantone 289) hover: '#002649', // Darker shade for hover state active: '#001C3B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, success: { base: '#4CAF50', // Subtle green hover: '#43A047', // Darker shade for hover state active: '#388E3C', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, warning: { base: '#FF9800', // Warm yellow-orange hover: '#FB8C00', // Darker shade for hover state active: '#F57C00', // Even darker shade for active state text: '#000000' // Black text for readability }, danger: { base: '#E53935', // Tomato red hover: '#D32F2F', // Darker shade for hover state active: '#C62828', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, info: { base: '#17A2B8', // Standard info blue hover: '#138496', // Darker shade for hover state active: '#117A8B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, light: { base: '#F8F9FA', // Light gray hover: '#E2E6EA', // Darker shade for hover state active: '#DAE0E5', // Even darker shade for active state text: '#000000' // Black text for readability }, dark: { base: '#343A40', // Dark gray hover: '#23272B', // Darker shade for hover state active: '#1D2124', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, default: { base: '#FFFFFF', // White hover: '#F8F9FA', // Light gray for hover state active: '#E9ECEF', // Darker gray for active state text: '#000000' // Black text for readability } };
|   |       --- theme.colors.united.ts: <empty file>
|   |       --- theme.module.ts: // src/components/theme/theme.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [CommonModule], exports: [] }) export class ThemeModule {}
|   |       --- theme.types.ts: // src/app/theme/theme.types.ts export type ThemeVariant = | 'primary' // Main brand color, key actions | 'secondary' // Supporting color | 'tertiary' | 'success' // Positive actions/states | 'danger' // Errors, destructive actions | 'warning' // Caution states | 'info' // Informational states | 'light' // Light backgrounds | 'dark' // Dark text/backgrounds | 'default'; // Default state export interface ThemeColor { base: string; hover: string; active: string; text: string; } export type ThemeColors = Record<ThemeVariant, ThemeColor>;
|   +-- services
|   |   --- breadcrumb.service.ts: import { Injectable } from '@angular/core'; import { Router, NavigationEnd, ActivatedRoute } from '@angular/router'; import { filter, map } from 'rxjs/operators'; import { Observable } from 'rxjs'; export interface Breadcrumb { label: string; url: string; } @Injectable({ providedIn: 'root' }) export class BreadcrumbService { breadcrumbs$: Observable<Breadcrumb[]>; constructor(private router: Router, private activatedRoute: ActivatedRoute) { this.breadcrumbs$ = this.router.events.pipe( filter(event => event instanceof NavigationEnd), map(event => { const root = this.activatedRoute.root; return this.createBreadcrumbs(root); }) ); } private createBreadcrumbs(route: ActivatedRoute, url: string = '', breadcrumbs: Breadcrumb[] = []): Breadcrumb[] { const children: ActivatedRoute[] = route.children; if (children.length === 0) { return breadcrumbs; } for (const child of children) { const routeURL: string = child.snapshot.url.map(segment => segment.path).join('/'); if (routeURL !== '') { url += `/${routeURL}`; } const label = child.snapshot.data['breadcrumb']; if (label) { breadcrumbs.push({ label, url }); } return this.createBreadcrumbs(child, url, breadcrumbs); } return breadcrumbs; } }
|   --- colors.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>United Airlines Palette</title> <style> body { font-family: Arial, sans-serif; line-height: 1.5; margin: 20px; } table { width: 100%; border-collapse: collapse; } th, td { border: 1px solid #ccc; padding: 10px; text-align: left; } th { background-color: #f4f4f4; } .color-box { width: 50px; height: 50px; display: inline-block; border-radius: 5px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } .header-example { width: 100%; height: 100px; border-radius: 5px; margin: 10px 0; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15); } .united-blue { background: radial-gradient(circle at center, #0033A0, #00297D); } .rhapsody-blue { background: radial-gradient(circle at center, #003057, #00203D); } .runway-gray { background: linear-gradient(to bottom, #E6E7E8, #CBCBCD); } .dusk { background: linear-gradient(to right, #9B9FBB, #7E8298); } .premium-purple { background: radial-gradient(circle at center, #4B306A, #3B2553); } .atlantic-amethyst { background: linear-gradient(to bottom, #7D5FB2, #614989); } .pacific-blue { background: radial-gradient(circle at center, #00B2A9, #008983); } .sky-blue { background: linear-gradient(to right, #6CB4E0, #4F8CB4); } .platinum { background: radial-gradient(circle at center, #A2AAAD, #808586); } .cloud-white { background: linear-gradient(to bottom, #F1F2F2, #D7D8D8); } .balanced-beige-gold { background: radial-gradient(circle at center, #C9A972, #D8BB8A, #E6CFA5, #F1DDBE); } .success { background: radial-gradient(circle at center, #28A745, #1E7A34); } .warning { background: radial-gradient(circle at center, #FFC107, #E0A800); } .danger { background: radial-gradient(circle at center, #DC3545, #B02A37); } .info { background: radial-gradient(circle at center, #17A2B8, #117A8B); } .error { background: radial-gradient(circle at center, #C82333, #9A1F29); } </style> </head> <body> <h1>United Airlines Palette with Header Examples</h1> <table> <thead> <tr> <th>Color Name</th> <th>Color Name 2</th> <th>Hex Code</th> <th>Gradient Definition</th> <th>Sample</th> <th>Header Example</th> <th>Use Cases</th> </tr> </thead> <tbody> <tr> <td>United Blue</td> <td>Digital Sapphire, Quantum Sky, Blue Alloy</td> <td>#0033A0</td> <td>Radial Gradient: #0033A0, #00297D</td> <td> <div class="color-box united-blue"></div> </td> <td> <div class="header-example united-blue"></div> </td> <td>Primary, Buttons, Nav Menu</td> </tr> <tr> <td>Rhapsody Blue</td> <td>Midnight Carbon, Indigo Core, Deep Silicon</td> <td>#003057</td> <td>Radial Gradient: #003057, #00203D</td> <td> <div class="color-box rhapsody-blue"></div> </td> <td> <div class="header-example rhapsody-blue"></div> </td> <td>Background, Secondary Headers, Borders</td> </tr> <tr> <td>Runway Gray</td> <td>Titanium Mist, Cloud Alloy, Digital Quartz</td> <td>#E6E7E8</td> <td>Linear Gradient: #E6E7E8, #CBCBCD</td> <td> <div class="color-box runway-gray"></div> </td> <td> <div class="header-example runway-gray"></div> </td> <td>Background, Disabled States, Borders</td> </tr> <tr> <td>Dusk</td> <td>Amethyst Fog, Violet Cloud, Digital Orchid</td> <td>#9B9FBB</td> <td>Linear Gradient: #9B9FBB, #7E8298</td> <td> <div class="color-box dusk"></div> </td> <td> <div class="header-example dusk"></div> </td> <td>Accents, Text Hover, Selected States</td> </tr> <tr> <td>Premium Purple</td> <td>Plasma Violet, Quantum Plum, Tech Amethyst</td> <td>#4B306A</td> <td>Radial Gradient: #4B306A, #3B2553</td> <td> <div class="color-box premium-purple"></div> </td> <td> <div class="header-example premium-purple"></div> </td> <td>Premium Features, Buttons, Highlights</td> </tr> <tr> <td>Atlantic Amethyst</td> <td>Neon Lavender, Mineral Glow, Crystal Orchid</td> <td>#7D5FB2</td> <td>Linear Gradient: #7D5FB2, #614989</td> <td> <div class="color-box atlantic-amethyst"></div> </td> <td> <div class="header-example atlantic-amethyst"></div> </td> <td>Links, Text Selected, Call-to-Action</td> </tr> <tr> <td>Pacific Blue</td> <td>Digital Aqua, Silicon Crest, Coastal Alloy</td> <td>#00B2A9</td> <td>Radial Gradient: #00B2A9, #008983</td> <td> <div class="color-box pacific-blue"></div> </td> <td> <div class="header-example pacific-blue"></div> </td> <td>Buttons, Nav Menu, Active States</td> </tr> <tr> <td>Sky Blue</td> <td>Arctic Tech, Horizon Core, Frosted Silicon</td> <td>#6CB4E0</td> <td>Linear Gradient: #6CB4E0, #4F8CB4</td> <td> <div class="color-box sky-blue"></div> </td> <td> <div class="header-example sky-blue"></div> </td> <td>Text, Hover Effects, Subtle Highlights</td> </tr> <tr> <td>Platinum</td> <td>Metal Glow, Lunar Alloy, Circuit Silver</td> <td>#A2AAAD</td> <td>Radial Gradient: #A2AAAD, #808586</td> <td> <div class="color-box platinum"></div> </td> <td> <div class="header-example platinum"></div> </td> <td>Borders, Dividers, Neutral Backgrounds</td> </tr> <tr> <td>Cloud White</td> <td>Neural Cloud, Pearl Alloy, Tech Mist</td> <td>#F1F2F2</td> <td>Linear Gradient: #F1F2F2, #D7D8D8</td> <td> <div class="color-box cloud-white"></div> </td> <td> <div class="header-example cloud-white"></div> </td> <td>Main Background, Text Background</td> </tr> <tr> <td>Balanced Beige-Gold</td> <td>Quantum Gold, Solar Alloy, Crystal Dune</td> <td>#D8BB8A</td> <td>Radial Gradient: #C9A972, #D8BB8A, #E6CFA5, #F1DDBE</td> <td> <div class="color-box balanced-beige-gold"></div> </td> <td> <div class="header-example balanced-beige-gold"></div> </td> <td>Headers, Highlights, Premium Sections</td> </tr> <tr> <td rowspan="2">Success</td> <td>Emerald, Growth Green, Vitality</td> <td>#28A745</td> <td>Radial Gradient: #28A745, #1E7A34</td> <td><div class="color-box success"></div></td> <td><div class="header-example success"></div></td> <td>Dialog Headers</td> </tr> <tr> <td>Soft Emerald, Pastel Green</td> <td>#A7E3B2</td> <td>Radial Gradient: #A7E3B2, #8EDBA2</td> <td><div class="color-box" style="background: radial-gradient(circle, #A7E3B2, #8EDBA2);"></div></td> <td><div class="header-example" style="background: radial-gradient(circle, #A7E3B2, #8EDBA2);"></div></td> <td>Text Backgrounds, Form Highlights</td> </tr> <tr> <td rowspan="2">Warning</td> <td>Amber, Alert Yellow, Solar Glow</td> <td>#FFC107</td> <td>Radial Gradient: #FFC107, #E0A800</td> <td><div class="color-box warning"></div></td> <td><div class="header-example warning"></div></td> <td>Dialog Headers</td> </tr> <tr> <td>Soft Amber, Pastel Yellow</td> <td>#FFE59B</td> <td>Radial Gradient: #FFE59B, #FFD86A</td> <td><div class="color-box" style="background: radial-gradient(circle, #FFE59B, #FFD86A);"></div></td> <td><div class="header-example" style="background: radial-gradient(circle, #FFE59B, #FFD86A);"></div></td> <td>Text Backgrounds, Form Highlights</td> </tr> <tr> <td rowspan="2">Danger</td> <td>Crimson, Risk Red, Fire Glow</td> <td>#DC3545</td> <td>Radial Gradient: #DC3545, #B02A37</td> <td><div class="color-box danger"></div></td> <td><div class="header-example danger"></div></td> <td>Dialog Headers</td> </tr> <tr> <td>Soft Crimson, Pastel Red</td> <td>#F5A6A8</td> <td>Radial Gradient: #F5A6A8, #E58C8E</td> <td><div class="color-box" style="background: radial-gradient(circle, #F5A6A8, #E58C8E);"></div></td> <td><div class="header-example" style="background: radial-gradient(circle, #F5A6A8, #E58C8E);"></div></td> <td>Text Backgrounds, Form Highlights</td> </tr> <tr> <td rowspan="2">Info</td> <td>Azure Glow, Digital Breeze, Tech Sky</td> <td>#17A2B8</td> <td>Radial Gradient: #17A2B8, #117A8B</td> <td><div class="color-box info"></div></td> <td><div class="header-example info"></div></td> <td>Dialog Headers</td> </tr> <tr> <td>Soft Azure, Pastel Blue</td> <td>#A3D7E8</td> <td>Radial Gradient: #A3D7E8, #8CCDE2</td> <td><div class="color-box" style="background: radial-gradient(circle, #A3D7E8, #8CCDE2);"></div></td> <td><div class="header-example" style="background: radial-gradient(circle, #A3D7E8, #8CCDE2);"></div></td> <td>Text Backgrounds, Form Highlights</td> </tr> <tr> <td rowspan="2">Error</td> <td>Cerise, Critical Red, Alert Crimson</td> <td>#C82333</td> <td>Radial Gradient: #C82333, #9A1F29</td> <td><div class="color-box error"></div></td> <td><div class="header-example error"></div></td> <td>Dialog Headers</td> </tr> <tr> <td>Soft Cerise, Pastel Red</td> <td>#EFA3A5</td> <td>Radial Gradient: #EFA3A5, #D9898A</td> <td><div class="color-box" style="background: radial-gradient(circle, #EFA3A5, #D9898A);"></div></td> <td><div class="header-example" style="background: radial-gradient(circle, #EFA3A5, #D9898A);"></div></td> <td>Text Backgrounds, Form Highlights</td> </tr> </tbody> </table> </body>
|   --- favicon.ico: <image file>
|   --- fonts.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Font Specification</title> <style> body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; } h1 { font-family: 'Roboto', sans-serif; font-size: 2.5em; font-weight: 700; margin-bottom: 10px; color: #0033A0; } h2 { font-family: 'Roboto', sans-serif; font-size: 2em; font-weight: 500; margin-bottom: 10px; color: #4B306A; } h3 { font-family: 'Roboto', sans-serif; font-size: 1.5em; font-weight: 400; margin-bottom: 10px; color: #7D5FB2; } h4, h5, h6 { font-family: 'Roboto', sans-serif; color: #444; } h4 { font-size: 1.2em; font-weight: 500; } h5 { font-size: 1em; font-weight: 400; } h6 { font-size: 0.9em; font-weight: 400; } p, li { font-family: 'Open Sans', sans-serif; font-size: 1em; font-weight: 300; color: #333; line-height: 1.8; } a { font-family: 'Open Sans', sans-serif; font-size: 1em; font-weight: 400; text-decoration: none; color: #00B2A9; } a:hover { text-decoration: underline; color: #007F77; } button { font-family: 'Roboto', sans-serif; font-size: 1em; font-weight: 500; padding: 10px 20px; color: #fff; background-color: #0033A0; border: none; border-radius: 5px; cursor: pointer; } button:hover { background-color: #00297D; } code { font-family: 'Courier New', monospace; background-color: #f4f4f4; padding: 2px 4px; border-radius: 3px; font-size: 0.9em; } small { font-family: 'Open Sans', sans-serif; font-size: 0.8em; color: #666; } b, strong { font-weight: 700; } i, em { font-style: italic; } mark { background-color: #ff0; color: #000; padding: 2px 4px; } del { text-decoration: line-through; color: #dc3545; } ins { text-decoration: underline; color: #28a745; } sub { font-size: 0.8em; vertical-align: sub; } sup { font-size: 0.8em; vertical-align: super; } hr { border: 0; height: 1px; background: #ccc; margin: 20px 0; } ul { list-style-type: disc; margin-left: 20px; } ol { list-style-type: decimal; margin-left: 20px; } dl { margin: 20px 0; } dt { font-weight: 700; color: #0033A0; } dd { margin-left: 20px; color: #555; } table { width: 100%; border-collapse: collapse; } th, td { border: 1px solid #ccc; padding: 10px; text-align: left; } th { background-color: #f4f4f4; } </style> </head> <body> <h1>Font Specification</h1> <h2>Headers</h2> <ul> <h1>H1: Roboto, 2.5em, Bold, Primary Color (#0033A0)</h1> <h2>H2: Roboto, 2em, Semi-Bold, Secondary Color (#4B306A)</h2> <h3>H3: Roboto, 1.5em, Regular, Tertiary Color (#7D5FB2)</h3> <h4>H4-H6: Roboto, Gradually Smaller and Lighter (#444)</h4> <h5>H4-H6: Roboto, Gradually Smaller and Lighter (#444)</h5> <h6>H4-H6: Roboto, Gradually Smaller and Lighter (#444)</h6> </ul> <h2>Text Elements</h2> <p>Example of <b>bold</b> and <strong>important</strong> text.</p> <p>Example of <i>italic</i> and <em>emphasized</em> text.</p> <p>Example of <mark>highlighted</mark>, <del>deleted</del>, and <ins>inserted</ins> text.</p> <p>Example of <sub>subscript</sub> and <sup>superscript</sup> text.</p> <h2>Lists</h2> <ul> <li>Unordered list item 1</li> <li>Unordered list item 2</li> </ul> <ol> <li>Ordered list item 1</li> <li>Ordered list item 2</li> </ol> <h2>Description List</h2> <dl> <dt>Term 1</dt> <dd>Description for Term 1</dd> <dt>Term 2</dt> <dd>Description for Term 2</dd> </dl> <h2>Tables</h2> <table> <thead> <tr> <th>Header 1</th> <th>Header 2</th> </tr> </thead> <tbody> <tr> <td>Data 1</td> <td>Data 2</td> </tr> </tbody> </table> <hr> <h2>Small Text</h2> <p><small>This is small text, often used for footnotes or additional information.</small></p> </body> </html>
|   --- index.html: <!doctype html> <html> <head> <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> <meta charset="utf-8"> <title>Ixtlan Demo</title> <base href="/"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="icon" type="image/x-icon" href="favicon.ico"> </head> <body> <app-root></app-root> </body> </html>
|   --- main.ts: import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module'; platformBrowserDynamic().bootstrapModule(AppModule) .catch(err => console.error(err));
|   --- polyfills.ts: import 'zone.js';
|   --- public-api.ts: // File: src/public-api.ts export * from './components/ixt-table/ixt-table.interfaces'; // Core UI Components export * from './components/ixt-button/ixt-button.index'; export * from './components/ixt-dialog/ixt-dialog.index'; export * from './components/ixt-tabset/ixt-tabset.index'; export * from './components/ixt-panel/ixt-panel.index'; export * from './components/ixt-menu/ixt-menu.index'; export * from './components/ixt-tree/ixt-tree.index'; export * from './components/ixt-accordian/ixt-accordian.index'; // Canvas & Viewport Components export * from './components/ixt-canvas/ixt-canvas.index'; export * from './components/ixt-viewport/ixt-viewport.index'; // Form Components export * from './components/ixt-expression-builder/ixt-expression-builder.index'; // Diagram Components export * from './components/ixt-diagram/ixt-diagram.index'; export * from './components/ixt-diagram/types/clazz/ixt-clazz.index'; export * from './components/ixt-diagram/types/deployment/ixt-deployment.index'; export * from './components/ixt-diagram/types/EBNF/ixt.ebnf.index'; export * from './components/ixt-diagram/types/flow/ixt-flow.index'; export * from './components/ixt-diagram/types/gannt/gannt.index'; export * from './components/ixt-diagram/types/network/ixt-network.index'; export * from './components/ixt-diagram/types/sankey/ixt-sankey.index'; export * from './components/ixt-diagram/types/wireframe/ixt-wireframe.index'; // Layer Management export * from './components/ixt-layer-manager/ixt-layer-manager.index'; // Calendar Component export * from './components/ixt-calendar/ixt-calendar.index'; // Map Component export * from './components/ixt-map/ixt-map.index'; // Split Pane Component export * from './components/ixt-splitpane/index'; // Add to src/public-api.ts export * from './components/theme/theme.types'; export * from './components/theme/theme.colors'; // In src/public-api.ts, add: export interface TableConfig { columns: { [key: string]: { title: string; type?: string; sortable?: boolean; filterable?: boolean; } }; sortable?: boolean; filterable?: boolean; pageSize?: number; }
--- .editorconfig: # Editor configuration, see https://editorconfig.org root = true [*] charset = utf-8 indent_style = space indent_size = 2 insert_final_newline = true trim_trailing_whitespace = true [*.ts] quote_type = single [*.md] max_line_length = off trim_trailing_whitespace = false
--- .gitignore: # Compiled output /dist /tmp /out-tsc /bazel-out # Node modules and logs /node_modules npm-debug.log* yarn-debug.log* yarn-error.log* .pnpm-debug.log* # IDEs and editors .idea/ /.project .classpath .c9/ /.settings/ *.launch *.sublime-workspace # Visual Studio Code .vscode/ !.vscode/settings.json # Optional: Share common workspace settings !.vscode/extensions.json # Optional: Share recommended extensions # Ignore user-specific files .vscode/launch.json # Debug configurations (usually user-specific) .vscode/tasks.json # Build tasks (often user/environment-specific) # History files (from various plugins) .history/ # Angular and TypeScript specific .angular/ .angular/cache .sass-cache/ coverage/ build/ libpeerconnection.log testem.log typings/ *.js *.d.ts *.js.map # Environment files .env .env.local .env.*.local # System files .DS_Store Thumbs.db # Temporary or backup files *.tmp *.bak *.swp *.swo *.~lock.* # GitHub .github/ # Miscellaneous connect.lock
--- .npmrc: { "name": "ixtlan", "version": "0.0.6", "description": "A component library for reusable Angular components.", "main": "dist/ixtlan/bundles/ixtlan.umd.js", "scripts": { "ng": "ng", "start": "ng serve", "build": "ng build ixtlan", "watch": "ng build ixtlan --watch", "test": "ng test", "release": "npm version patch && git push && git push origin --tags && npm publish dist/ixtlan" }, "publishConfig": { "access": "public" }, "repository": { "type": "git", "url": "https://github.com/dvanauken/ixtlan.git" }, "author": "Your Name", "license": "MIT", "dependencies": { "@angular/core": "^16.2.0", "@angular/cli": "^16.2.0" }, "devDependencies": { "typescript": "^5.1.0" } }
--- LICENSE: This software is proprietary and confidential. It is intended for personal use only and may not be copied, modified, or distributed without explicit, written permission from the author.
--- README.md: # Ixtlan Angular Component Library This library contains reusable Angular components, starting with a configurable data table component. ## Development Setup ### Building the Library From the ixtlan project root: ```bash ng build ``` The build output will be in `dist/ixtlan/`. ### Development with GeoView To develop the library while testing it in GeoView: 1. Build the library first: ```bash cd /path/to/ixtlan ng build ``` 2. Link the built library: ```bash cd dist/ixtlan npm link ``` 3. Link from GeoView: ```bash cd /path/to/geoview npm link ixtlan ``` Now you can import components from the library: ```typescript import { IxtTableModule } from 'ixtlan'; @NgModule({ imports: [ IxtTableModule, // ... ] }) export class AppModule { } ``` ### Making Changes When you make changes to the library: 1. Rebuild the library: ```bash cd /path/to/ixtlan ng build ``` 2. Changes will be automatically available to GeoView through the npm link. ### Unlinking To remove the development links: 1. In GeoView: ```bash npm unlink ixtlan ``` 2. In Ixtlan: ```bash cd dist/ixtlan npm unlink ``` ## Using the Library ### IxtTable Component Import the module: ```typescript import { IxtTableModule } from 'ixtlan'; ``` Basic usage in template: ```html <ixt-table [data]="yourData" [columns]="yourColumns"> </ixt-table> ``` Configure columns: ```typescript import { IxtTableColumn } from 'ixtlan'; columns: IxtTableColumn[] = [ { field: 'name', header: 'Name' }, { field: 'age', header: 'Age' } ]; ``` ### Project Structure ``` ixtlan/ ├── src/ │ ├── components/ │ │ └── ixt-table/ │ │ ├── ixt-table.component.ts │ │ ├── ixt-table.component.html │ │ ├── ixt-table.component.scss │ │ ├── ixt-table.interfaces.ts │ │ ├── ixt-table.module.ts │ │ └── ixt-table.index.ts │ └── public-api.ts ├── package.json └── ng-package.json ```
--- TiltedPerspective.gif: <image file>
--- TiltedPerspective.jpg: <image file>
--- TiltedPerspective.png: <image file>
--- branding.html: <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>CSS Style Sheet Specification</title> </head> <body> <h1>Suggested Outline for a Comprehensive CSS Style Sheet Specification</h1> <ol> <li> <h2>Introduction</h2> <ul> <li><strong>Purpose:</strong> Explain the purpose of the style sheet and its role in maintaining consistent branding and UI/UX.</li> <li><strong>Audience:</strong> Developers, designers, and QA teams.</li> <li><strong>Scope:</strong> Include components like typography, colors, spacing, buttons, forms, etc.</li> </ul> </li> <li> <h2>Typography</h2> <ul> <li><strong>Font Families:</strong> Define primary, secondary, and fallback fonts.</li> <li> <strong>Headers:</strong> <ul> <li>Levels (H1–H6)</li> <li>Font size, weight, and color</li> </ul> </li> <li> <strong>Body Text:</strong> <ul> <li>Paragraphs, inline elements (bold, italic, small, etc.)</li> </ul> </li> <li> <strong>Lists:</strong> <ul> <li>Ordered, unordered, and description lists</li> </ul> </li> <li> <strong>Special Text:</strong> <ul> <li>Blockquotes, citations, code snippets, superscript, subscript, etc.</li> </ul> </li> </ul> </li> <li> <h2>Color Palette</h2> <ul> <li><strong>Primary Colors:</strong> Core branding colors (e.g., blue, green, gold).</li> <li><strong>Secondary Colors:</strong> Supporting accents for UI elements.</li> <li> <strong>Semantic Colors:</strong> <ul> <li>Success, Warning, Danger, Info, Error</li> </ul> </li> <li><strong>Gradients:</strong> Defined for backgrounds and highlights.</li> <li><strong>Usage Guidelines:</strong> Specific colors for headers, buttons, links, and backgrounds.</li> </ul> </li> <li> <h2>Spacing and Layout</h2> <ul> <li><strong>Margins and Padding:</strong> Define global spacing units (e.g., 8px, 16px).</li> <li> <strong>Grid System:</strong> <ul> <li>Breakpoints for responsive design.</li> <li>Columns, rows, and gutters.</li> </ul> </li> <li> <strong>Containers:</strong> <ul> <li>Widths for full-width, fluid, and fixed containers.</li> </ul> </li> </ul> </li> <li> <h2>Buttons</h2> <ul> <li> <strong>Primary and Secondary Buttons:</strong> Font styles, padding, border radius, and hover states. </li> <li><strong>Disabled Buttons:</strong> Styles for disabled states.</li> <li><strong>Icon Buttons:</strong> Styling for buttons with icons.</li> </ul> </li> <li> <h2>Forms</h2> <ul> <li> <strong>Inputs:</strong> Text fields, checkboxes, radio buttons, dropdowns. </li> <li><strong>Labels:</strong> Placement and alignment.</li> <li> <strong>Validation States:</strong> Success, Warning, Error states. </li> <li> <strong>Placeholder Text:</strong> Styling for placeholder content. </li> </ul> </li> <li> <h2>Links</h2> <ul> <li><strong>Default Styles:</strong> Font size, weight, and colors.</li> <li><strong>Hover and Active States:</strong> Color transitions or underline effects.</li> </ul> </li> <li> <h2>Tables</h2> <ul> <li><strong>Structure:</strong> Borders, padding, and alignment.</li> <li><strong>Headers and Rows:</strong> Alternating row styles.</li> <li><strong>Responsive Tables:</strong> Behavior on smaller screens.</li> </ul> </li> <li> <h2>Navigation</h2> <ul> <li><strong>Menus:</strong> Horizontal and vertical layouts.</li> <li><strong>Dropdowns:</strong> Styling for submenus.</li> <li><strong>Active and Hover States.</strong></li> </ul> </li> <li> <h2>Components</h2> <ul> <li> <strong>Cards:</strong> Header, body, and footer sections. </li> <li><strong>Modals:</strong> Overlays, close buttons, and content areas.</li> <li> <strong>Tooltips and Popovers:</strong> Default and hover states. </li> </ul> </li> <li> <h2>Animations and Transitions</h2> <p>Define duration, easing, and properties for hover effects, modals, and dropdowns.</p> </li> <li> <h2>Accessibility</h2> <ul> <li><strong>Focus States:</strong> Outline and color for keyboard navigation.</li> <li><strong>Contrast Ratios:</strong> Ensure readability for all text and components.</li> <li><strong>ARIA Roles:</strong> Guidelines for screen readers.</li> </ul> </li> <li> <h2>Theming</h2> <ul> <li><strong>Dark and Light Modes:</strong> Colors and contrast adjustments.</li> <li><strong>Custom Properties:</strong> CSS variables for dynamic themes.</li> </ul> </li> <li> <h2>Appendix</h2> <ul> <li><strong>Global Reset:</strong> Normalize or reset styles.</li> <li><strong>Utility Classes:</strong> Margin, padding, text alignment, etc.</li> <li><strong>Testing Guidelines:</strong> Cross-browser compatibility checks.</li> </ul> </li> </ol> </body> </html>
