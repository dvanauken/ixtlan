\-- src
    +-- components
    |   +-- ixt-map
    |   |   +-- models
    |   |   |   \-- sphere
    |   |   |       +-- types
    |   |   |       |   --- GeometryCollection.ts: <empty file>
    |   |   |       |   --- LineString.ts: <empty file>
    |   |   |       |   --- MultiLineString.ts: <empty file>
    |   |   |       |   --- MultiPoint.ts: <empty file>
    |   |   |       |   --- MultiPolygon.ts: <empty file>
    |   |   |       |   --- Point.ts: <empty file>
    |   |   |       |   --- Polygon.ts: <empty file>
    |   |   |       --- Angle.ts: <empty file>
    |   |   |       --- Arc.ts: <empty file>
    |   |   |       --- Azimuth.ts: <empty file>
    |   |   |       --- Bearing.ts: <empty file>
    |   |   |       --- Collection.ts: <empty file>
    |   |   |       --- Coordinate.ts: <empty file>
    |   |   |       --- Geodesic.ts: <empty file>
    |   |   |       --- GreatCircle.ts: <empty file>
    |   |   |       --- Horizon.ts: <empty file>
    |   |   |       --- Luxodrome.ts: <empty file>
    |   |   |       --- Nadir.ts: <empty file>
    |   |   |       --- Point.ts: <empty file>
    |   |   |       --- Polygon.ts: <empty file>
    |   |   |       --- Rhumb.ts: <empty file>
    |   |   |       --- SmallCircle.ts: <empty file>
    |   |   |       --- Sphere.ts: <empty file>
    |   |   |       --- Triangle.ts: <empty file>
    |   |   |       --- Zenith.ts: <empty file>
    |   |   +-- types
    |   |   |   +-- azimuthal
    |   |   |   |   +-- gnomic
    |   |   |   |   |   --- gnomic.projection.ts: <empty file>
    |   |   |   |   +-- orthographic
    |   |   |   |   |   --- orthographic.projection.ts: <empty file>
    |   |   |   |   +-- perspective
    |   |   |   |   |   --- perspective.projection.ts: <empty file>
    |   |   |   |   --- azimuthal.projection.ts: <empty file>
    |   |   |   +-- conical
    |   |   |   |   \-- lambert
    |   |   |   |       --- lambert.projection.ts: <empty file>
    |   |   |   \-- cylindrical
    |   |   |       \-- utm
    |   |   |           --- utm.projection.ts: <empty file>
    |   |   --- geo-processing.service.ts: // Create the GeoJSON processing service (geo-processing.service.ts) import { Injectable } from '@angular/core'; import { Feature, LineString, GeoJsonProperties, Geometry } from 'geojson'; import * as d3 from 'd3'; import { GeoFeatureProperties, GeoProcessingOptions } from './geo.types'; @Injectable({ providedIn: 'root' }) export class GeoProcessingService { processFeatures(features: Feature[], options: GeoProcessingOptions = {}): Feature[] { let processedFeatures = [...features]; // Apply route interpolation if needed if (options.interpolateRoutes) { processedFeatures = this.interpolateRoutes(processedFeatures, { pointsPerRoute: options.pointsPerRoute, minPoints: options.minPointsPerRoute }); } // Apply filtering if expression provided if (options.filterExpression) { processedFeatures = this.filterFeatures(processedFeatures, options.filterExpression); } return processedFeatures; } private interpolateRoutes( features: Feature[], options: { pointsPerRoute?: number; minPoints?: number } = {} ): Feature[] { const minPoints = options.minPoints || 5; return features.map(feature => { if (feature.geometry.type !== 'LineString') { return feature; } const line = feature.geometry as LineString; const coordinates = line.coordinates; if (coordinates.length !== 2) { return feature; } const start = coordinates[0] as [number, number]; const end = coordinates[1] as [number, number]; const route = d3.geoInterpolate(start, end); // Calculate distance and points const distance = d3.geoDistance(start, end) * 3959; // Earth radius in miles const pointsPer5Miles = Math.ceil(distance / 5); const numPoints = Math.max(minPoints, options.pointsPerRoute || pointsPer5Miles); const newCoordinates = Array.from({ length: numPoints }, (_, i) => { const t = i / (numPoints - 1); return route(t); }); return { ...feature, geometry: { ...line, coordinates: newCoordinates } }; }); } private filterFeatures(features: Feature[], expression: string): Feature[] { const filterFn = this.createFilterFunction(expression); return features.filter(feature => { try { return filterFn ? filterFn(feature) : true; } catch (e) { console.error('Error applying filter to feature:', e); return true; } }); } private createFilterFunction(expression: string): Function | null { if (!expression) return null; try { return new Function('feature', ` try { const properties = feature.properties; return ${expression}; } catch (e) { console.error('Filter expression error:', e); return true; } `); } catch (e) { console.error('Error creating filter function:', e); return null; } } // private createFilterFunction(): Function | null { // if (!this.filterExpression) return null; // console.log('Creating filter with expression:', this.filterExpression); // return new Function('feature', ` // try { // const properties = feature.properties; // //console.log('Evaluating:', properties); // return ${this.filterExpression}; // } catch (e) { // console.error('Filter expression error:', e); // return true; // If there's an error, include the feature // } // `); // } }
    |   |   --- geo.types.ts: // First, let's create the interfaces (geo.types.ts) export interface GeoFeatureProperties { [key: string]: any; } export interface GeoProcessingOptions { interpolateRoutes?: boolean; pointsPerRoute?: number; minPointsPerRoute?: number; filterExpression?: string; }
    |   |   --- ixt-layer.component.ts: import { Component, Input, Output, EventEmitter, ElementRef, Host, ChangeDetectionStrategy, ChangeDetectorRef, SimpleChanges } from '@angular/core'; import * as d3 from 'd3'; import { IxtMapComponent } from './ixt-map.component'; import { GeoProcessingService } from './geo-processing.service'; import { LayerRenderService } from './layer-render.service'; import { LayerEventHandlers, LayerEventService } from './layer-event.service'; import { LayerStateService } from './layer-state.service'; import { Feature } from 'geojson'; @Component({ selector: 'ixt-layer', template: ` <svg:g> <ng-content></ng-content> </svg:g> `, changeDetection: ChangeDetectionStrategy.OnPush }) export class IxtLayerComponent { @Input() src: string = ''; @Input() stroke: string = 'black'; @Input() fill: string = 'none'; @Output() click = new EventEmitter<MouseEvent>(); @Output() hover = new EventEmitter<MouseEvent>(); private initialized = false; private pathGenerator!: d3.GeoPath; private filterExpression: string = ''; constructor( @Host() private mapComponent: IxtMapComponent, private elementRef: ElementRef, private cdr: ChangeDetectorRef, private geoProcessingService: GeoProcessingService, private layerRenderService: LayerRenderService, private layerEventService: LayerEventService, private layerStateService: LayerStateService ) { } ngOnChanges(changes: SimpleChanges) { if ((changes['src'] || changes['stroke'] || changes['fill']) && this.initialized) { this.initializeLayer(); } } ngAfterContentInit() { const content = this.elementRef.nativeElement.textContent?.trim(); if (content) { this.filterExpression = content; } } setProjection(pathGenerator: d3.GeoPath): void { this.pathGenerator = pathGenerator; this.initializeLayer(); } async initializeLayer(): Promise<void> { if (this.initialized) return; if (!this.validateContainer()) return; try { const features = await this.loadGeoJsonData(); const handlers = this.createEventHandlers(); this.renderLayer(features, handlers); this.initialized = true; } catch (error) { console.error('Layer initialization failed:', error); } } private validateContainer(): boolean { const container = this.mapComponent.getContainer(); if (!container || !this.pathGenerator) { console.error('Map container or projection not ready'); return false; } return true; } private async loadGeoJsonData(): Promise<Feature[]> { const data = await d3.json(this.src) as { features: Feature[] }; return this.geoProcessingService.processFeatures(data.features, { interpolateRoutes: true, filterExpression: this.filterExpression }); } private async renderLayer(features: any, handlers: any): Promise<void> { const container = this.mapComponent.getContainer(); const selection = this.layerRenderService.createLayer( d3.select(container.nativeElement), features, { stroke: this.stroke, fill: this.fill }, handlers ); this.layerStateService.addSelection(selection); this.cdr.markForCheck(); } private createEventHandlers(): LayerEventHandlers { return { onClick: (event: MouseEvent, datum: any) => { this.layerEventService.handleClick(event, this.mapComponent); this.click.emit(event); }, onMouseOver: (event: MouseEvent) => { this.layerEventService.handleMouseOver(event, this.mapComponent); this.hover.emit(event); }, onMouseOut: () => this.layerEventService.handleMouseOut(), onMouseMove: (event: MouseEvent) => event.stopPropagation() }; } ngOnDestroy(): void { this.layerStateService.clearSelections(); } }
    |   |   --- ixt-layer.module.ts: // src/components/ixt-map/layer/ixt-layer.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtLayerComponent } from './ixt-layer.component'; @NgModule({ declarations: [ IxtLayerComponent ], imports: [ CommonModule ], exports: [ IxtLayerComponent ] }) export class IxtLayerModule { }
    |   |   --- ixt-map.component.ts: import { Component, Input, ViewChild, ElementRef, ContentChildren, QueryList, AfterContentInit, OnDestroy, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core'; import * as d3 from 'd3'; import { IxtLayerComponent } from './ixt-layer.component'; import { GeoProjection, GeoPath } from 'd3'; import { BehaviorSubject, Subscription } from 'rxjs'; import { MapService } from './map.service'; import { MapDimensions, MapSelection, PathSelection, MapContainer } from './map.types'; @Component({ selector: 'ixt-map', template: ` <svg #mapSvg [attr.width]="width" [attr.height]="height" [attr.viewBox]="getViewBox()" style="display: block; background: lightgray;"> <g #mapGroup> <ng-content></ng-content> </g> </svg> `, styles: [` :host { display: block; } svg { display: block; } `], changeDetection: ChangeDetectionStrategy.OnPush }) export class IxtMapComponent implements AfterContentInit, OnDestroy { @Input() width: string | number = 800; @Input() height: string | number = 600; @Input() scale: string | number = 1; @Input() translate: string = '0,0'; @ViewChild('mapSvg') mapSvg!: ElementRef<SVGSVGElement>; @ViewChild('mapGroup') mapGroup!: MapContainer; @ContentChildren(IxtLayerComponent) layers!: QueryList<IxtLayerComponent>; private projection!: GeoProjection; private pathGenerator!: GeoPath; private selectedElement: SVGPathElement | null = null; private mapSubscriptions = new Subscription(); private projectionReady = new BehaviorSubject<boolean>(false); projectionReady$ = this.projectionReady.asObservable(); constructor( private cdr: ChangeDetectorRef, private mapService: MapService ) {} private getDimensions(): MapDimensions { return { width: this.mapService.getBaseDimension(this.width), height: this.mapService.getBaseDimension(this.height), scale: Number(this.scale), translate: this.translate }; } getViewBox(): string { const { width, height } = this.getDimensions(); return `0 0 ${width} ${height}`; } private initializeMap(): void { const dimensions = this.getDimensions(); const { projection, pathGenerator } = this.mapService.initializeProjection( dimensions.width, dimensions.height ); this.projection = projection; this.pathGenerator = pathGenerator; this.projectionReady.next(true); if (this.mapGroup) { const mapSelection = d3.select<SVGGElement, unknown>(this.mapGroup.nativeElement); mapSelection.on('click', () => this.clearSelection()); } setTimeout(() => { this.layers.forEach(layer => { layer.setProjection(this.pathGenerator); }); }); } getContainer(): MapContainer { return this.mapGroup; } getPathGenerator(): GeoPath { return this.pathGenerator; } clearSelection(): void { if (this.selectedElement) { d3.select<SVGPathElement, unknown>(this.selectedElement) .attr('stroke', function(this: SVGPathElement) { return this.getAttribute('data-original-stroke') || ''; }) .attr('stroke-width', '1'); this.selectedElement = null; this.cdr.markForCheck(); } } setSelection(element: SVGPathElement | null): void { this.clearSelection(); if (element) { this.selectedElement = element; this.cdr.markForCheck(); } } ngAfterContentInit(): void { this.initializeMap(); this.mapSubscriptions.add( this.layers.changes.subscribe(() => { this.initializeMap(); this.cdr.markForCheck(); }) ); } ngOnDestroy(): void { this.mapSubscriptions.unsubscribe(); this.selectedElement = null; this.projection = null as any; this.pathGenerator = null as any; } }
    |   |   --- ixt-map.index.ts: // ixt-map.index.ts // Components export { IxtMapComponent } from './ixt-map.component'; export { IxtLayerComponent } from './ixt-layer.component'; export { IxtMapModule } from './ixt-map.module'; // Services export { MapService } from './map.service'; export { GeoProcessingService } from './geo-processing.service'; export { LayerRenderService, LayerRenderOptions } from './layer-render.service'; export { LayerEventService, LayerEventHandlers } from './layer-event.service'; export { LayerStateService, LayerState } from './layer-state.service'; export { MapErrorService, MapError, MapErrorCode } from './map-error.service'; export { RouteProcessorService, RouteProcessingConfig } from './route-processor.service'; // Types export { MapDimensions, MapState, MapSelection, PathSelection, MapContainer, MapServiceState } from './map.types'; export { GeoFeatureProperties, GeoProcessingOptions } from './geo.types';
    |   |   --- ixt-map.module.ts: // ixt-map.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtMapComponent } from './ixt-map.component'; import { IxtLayerComponent } from './ixt-layer.component'; import { GeoProcessingService } from './geo-processing.service'; import { LayerEventService } from './layer-event.service'; import { LayerRenderService } from './layer-render.service'; import { LayerStateService } from './layer-state.service'; import { MapErrorService } from './map-error.service'; import { MapService } from './map.service'; import { RouteProcessorService } from './route-processor.service'; @NgModule({ declarations: [ IxtMapComponent, IxtLayerComponent ], imports: [ CommonModule ], exports: [ IxtMapComponent, IxtLayerComponent ], providers: [ MapService, GeoProcessingService, LayerRenderService, LayerEventService, LayerStateService, MapErrorService, RouteProcessorService ] }) export class IxtMapModule { }
    |   |   --- layer-event.service.ts: // layer-event.service.ts import { Injectable } from '@angular/core'; import { MapService } from './map.service'; import * as d3 from 'd3'; export interface LayerEventHandlers { onClick: (event: MouseEvent, datum: any) => void; onMouseOver: (event: MouseEvent) => void; onMouseOut: () => void; onMouseMove: (event: MouseEvent) => void; } @Injectable({ providedIn: 'root' }) export class LayerEventService { private hoveredElement: SVGPathElement | null = null; constructor(private mapService: MapService) {} handleClick(event: MouseEvent, mapRef: any): void { event.stopPropagation(); const clickedPath = event.currentTarget as SVGPathElement; if (clickedPath === mapRef['selectedElement']) { mapRef.setSelection(null); this.applyHoverEffect(clickedPath, false); } else { if (mapRef['selectedElement']) { this.applyHoverEffect(mapRef['selectedElement'], false); } mapRef.setSelection(clickedPath); this.applyHoverEffect(clickedPath, true); } } handleMouseOver(event: MouseEvent, mapRef: any): void { event.stopPropagation(); const currentPath = event.currentTarget as SVGPathElement; if (currentPath !== mapRef['selectedElement']) { this.applyHoverEffect(currentPath, true); this.hoveredElement = currentPath; } } handleMouseOut(): void { if (this.hoveredElement) { this.clearHoverState(this.hoveredElement); this.hoveredElement = null; } } private applyHoverEffect(element: SVGPathElement, isHover: boolean): void { const d3Element = d3.select(element); const currentFill = element.getAttribute('data-original-fill'); if (currentFill && currentFill !== 'none') { d3Element .attr('fill', currentFill) .attr('stroke-width', isHover ? '2' : '1'); } else { d3Element.attr('stroke-width', isHover ? '2' : '1'); } } private clearHoverState(element: SVGPathElement): void { const d3Element = d3.select(element); const originalFill = element.getAttribute('data-original-fill'); d3Element .attr('fill', originalFill) .attr('stroke-width', '1'); } }
    |   |   --- layer-render.service.ts: // layer-render.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { Feature, GeoJsonProperties, Geometry } from 'geojson'; import { MapService } from './map.service'; export interface LayerRenderOptions { stroke: string; fill: string; } @Injectable({ providedIn: 'root' }) export class LayerRenderService { constructor(private mapService: MapService) {} createLayer( container: d3.Selection<any, any, any, any>, features: Feature[], options: LayerRenderOptions, eventHandlers: { onClick: (event: MouseEvent, datum: any) => void; onMouseOver: (event: MouseEvent) => void; onMouseOut: (event: MouseEvent) => void; onMouseMove: (event: MouseEvent) => void; } ): d3.Selection<any, any, any, any> { const layerGroup = container .append('g') .attr('class', 'map-layer'); return layerGroup .selectAll('path') .data(features) .enter() .append('path') .attr('d', (datum) => this.mapService.getPathGenerator()(datum) || '') .attr('stroke', options.stroke) .attr('fill', options.fill) .attr('stroke-width', '1') .attr('data-original-fill', options.fill) .attr('data-original-stroke', options.stroke) .attr('vector-effect', 'non-scaling-stroke') .style('cursor', 'pointer') .on('click', eventHandlers.onClick) .on('mouseover', eventHandlers.onMouseOver) .on('mouseout', eventHandlers.onMouseOut) .on('mousemove', eventHandlers.onMouseMove); } }
    |   |   --- layer-state.service.ts: // layer-state.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; export interface LayerState { hoveredElement: SVGPathElement | null; selections: d3.Selection<any, any, any, any>[]; } @Injectable({ providedIn: 'root' }) export class LayerStateService { private state = new BehaviorSubject<LayerState>({ hoveredElement: null, selections: [] }); state$ = this.state.asObservable(); setHoveredElement(element: SVGPathElement | null): void { this.updateState({ hoveredElement: element }); } addSelection(selection: d3.Selection<any, any, any, any>): void { const currentState = this.state.value; this.updateState({ selections: [...currentState.selections, selection] }); } clearSelections(): void { const currentState = this.state.value; currentState.selections.forEach(selection => { if (selection && !selection.empty()) { selection.remove(); } }); this.updateState({ selections: [] }); } private updateState(partialState: Partial<LayerState>): void { this.state.next({ ...this.state.value, ...partialState }); } ngOnDestroy(): void { this.clearSelections(); this.state.complete(); } }
    |   |   --- map-error.service.ts: // map-error.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; export interface MapError { code: MapErrorCode; message: string; timestamp: Date; context?: any; } export enum MapErrorCode { INITIALIZATION_FAILED = 'INIT_FAILED', PROJECTION_FAILED = 'PROJ_FAILED', DATA_LOAD_FAILED = 'DATA_LOAD_FAILED', SELECTION_FAILED = 'SELECT_FAILED', INVALID_DIMENSIONS = 'INVALID_DIMS' } @Injectable({ providedIn: 'root' }) export class MapErrorService { private errorSubject = new BehaviorSubject<MapError | null>(null); private retryAttemptsMap = new Map<string, number>(); readonly maxRetryAttempts = 3; readonly errors$ = this.errorSubject.asObservable(); reportError(code: MapErrorCode, message: string, context?: any): void { const error: MapError = { code, message, timestamp: new Date(), context }; this.errorSubject.next(error); console.error(`Map Error [${code}]:`, message, context); } clearError(): void { this.errorSubject.next(null); } shouldRetry(operationKey: string): boolean { const attempts = this.retryAttemptsMap.get(operationKey) || 0; if (attempts < this.maxRetryAttempts) { this.retryAttemptsMap.set(operationKey, attempts + 1); return true; } return false; } resetRetryCount(operationKey: string): void { this.retryAttemptsMap.delete(operationKey); } }
    |   |   --- map.service.ts: // map.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { GeoProjection, GeoPath } from 'd3'; import { BehaviorSubject } from 'rxjs'; import { MapError, MapErrorCode, MapErrorService } from './map-error.service'; import { MapDimensions, MapState } from './map.types'; @Injectable({ providedIn: 'root' }) export class MapService { private projection!: GeoProjection; private pathGenerator!: GeoPath; private selectedElementSource = new BehaviorSubject<SVGPathElement | null>(null); private dimensions = new BehaviorSubject<MapDimensions>({ width: 800, height: 600, scale: 1, translate: '0,0' }); readonly selectedElement$ = this.selectedElementSource.asObservable(); readonly dimensions$ = this.dimensions.asObservable(); private errorSubject = new BehaviorSubject<MapError | null>(null); private retryAttemptsMap = new Map<string, number>(); readonly maxRetryAttempts = 3; readonly errors$ = this.errorSubject.asObservable(); constructor(private errorService: MapErrorService) {} initializeProjection(width: number, height: number): { projection: GeoProjection; pathGenerator: d3.GeoPath } { try { if (width <= 0 || height <= 0) { throw new Error('Invalid dimensions'); } this.projection = d3.geoMercator() .fitSize([width, height], { type: 'Sphere' }); this.pathGenerator = d3.geoPath().projection(this.projection); return { projection: this.projection, pathGenerator: this.pathGenerator }; } catch (error) { this.errorService.reportError( MapErrorCode.INITIALIZATION_FAILED, 'Failed to initialize map projection', { width, height, error } ); throw error; } } getProjection(): GeoProjection { return this.projection; } getPathGenerator(): GeoPath { return this.pathGenerator; } getDimensions(): MapDimensions { return this.dimensions.value; } setSelection(element: SVGPathElement | null): void { const previousElement = this.selectedElementSource.value; if (previousElement) { d3.select(previousElement) .attr('stroke', d3.select(previousElement).attr('data-original-stroke')) .attr('stroke-width', '1'); } this.selectedElementSource.next(element); } clearSelection(): void { this.setSelection(null); } getBaseDimension(value: string | number): number { if (typeof value === 'number') { return value; } const num = parseFloat(value); return isNaN(num) ? 800 : num; } reportError(code: MapErrorCode, message: string, context?: any): void { const error: MapError = { code, message, timestamp: new Date(), context }; this.errorSubject.next(error); console.error(`Map Error [${code}]:`, message, context); } clearError(): void { this.errorSubject.next(null); } shouldRetry(operationKey: string): boolean { const attempts = this.retryAttemptsMap.get(operationKey) || 0; if (attempts < this.maxRetryAttempts) { this.retryAttemptsMap.set(operationKey, attempts + 1); return true; } return false; } resetRetryCount(operationKey: string): void { this.retryAttemptsMap.delete(operationKey); } }
    |   |   --- map.types.ts: // map.types.ts import { ElementRef } from '@angular/core'; import { GeoProjection, GeoPath } from 'd3'; import { BehaviorSubject } from 'rxjs'; /** * Represents the dimensions and transformation properties of the map */ export interface MapDimensions { width: number; height: number; scale: number; translate: string; } /** * Represents the current state of the map including projection and dimensions */ export interface MapState { projection: GeoProjection; pathGenerator: GeoPath; dimensions: MapDimensions; } /** * Type definition for SVG group selection */ export interface MapSelection extends d3.Selection<SVGGElement, unknown, null, undefined> {} export interface PathSelection extends d3.Selection<SVGPathElement, unknown, null, undefined> {} export interface MapContainer extends ElementRef<SVGGElement> {} export interface MapServiceState { selectedElement: SVGPathElement | null; dimensions: MapDimensions; } /** * Type for map bounds */ export interface MapBounds { minX: number; minY: number; maxX: number; maxY: number; } /** * Configuration options for map initialization */ export interface MapConfig { dimensions?: Partial<MapDimensions>; projectionType?: 'mercator' | 'equalEarth' | 'equirectangular'; autoFit?: boolean; center?: [number, number]; zoom?: number; } /** * Map viewport state */ export interface ViewportState { center: [number, number]; zoom: number; rotation: [number, number, number]; bounds: MapBounds; } /** * Type for map event handlers */ export interface MapEventHandlers { onClick?(event: MouseEvent): void; onZoom?(state: ViewportState): void; onPan?(state: ViewportState): void; onBoundsChanged?(bounds: MapBounds): void; onProjectionChanged?(projection: GeoProjection): void; } /** * Type for map rendering options */ export interface MapRenderOptions { animate?: boolean; duration?: number; preserveAspectRatio?: boolean; useHardwareAcceleration?: boolean; }
    |   |   --- route-processor.service.ts: // route-processor.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { Feature, LineString, GeoJsonProperties } from 'geojson'; export interface RouteProcessingConfig { pointsPerMile?: number; minPoints?: number; earthRadiusMiles?: number; } const DEFAULT_CONFIG: RouteProcessingConfig = { pointsPerMile: 0.2, // 1 point every 5 miles minPoints: 5, earthRadiusMiles: 3959 }; @Injectable({ providedIn: 'root' }) export class RouteProcessorService { private config: RouteProcessingConfig; constructor() { this.config = DEFAULT_CONFIG; } setConfig(config: Partial<RouteProcessingConfig>): void { this.config = { ...DEFAULT_CONFIG, ...config }; } interpolateRoute(feature: Feature<LineString, GeoJsonProperties>): Feature<LineString, GeoJsonProperties> { const line = feature.geometry; const coordinates = line.coordinates; if (coordinates.length !== 2) { return feature; } const start = coordinates[0] as [number, number]; const end = coordinates[1] as [number, number]; const route = d3.geoInterpolate(start, end); const distance = d3.geoDistance(start, end) * this.config.earthRadiusMiles!; const numPoints = Math.max( this.config.minPoints!, Math.ceil(distance * this.config.pointsPerMile!) ); const newCoordinates = Array.from({ length: numPoints }, (_, i) => { const t = i / (numPoints - 1); return route(t); }); return { ...feature, geometry: { ...line, coordinates: newCoordinates } }; } calculateRouteDistance(coordinates: [number, number][]): number { if (coordinates.length < 2) return 0; return coordinates.reduce((total, coord, i) => { if (i === 0) return 0; const distance = d3.geoDistance(coordinates[i - 1], coord) * this.config.earthRadiusMiles!; return total + distance; }, 0); } }
    --- index.ts: // src/index.ts export * from './public-api';
    --- main.ts: import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module'; platformBrowserDynamic().bootstrapModule(AppModule) .catch(err => console.error(err));
    --- public-api.ts: // public-api.ts //---------------------------------- Core Components & Services ---------------------------------- export { IxtTableModule, IxtTableComponent, AirportCodeEditorComponent, CoordinateEditorComponent, BinaryEditorComponent, TableEditor, ColumnConfigs, EditService, FilterService, SortService, SelectionService, PaginationService } from './components/ixt-table/ixt-table.index'; export { IxtDialogModule, IxtDialogComponent, IxtDialogService } from './components/ixt-dialog/ixt-dialog.index'; export { IxtTabsetModule, IxtTabComponent, IxtTabsetComponent, ITabContent, ITabsetConfig } from './components/ixt-tabset/ixt-tabset.index'; //------------------------------------ Basic UI Components ------------------------------------- export { IxtButtonModule, IxtButtonComponent, ButtonSize } from './components/ixt-button/ixt-button.index'; export { IxtPanelModule, IxtPanelComponent } from './components/ixt-panel/ixt-panel.index'; export { IxtMenuModule, IxtMenuComponent } from './components/ixt-menu/ixt-menu.index'; export { IxtTreeModule, IxtTreeComponent } from './components/ixt-tree/ixt-tree.index'; export { IxtAccordianModule, IxtAccordianComponent } from './components/ixt-accordian/ixt-accordian.index'; //--------------------------------- Canvas & View Components ---------------------------------- export { IxtCanvasModule, IxtCanvasComponent } from './components/ixt-canvas/ixt-canvas.index'; //------------------------------------ Form Components --------------------------------------- export { IxtExpressionBuilderComponent, IxtExpressionBuilderModule } from './components/ixt-expression-builder/ixt-expression-builder.index'; //----------------------------------- Diagram Components ------------------------------------ export { IxtDiagramModule, IxtDiagramComponent } from './components/ixt-diagram/ixt-diagram.index'; export { IxtClazzDiagram, IxtClazzModule } from './components/ixt-diagram/types/clazz/ixt-clazz.index'; export { IxtDeploymentDiagram, IxtDeploymentModule } from './components/ixt-diagram/types/deployment/ixt-deployment.index'; export { IxtEbnfDiagram, IxtEbnfModule } from './components/ixt-diagram/types/EBNF/ixt-ebnf.index'; export { IxtFlowDiagram, IxtFlowModule } from './components/ixt-diagram/types/flow/ixt-flow.index'; export { IxtGanntDiagram, IxtGanntModule } from './components/ixt-diagram/types/gannt/gannt.index'; export { IxtNetworkDiagram, IxtNetworkModule } from './components/ixt-diagram/types/network/ixt-network.index'; export { IxtSankeyDiagram, IxtSankeyModule } from './components/ixt-diagram/types/sankey/ixt-sankey.index'; export { IxtWireframeDiagram, IxtWireframeModule } from './components/ixt-diagram/types/wireframe/ixt-wireframe.index'; //-------------------------------- Map & Layer Components ---------------------------------- //-------------------------------- Map & Layer Components ---------------------------------- export { // Components & Modules IxtMapModule, IxtMapComponent, IxtLayerComponent, IxtLayerModule, // Services MapService, GeoProcessingService, LayerRenderService, LayerEventService, LayerStateService, MapErrorService, RouteProcessorService, // Types & Interfaces MapDimensions, MapState, MapContainer, MapSelection, PathSelection, MapServiceState, LayerEventHandlers, LayerRenderOptions, LayerState, MapError, MapErrorCode, RouteProcessingConfig, GeoFeatureProperties, GeoProcessingOptions, } from './components/ixt-map/ixt-map.index'; //----------------------------- Utility & Layout Components -------------------------------- // export { // IxtSplitPaneModule, // IxtSplitPaneComponent // } from './components/ixt-splitpane/index'; // export { // IxtCalendarModule // } from './components/ixt-calendar/ixt-calendar.index'; // //------------------------------------ Theme Exports -------------------------------------- // export { // ThemeVariant, // ThemeColor, // ThemeColors // } from './components/theme/theme.types'; // export { // baseThemeColors, // unitedThemeColors // } from './components/theme/theme.colors';
