+-- src
|   +-- components
|   |   +-- ixt-diagram
|   |   |   +-- ixt-diagram.component.html: 
|   |   |   +-- ixt-diagram.component.scss: 
|   |   |   +-- ixt-diagram.component.ts: // ixt-diagram.component.ts import { Component, ElementRef, OnInit, ViewChild } from '@angular/core';  interface Participant {   type: 'actor' | 'component';   name: string;   x: number; }  interface Message {   from: string;   to: string;   text: string;   y: number;   type: 'sync' | 'return' | 'self'; }  interface Activation {   participant: string;   startY: number;   endY: number; }  @Component({   selector: 'ixt-diagram',   template: `     <canvas #diagramCanvas              width="800"              height="600"             [style.border]="'1px solid #ccc'">     </canvas>   ` }) export class IxtDiagramComponent implements OnInit {   @ViewChild('diagramCanvas', { static: true })   private canvas!: ElementRef<HTMLCanvasElement>;   private ctx!: CanvasRenderingContext2D;    // Sample data matching the example diagram   private participants: Participant[] = [     { type: 'actor', name: 'SD Login Customer', x: 100 },     { type: 'component', name: 'LoginUI', x: 300 },     { type: 'component', name: 'LoginControl', x: 500 },     { type: 'component', name: 'UserDB', x: 700 }   ];      // Update the activation data to match the screenshot   private activations: Activation[] = [     { participant: 'LoginUI', startY: 150, endY: 420 },     { participant: 'LoginControl', startY: 200, endY: 420 },     { participant: 'UserDB', startY: 250, endY: 320 }  // Adjusted timing   ];    // Update message types to ensure sync messages have filled arrowheads   private messages: Message[] = [     { from: 'SD Login Customer', to: 'LoginUI', text: 'Login(Un/Pw)', y: 150, type: 'sync' },     { from: 'LoginUI', to: 'LoginControl', text: 'login(Un/Pw)', y: 200, type: 'sync' },     { from: 'LoginControl', to: 'UserDB', text: 'search(Un/Pw)', y: 250, type: 'sync' },     { from: 'UserDB', to: 'LoginControl', text: 'status', y: 300, type: 'return' },     { from: 'LoginControl', to: 'LoginControl', text: 'validateUser', y: 350, type: 'self' },     { from: 'LoginControl', to: 'LoginUI', text: 'status', y: 400, type: 'return' }   ];      ngOnInit() {     this.initializeCanvas();     this.drawDiagram();   }    private initializeCanvas() {     const context = this.canvas.nativeElement.getContext('2d');     if (!context) {       throw new Error('Canvas 2D context not supported');     }     this.ctx = context;     this.ctx.font = '12px Arial';     this.ctx.textAlign = 'center';   }    private drawDiagram() {     this.clearCanvas();     this.drawParticipants();     this.drawLifelines();     this.drawActivations();     this.drawMessages();   }    private clearCanvas() {     const canvas = this.canvas.nativeElement;     this.ctx.clearRect(0, 0, canvas.width, canvas.height);   }    private drawParticipants() {     this.participants.forEach(participant => {       if (participant.type === 'actor') {         this.drawActor(participant);       } else {         this.drawComponent(participant);       }     });   }    private drawActor(participant: Participant) {     const x = participant.x;     const y = 30;     this.ctx.strokeStyle = '#000';      // Draw stick figure     // Head     this.ctx.beginPath();     this.ctx.arc(x, y, 10, 0, Math.PI * 2);     this.ctx.stroke();      // Body     this.ctx.beginPath();     this.ctx.moveTo(x, y + 10);     this.ctx.lineTo(x, y + 30);     this.ctx.stroke();      // Arms     this.ctx.beginPath();     this.ctx.moveTo(x - 15, y + 20);     this.ctx.lineTo(x + 15, y + 20);     this.ctx.stroke();      // Legs     this.ctx.beginPath();     this.ctx.moveTo(x, y + 30);     this.ctx.lineTo(x - 10, y + 45);     this.ctx.moveTo(x, y + 30);     this.ctx.lineTo(x + 10, y + 45);     this.ctx.stroke();      // Label     this.ctx.fillStyle = '#000';     this.drawLabel(participant.name, x, y + 60);   }    private drawComponent(participant: Participant) {     const width = 100;     const height = 40;     const x = participant.x - width / 2;     const y = 30;      // Draw box     this.ctx.strokeStyle = '#000';     this.ctx.fillStyle = '#fff';     this.ctx.beginPath();     this.ctx.rect(x, y, width, height);     this.ctx.fill();     this.ctx.stroke();      // Draw text     this.ctx.fillStyle = '#000';     this.drawLabel(participant.name, participant.x, y + height / 2);   }    private drawLifelines() {     this.ctx.setLineDash([5, 5]);     this.ctx.strokeStyle = '#666';      this.participants.forEach(participant => {       this.ctx.beginPath();       this.ctx.moveTo(participant.x, 90);       this.ctx.lineTo(participant.x, 500);       this.ctx.stroke();     });      this.ctx.setLineDash([]); // Reset line style   }     private drawMessages() {     this.messages.forEach(message => {       const fromX = this.getParticipantX(message.from);       const toX = this.getParticipantX(message.to);        this.ctx.strokeStyle = '#000';       this.ctx.fillStyle = '#000';        if (message.type === 'sync') {         this.drawSyncMessage(fromX, toX, message);       } else if (message.type === 'return') {         this.drawReturnMessage(fromX, toX, message);       } else if (message.type === 'self') {         this.drawSelfMessage(fromX, message);       }     });   }     private drawReturnMessage(fromX: number, toX: number, message: Message) {     // Dashed line with open arrow     this.ctx.setLineDash([5, 5]);     this.ctx.beginPath();     this.ctx.moveTo(fromX, message.y);     this.ctx.lineTo(toX, message.y);     this.ctx.stroke();     this.ctx.setLineDash([]);      // Open arrowhead     this.drawArrowhead(toX, message.y, fromX < toX ? 'right' : 'left', false);      // Message text     this.drawLabel(message.text, (fromX + toX) / 2, message.y - 10);   }    private drawSelfMessage(x: number, message: Message) {     const offset = 20;     this.ctx.beginPath();     this.ctx.moveTo(x, message.y);     this.ctx.lineTo(x + offset, message.y);     this.ctx.lineTo(x + offset, message.y + 20);     this.ctx.lineTo(x, message.y + 20);     this.ctx.stroke();      // Filled arrowhead     this.drawArrowhead(x, message.y + 20, 'left', true);      // Message text     this.drawLabel(message.text, x + offset + 20, message.y + 10);   }     private drawLabel(text: string, x: number, y: number) {     this.ctx.fillStyle = '#000';     this.ctx.textAlign = 'center';     this.ctx.textBaseline = 'middle';     this.ctx.fillText(text, x, y);   }    private getParticipantX(name: string): number {     const participant = this.participants.find(p => p.name === name);     if (!participant) {       throw new Error(`Participant ${name} not found`);     }     return participant.x;   }           // Only showing the modified methods - the rest of the component remains the same    private drawActivations() {     this.ctx.fillStyle = '#fff';     this.ctx.strokeStyle = '#000';      this.activations.forEach(activation => {       const participant = this.participants.find(p => p.name === activation.participant);       if (participant) {         // Make activation bars wider and ensure they're solid         const width = 16;  // Increased from 10         const x = participant.x - width / 2;          // Draw solid white rectangle         this.ctx.beginPath();         this.ctx.fillStyle = '#fff';         this.ctx.fillRect(x, activation.startY, width, activation.endY - activation.startY);         this.ctx.strokeRect(x, activation.startY, width, activation.endY - activation.startY);       }     });   }    private drawArrowhead(x: number, y: number, direction: 'left' | 'right', filled: boolean) {     const size = 10;  // Increased from 8     const angle = Math.PI / 6;     const dir = direction === 'right' ? 1 : -1;      this.ctx.beginPath();     this.ctx.moveTo(x, y);      // Calculate arrow points     const x1 = x - dir * size * Math.cos(angle);     const y1 = y - size * Math.sin(angle);     const x2 = x - dir * size * Math.cos(-angle);     const y2 = y - size * Math.sin(-angle);      this.ctx.lineTo(x1, y1);     this.ctx.lineTo(x2, y2);      if (filled) {       this.ctx.closePath();       this.ctx.fillStyle = '#000';       this.ctx.fill();     }     this.ctx.stroke();   }    private drawSyncMessage(fromX: number, toX: number, message: Message) {     // Draw solid line     this.ctx.beginPath();     this.ctx.strokeStyle = '#000';     this.ctx.lineWidth = 1;     this.ctx.moveTo(fromX, message.y);     this.ctx.lineTo(toX, message.y);     this.ctx.stroke();      // Always draw filled arrowhead for sync messages     this.drawArrowhead(toX, message.y, fromX < toX ? 'right' : 'left', true);      // Message text     this.drawLabel(message.text, (fromX + toX) / 2, message.y - 10);   }  }
|   |   |   +-- ixt-diagram.index.ts: // ixt-diagram.index.ts export * from './ixt-diagram.component'; export * from './ixt-diagram.module';  
|   |   |   +-- ixt-diagram.module.ts: // Later we can add additional exports like: // export * from './ixt-diagram.service'; // export * from './ixt-diagram.models'; // export * from './ixt-diagram.utils';  // ixt-diagram.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtDiagramComponent } from './ixt-diagram.component';  @NgModule({   declarations: [     IxtDiagramComponent   ],   imports: [     CommonModule   ],   exports: [     IxtDiagramComponent   ] }) export class IxtDiagramModule { }  /* Future imports we might need: import { FormsModule } from '@angular/forms'; import { IxtDiagramService } from './ixt-diagram.service'; import { IxtDiagramToolbarComponent } from './components/toolbar/toolbar.component'; */
|   |   |   -- types
|   |   |      +-- EBNF
|   |   |      +-- ERD
|   |   |      |   +-- ixt-erd.diagram.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      |   +-- ixt-erd.diagram.scss: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      |   -- ixt-erd.diagram.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      +-- clazz
|   |   |      |   +-- ixt-clazz.diagram.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      |   +-- ixt-clazz.diagram.scss: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      |   -- ixt-clazz.diagram.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      +-- deployment
|   |   |      |   +-- ixt-deployment.diagram.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      |   +-- ixt-deployment.diagram.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      |   -- ixt-deployment.diagrams.css
|   |   |      +-- flow
|   |   |      |   +-- ixt-flow.diagram.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      |   +-- ixt-flow.diagram.scss: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      |   -- ixt-flow.diagram.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      +-- gannt
|   |   |      |   +-- gannt.diagram.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      |   +-- gannt.diagram.scss: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      |   +-- gannt.diagram.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      |   +-- gannt.index.ts: 
|   |   |      |   -- gannt.module.ts: 
|   |   |      +-- network
|   |   |      |   +-- ixt-network.diagram.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      |   +-- ixt-network.diagram.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |      |   -- ixt-network.diagrams.css
|   |   |      +-- sequence
|   |   |      |   +-- model.ts: // src/app/sequence-diagram/models.ts export interface Participant {     type: 'actor' | 'component';     name: string;     x?: number; }  export interface Message {     from: string;     to: string;     text: string;     type: 'sync' | 'return';     y?: number; }  export interface DiagramData {     participants: Participant[];     messages: Message[]; }  
|   |   |      |   +-- parser.service.ts:   // src/app/sequence-diagram/parser.service.ts   import { Injectable } from '@angular/core'; import { DiagramData, Participant, Message } from './model';      @Injectable({     providedIn: 'root'   })   export class DiagramParserService {     parse(input: string): DiagramData {       const lines = input.trim().split('\n').map(line => line.trim());       const participants: Participant[] = [];       const messages: Message[] = [];          lines.forEach(line => {         if (line.startsWith('actor')) {           const name = line.replace('actor', '').trim();           participants.push({ type: 'actor', name });         }         else if (line.startsWith('participant')) {           const name = line.replace('participant', '').trim();           participants.push({ type: 'component', name });         }         else if (line.includes('->')) {           const parts = line.split('->');           if (parts.length === 2) {             const [from, rest] = parts;             const [to, text] = rest.split(':').map(s => s.trim());             messages.push({               from: from.trim(),               to: to.trim(),               text: text || '',               type: 'sync'             });           }         }         else if (line.includes('-->')) {           const parts = line.split('-->');           if (parts.length === 2) {             const [from, rest] = parts;             const [to, text] = rest.split(':').map(s => s.trim());             messages.push({               from: from.trim(),               to: to.trim(),               text: text || '',               type: 'return'             });           }         }       });          return { participants, messages };     }   }
|   |   |      |   +-- sequence-diagram.component.ts:       // src/app/sequence-diagram/sequence-diagram.component.ts   import { Component, ElementRef, Input, ViewChild, OnInit } from '@angular/core';   import { DiagramParserService } from './parser.service'; import { DiagramData, Participant } from './model';      @Component({     selector: 'app-sequence-diagram',     template: `       <canvas #canvas                [width]="800"                [height]="600"               style="border: 1px solid #ccc;">       </canvas>     `   })   export class SequenceDiagramComponent implements OnInit {     @ViewChild('canvas', { static: true })     private canvas!: ElementRef<HTMLCanvasElement>;     private ctx!: CanvasRenderingContext2D;     private data!: DiagramData;        @Input() set diagram(value: string) {       this.data = this.parser.parse(value);       this.calculatePositions();       this.render();     }        constructor(private parser: DiagramParserService) {}        ngOnInit() {       const context = this.canvas.nativeElement.getContext('2d');       if (!context) {         throw new Error('Canvas 2D context not supported');       }       this.ctx = context;     }        private calculatePositions() {       const spacing = 150;       this.data.participants.forEach((p, index) => {         p.x = 100 + (index * spacing);       });          let currentY = 100;       this.data.messages.forEach(msg => {         msg.y = currentY;         currentY += 50;       });     }        private render() {       this.clear();       this.drawParticipants();       this.drawLifelines();       this.drawMessages();     }        private clear() {       const canvas = this.canvas.nativeElement;       this.ctx.clearRect(0, 0, canvas.width, canvas.height);     }        private drawParticipants() {       this.ctx.font = '12px Arial';       this.ctx.textAlign = 'center';              this.data.participants.forEach(p => {         if (p.x === undefined) return;            if (p.type === 'actor') {           this.drawActor(p);         } else {           this.drawComponent(p);         }       });     }        private drawActor(p: Participant) {       if (p.x === undefined) return;       const x = p.x;       const y = 30;          // Head       this.ctx.beginPath();       this.ctx.arc(x, y, 10, 0, Math.PI * 2);       this.ctx.stroke();          // Body       this.ctx.beginPath();       this.ctx.moveTo(x, y + 10);       this.ctx.lineTo(x, y + 30);       this.ctx.moveTo(x - 15, y + 20);       this.ctx.lineTo(x + 15, y + 20);       this.ctx.moveTo(x, y + 30);       this.ctx.lineTo(x - 10, y + 45);       this.ctx.moveTo(x, y + 30);       this.ctx.lineTo(x + 10, y + 45);       this.ctx.stroke();          // Label       this.ctx.fillText(p.name, x, y + 60);     }        private drawComponent(p: Participant) {       if (p.x === undefined) return;       const width = 100;       const height = 40;       const x = p.x - width / 2;       const y = 30;          this.ctx.strokeRect(x, y, width, height);       this.ctx.fillText(p.name, p.x, y + height / 2);     }        private drawLifelines() {       this.ctx.setLineDash([5, 5]);       this.data.participants.forEach(p => {         if (p.x === undefined) return;         this.ctx.beginPath();         this.ctx.moveTo(p.x, 90);         this.ctx.lineTo(p.x, 500);         this.ctx.stroke();       });       this.ctx.setLineDash([]);     }        private drawMessages() {       this.data.messages.forEach(msg => {         const fromX = this.getParticipantX(msg.from);         const toX = this.getParticipantX(msg.to);         if (fromX === undefined || toX === undefined || msg.y === undefined) return;            // Arrow line         this.ctx.beginPath();         if (msg.type === 'return') {           this.ctx.setLineDash([5, 5]);         } else {           this.ctx.setLineDash([]);         }         this.ctx.moveTo(fromX, msg.y);         this.ctx.lineTo(toX, msg.y);         this.ctx.stroke();            // Arrow head         const arrowSize = 10;         const direction = fromX < toX ? 1 : -1;         this.ctx.beginPath();         this.ctx.moveTo(toX, msg.y);         this.ctx.lineTo(toX - direction * arrowSize, msg.y - arrowSize/2);         this.ctx.lineTo(toX - direction * arrowSize, msg.y + arrowSize/2);         this.ctx.closePath();         if (msg.type === 'sync') {           this.ctx.fill();         } else {           this.ctx.stroke();         }            // Message text         this.ctx.fillText(msg.text, (fromX + toX)/2, msg.y - 10);       });     }        private getParticipantX(name: string): number | undefined {       return this.data.participants.find(p => p.name === name)?.x;     }   }    
|   |   |      |   -- sequence-diagram.module.ts:   // src/app/sequence-diagram/sequence-diagram.module.ts   import { NgModule } from '@angular/core';   import { CommonModule } from '@angular/common';   import { SequenceDiagramComponent } from './sequence-diagram.component';   import { DiagramParserService } from './parser.service';      @NgModule({     declarations: [SequenceDiagramComponent],     imports: [CommonModule],     exports: [SequenceDiagramComponent],     providers: [DiagramParserService]   })   export class SequenceDiagramModule { }
|   |   |      -- wireframe
|   |   |         +-- ixt-wireframe.diagram.html: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |         +-- ixt-wireframe.diagram.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = `     <div role="progressbar">         <p>{{message}}</p>         <progress [value]="current" [max]="total"></progress>     </div> `; 
|   |   |         -- ixt-wireframe.diagrams.css
+-- test
|   +-- parser.test.js
|   -- parser.test.ts: import { DiagramParserService } from "src/components/ixt-diagram/types/sequence/parser.service";   // Simple test runner function runTests() {     let passCount = 0;     let failCount = 0;          function assert(condition: boolean, message: string) {         if (condition) {             console.log(`✓ ${message}`);             passCount++;         } else {             console.log(`✗ ${message}`);             failCount++;         }     }      function assertEqual(actual: any, expected: any, message: string) {         const pass = JSON.stringify(actual) === JSON.stringify(expected);         assert(pass, message);         if (!pass) {             console.log('  Expected:', expected);             console.log('  Got:', actual);         }     }      const parser = new DiagramParserService();      // Test 1: Basic actor parsing     {         const input = `             actor User             actor Customer         `;         const result = parser.parse(input);         assertEqual(             result.participants,             [                 { type: 'actor', name: 'User' },                 { type: 'actor', name: 'Customer' }             ],             'Should parse multiple actors'         );     }      // Test 2: Basic participant parsing     {         const input = `             participant LoginUI             participant UserDB         `;         const result = parser.parse(input);         assertEqual(             result.participants,             [                 { type: 'component', name: 'LoginUI' },                 { type: 'component', name: 'UserDB' }             ],             'Should parse multiple participants'         );     }      // Test 3: Sync message parsing     {         const input = `             actor User             participant LoginUI             User -> LoginUI: Login         `;         const result = parser.parse(input);         assertEqual(             result.messages,             [{                 from: 'User',                 to: 'LoginUI',                 text: 'Login',                 type: 'sync'             }],             'Should parse sync message'         );     }      // Test 4: Return message parsing     {         const input = `             participant LoginUI             participant UserDB             UserDB --> LoginUI: status         `;         const result = parser.parse(input);         assertEqual(             result.messages,             [{                 from: 'UserDB',                 to: 'LoginUI',                 text: 'status',                 type: 'return'             }],             'Should parse return message'         );     }      // Test 5: Complete sequence     {         const input = `             actor User             participant LoginUI             participant LoginControl                          User -> LoginUI: Login(Un/Pw)             LoginUI -> LoginControl: verify             LoginControl --> LoginUI: status         `;         const result = parser.parse(input);         assert(             result.participants.length === 3 &&              result.messages.length === 3,             'Should parse complete sequence'         );     }      // Test 6: Empty input     {         const input = '';         const result = parser.parse(input);         assertEqual(             result,             { participants: [], messages: [] },             'Should handle empty input'         );     }      // Test 7: Invalid input     {         const input = 'invalid syntax here';         const result = parser.parse(input);         assertEqual(             result,             { participants: [], messages: [] },             'Should handle invalid input gracefully'         );     }      // Print summary     console.log('\nTest Summary:');     console.log(`Passed: ${passCount}`);     console.log(`Failed: ${failCount}`);          // Exit with appropriate code     process.exit(failCount > 0 ? 1 : 0); }  // Run the tests runTests();
