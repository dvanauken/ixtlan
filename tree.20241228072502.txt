\-- src
    +-- app
    |   --- app.component.html: <main> <nav> <ixt-tabset title="Employee Form"> <ixt-tab title="Tab 1"> <ixt-tree [nodes]="treeProvider.treeData" (nodeExpanded)="treeHandler.onNodeExpanded($event)" (nodeCollapsed)="treeHandler.onNodeCollapsed($event)" (nodeSelected)="treeHandler.onNodeSelected($event)"> </ixt-tree> </ixt-tab> <ixt-tab title="Tab 2"> <ixt-accordian [panels]="accordionPanels" [allowMultiple]="true"> </ixt-accordian> </ixt-tab> </ixt-tabset> </nav> <header> <ixt-menu src="./../assets/menu.json" brandName="Your Brand" brandLogo="./../assets/logo.png" brandLink="/" variant="default" [showSearch]="true" searchPlaceholder="Search products..." (searchSubmitted)="onSearch($event)"> </ixt-menu> </header> <section> <ixt-tabset> <ixt-tab title="diagrams"> <ixt-tabset> <ixt-tab title="Clazz"> <ixt-clazz></ixt-clazz> </ixt-tab> <ixt-tab title="Sequence"> <ixt-diagram></ixt-diagram> </ixt-tab> <ixt-tab title="viewport"> <ixt-viewport></ixt-viewport> </ixt-tab> <ixt-tab title="cavas"> <ixt-canvas></ixt-canvas> </ixt-tab> <ixt-tab title="EBNF"> <ixt-ebnf></ixt-ebnf> </ixt-tab> <ixt-tab title="ERD"> <ixt-erd></ixt-erd> </ixt-tab> <ixt-tab title="Network"> <ixt-network></ixt-network> </ixt-tab> <ixt-tab title="Flow"> <ixt-flow></ixt-flow> </ixt-tab> <ixt-tab title="Gannt"> <gannt-diagram></gannt-diagram> </ixt-tab> <ixt-tab title="Sankey"> <ixt-sankey></ixt-sankey> </ixt-tab> <ixt-tab title="Wireframe"> <ixt-wireframe></ixt-wireframe> </ixt-tab> </ixt-tabset> </ixt-tab> <ixt-tab title="D3 Geo"> <ixt-map [width]="'100%'" [height]="'80%'" scale="1" translate="0,0"> <ixt-layer src="./../assets/countries.geojson" stroke="black" fill="gray"></ixt-layer> <ixt-layer src="./../assets/flights.minified.geojson" stroke="red" fill="none" (click)="select($event)"> properties.airlineIata === 'F9' </ixt-layer> <ixt-layer src="./../assets/flights.minified.geojson" stroke="green" fill="none" (click)="select($event)"> properties.airlineIata === 'NK' </ixt-layer> <ixt-layer src="./../assets/lakes.geojson" stroke="black" fill="blue" (click)="select($event)"></ixt-layer> <ixt-layer src="./../assets/rivers.geojson" stroke="purple" fill="none" (hover)="highlight($event)"></ixt-layer> </ixt-map> </ixt-tab> <ixt-tab title="Buttons"> <div class="button-showcase"> <!-- Size Variants --> <div class="section"> <h4>Size Variants</h4> <div class="button-row"> <ixt-button variant="primary" size="sm">Small</ixt-button> <ixt-button variant="primary" size="md">Medium</ixt-button> <ixt-button variant="primary" size="lg">Large</ixt-button> </div> </div> <!-- Theme Variants --> <div class="section"> <h4>Theme Variants</h4> <div class="button-row"> <div class="theme"> <h5>Base Theme</h5> <div class="button-row"> <ixt-button variant="primary">Primary</ixt-button> <ixt-button variant="secondary">Secondary</ixt-button> <ixt-button variant="danger">Danger</ixt-button> </div> </div> <div class="theme"> <h5>United Theme</h5> <div class="button-row"> <ixt-button variant="primary" [theme]="unitedThemeColors">Primary</ixt-button> <ixt-button variant="secondary" [theme]="unitedThemeColors">Secondary</ixt-button> <ixt-button variant="danger" [theme]="unitedThemeColors">Danger</ixt-button> </div> </div> </div> </div> <!-- Examples --> <div class="section"> <h4>Examples</h4> <div class="button-row"> <ixt-button *ngFor="let button of buttonDemos" [variant]="button.variant" [size]="button.size || 'md'" [theme]="button.theme || baseThemeColors" [disabled]="button.disabled" (onClick)="handleButtonClick(button.label)"> <span *ngIf="button.prefix" prefix>{{button.prefix}}</span> {{button.label}} <span *ngIf="button.suffix" suffix>{{button.suffix}}</span> </ixt-button> </div> </div> </div> </ixt-tab> <!-- Dialog Example --> <ixt-tab title="Dialog Example"> <div class="dialog-demo-container flex flex-col gap-4 p-4"> <!-- Service-based dialogs --> <div class="flex flex-col gap-2"> <h3 class="text-lg font-semibold">Service-based Dialogs</h3> <div class="flex flex-wrap gap-2"> <button (click)="showSuccessDialog()" class="px-4 py-2 bg-green-500 text-white rounded"> Success Dialog </button> </div> </div> </div> </ixt-tab> <ixt-tab title="Employee Form"> <form class="form-grid"> <h3>Personal Information</h3> <div class="field"> <label>First Name</label> <input type="text" [(ngModel)]="formData.firstName" name="firstName"> </div> <div class="field"> <label>Last Name</label> <input type="text" [(ngModel)]="formData.lastName" name="lastName"> </div> <div class="field"> <label>Email</label> <input type="email" [(ngModel)]="formData.email" name="email"> </div> <h3>Employment Details</h3> <div class="field"> <label>Department</label> <input type="text" [(ngModel)]="formData.department" name="department"> </div> <div class="field"> <label>Position</label> <input type="text" [(ngModel)]="formData.position" name="position"> </div> <div class="field"> <label>Start Date</label> <input type="date" [(ngModel)]="formData.hireDate" name="hireDate"> </div> <div class="actions"> <button type="button" (click)="employeeFormHandler.submitForm()">Save</button> <button type="button" (click)="employeeFormHandler.resetForm()">Cancel</button> </div> </form> </ixt-tab> <ixt-tab title="Calendar"> <ixt-calendar></ixt-calendar> </ixt-tab> <ixt-tab title="Standard Table"> <ixt-table [data]="tableAirportData" [columnConfigs]="tableColumnConfigs" *ngIf="tableAirportData.length"> </ixt-table> </ixt-tab> <ixt-tab title="IxtSplitPane"> <ixt-split-pane> <div class="left-pane"> <h2>Left</h2> </div> <div class="right-pane"> <h2>Right</h2> </div> </ixt-split-pane> </ixt-tab> <ixt-tab title="Panels"> <h2>Examples</h2> <div class="ixt-panel-container"> <div class="panel-grid"> <ixt-panel title="Basic Panel"> <div class="panel-content"> This is a basic panel with default settings (bordered=true, elevated=false) </div> </ixt-panel> <ixt-panel title="Elevated Panel" [elevated]="true" caption="With caption text"> <div class="panel-content"> This panel has elevation enabled, creating a shadow effect </div> </ixt-panel> <ixt-panel title="No Border Panel" [bordered]="false" [padding]="true"> <div class="panel-content"> This panel has borders disabled but keeps padding </div> </ixt-panel> <ixt-panel [bordered]="false" [padding]="false" [elevated]="false"> <div class="panel-content"> A minimal panel without title, borders, elevation or padding </div> </ixt-panel> </div> </div> </ixt-tab> </ixt-tabset> </section> <aside> <ixt-layer-manager [layers]="layerProvider.mapLayers" (layerChange)="layerManager.onLayerChange($event)" (layerOrderChange)="layerManager.onLayerOrderChange($event)"> </ixt-layer-manager> </aside> <footer>Footer</footer> </main> <app-lunch-form></app-lunch-form>
    |   --- app.component.ts: import { Component, ViewChild, AfterViewInit } from '@angular/core'; import { IxtLayerProvider } from './layer/ixt-layer.provider'; import { IxtLayerManager } from './layer/ixt-layer.manager'; import { IxtTreeProvider } from './tree/ixt-tree.provider'; import { IxtTreeHandler } from './tree/ixt-tree.handler'; import { IxtExpressionProvider } from './expression/ixt-expression.provider'; import { IxtExpressionHelper } from './expression/ixt-expression.helper'; import { IxtEmployeeFormProvider } from './form/ixt-employee-form.provider'; import { IxtEmployeeFormHandler } from './form/ixt-employee-form.handler'; import { IxtTableProvider } from './table/ixt-table.provider'; import { IxtMenuProvider } from './menu/ixt-menu.provider'; import { AccordianDataService } from './accordion/accordion.data'; import { IxtDialogService } from 'src/components/ixt-dialog/ixt-dialog.service'; import { firstValueFrom } from 'rxjs'; import { NgForm } from '@angular/forms'; import { LunchFormComponent } from './lunch-form.component'; import { ThemeVariant, ThemeColors } from 'src/components/theme/theme.types'; import { baseThemeColors, unitedThemeColors } from 'src/components/theme/theme.colors'; // Add to existing AppComponent class export interface ButtonDemo { label: string; variant: ThemeVariant; size?: 'sm' | 'md' | 'lg'; theme?: ThemeColors; disabled: boolean; prefix?: string; suffix?: string; } @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'], providers: [ IxtLayerProvider, IxtLayerManager, IxtTreeProvider, IxtTreeHandler, IxtExpressionProvider, IxtExpressionHelper, IxtEmployeeFormProvider, IxtEmployeeFormHandler, IxtTableProvider, IxtMenuProvider ] }) export class AppComponent implements AfterViewInit { @ViewChild(LunchFormComponent, { static: true }) lunchForm!: LunchFormComponent; protected baseThemeColors = baseThemeColors; protected unitedThemeColors = unitedThemeColors; formData = this.employeeFormProvider.getCurrentForm(); tableAirportData: any[] = []; tableColumnConfigs = this.tableProvider.getAirportColumnConfigs(); accordionPanels = this.accordianDataService.getAccordianPanels(); constructor( private dialog: IxtDialogService, public layerProvider: IxtLayerProvider, public layerManager: IxtLayerManager, public treeProvider: IxtTreeProvider, public treeHandler: IxtTreeHandler, public expressionProvider: IxtExpressionProvider, public expressionHelper: IxtExpressionHelper, public employeeFormProvider: IxtEmployeeFormProvider, public employeeFormHandler: IxtEmployeeFormHandler, public tableProvider: IxtTableProvider, public menuProvider: IxtMenuProvider, private accordianDataService: AccordianDataService ) { } ngOnInit() { this.tableProvider.getAirportData().subscribe(data => { this.tableAirportData = data; }); } ngAfterViewInit() { } select(event: Event): void { console.log('Selected:', event); } highlight(event: Event): void { console.log('Highlighted:', event); } onSearch(searchTerm: string) { console.log('Search term:', searchTerm); } // Dialog examples using improved service ------------------------------------------------------ async showSuccessDialog() { console.log('Starting dialog test'); await this.dialog.success('Success123!', 'Success Dialog 456'); console.log('Dialog completed'); } buttonDemos: ButtonDemo[] = [ { label: 'Submit Form', variant: 'primary', size: 'lg', suffix: '→', disabled: false }, { label: 'Cancel', variant: 'secondary', size: 'lg', disabled: false }, { label: 'Delete Record', variant: 'danger', prefix: '⚠️', disabled: false }, { label: 'United Theme', variant: 'primary', theme: unitedThemeColors, size: 'lg', disabled: false }, { label: 'Processing...', variant: 'primary', disabled: true }, { label: 'View Details', variant: 'info', size: 'sm', disabled: false } ]; handleButtonClick(label: string) { console.log(`Button clicked: ${label}`); } }
    |   --- app.module.ts: import { NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { HttpClientModule } from '@angular/common/http'; import { RouterModule } from '@angular/router'; // Import components individually since library isn't published yet import { IxtButtonModule } from 'src/components/ixt-button/ixt-button.module'; import { IxtDialogModule } from 'src/components/ixt-dialog/ixt-dialog.module'; import { IxtTableModule } from 'src/components/ixt-table/ixt-table.module'; import { IxtTabsetModule } from 'src/components/ixt-tabset/ixt-tabset.module'; // Fixed name import { IxtTabComponent } from 'src/components/ixt-tabset/ixt-tab.component'; // Added individual component import { IxtPanelModule } from 'src/components/ixt-panel/ixt-panel.module'; import { IxtMenuModule } from 'src/components/ixt-menu/ixt-menu.module'; import { IxtTreeModule } from 'src/components/ixt-tree/ixt-tree.module'; import { IxtAccordianModule } from 'src/components/ixt-accordian/ixt-accordian.module'; // Fixed path import { IxtCanvasModule } from 'src/components/ixt-canvas/ixt-canvas.module'; import { IxtViewportModule } from 'src/components/ixt-viewport/ixt-viewport.module'; import { IxtExpressionBuilderModule } from 'src/components/ixt-expression-builder/ixt-expression-builder.module'; import { IxtMapModule } from 'src/components/ixt-map/ixt-map.module'; import { IxtLayerModule } from 'src/components/ixt-map/ixt-layer.module'; import { IxtLayerManagerModule } from 'src/components/ixt-layer-manager/ixt-layer-manager.module'; import { IxtSplitPaneModule } from 'src/components/ixt-splitpane/ixt-split-pane.module'; import { IxtCalendarModule } from 'src/components/ixt-calendar/ixt-calendar.module'; // Diagram Modules import { IxtDiagramModule } from 'src/components/ixt-diagram/ixt-diagram.module'; import { IxtClazzModule } from 'src/components/ixt-diagram/types/clazz/ixt-clazz.module'; import { IxtDeploymentModule } from 'src/components/ixt-diagram/types/deployment/ixt-deployment.module'; import { IxtEbnfModule } from 'src/components/ixt-diagram/types/EBNF/ixt-ebnf.module'; // Fixed path import { IxtFlowModule } from 'src/components/ixt-diagram/types/flow/ixt-flow.module'; import { IxtGanntModule } from 'src/components/ixt-diagram/types/gannt/gannt.module'; import { IxtNetworkModule } from 'src/components/ixt-diagram/types/network/ixt-network.module'; import { IxtSankeyModule } from 'src/components/ixt-diagram/types/sankey/ixt-sankey.module'; import { IxtWireframeModule } from 'src/components/ixt-diagram/types/wireframe/ixt-wireframe.module'; // Components import { AppComponent } from './app.component'; import { LunchFormComponent } from './lunch-form.component'; // Providers import { IxtEmployeeFormHandler } from './form/ixt-employee-form.handler'; import { IxtEmployeeFormProvider } from './form/ixt-employee-form.provider'; import { IxtExpressionHelper } from './expression/ixt-expression.helper'; import { IxtExpressionProvider } from './expression/ixt-expression.provider'; import { IxtLayerManager } from './layer/ixt-layer.manager'; import { IxtLayerProvider } from './layer/ixt-layer.provider'; import { IxtTreeHandler } from './tree/ixt-tree.handler'; import { IxtTableProvider } from './table/ixt-table.provider'; import { IxtTreeProvider } from './tree/ixt-tree.provider'; @NgModule({ declarations: [ AppComponent, LunchFormComponent ], imports: [ // Angular Core Modules BrowserModule, BrowserAnimationsModule, FormsModule, ReactiveFormsModule, HttpClientModule, RouterModule.forRoot([]), // Ixtlan Modules IxtAccordianModule, IxtButtonModule, IxtCalendarModule, IxtCanvasModule, IxtDialogModule, IxtDiagramModule, IxtExpressionBuilderModule, IxtLayerModule, // Added Layer module IxtLayerManagerModule, IxtMapModule, IxtMenuModule, IxtPanelModule, IxtSplitPaneModule, IxtTableModule, IxtTreeModule, IxtTabsetModule, IxtViewportModule, // Diagram Type Modules IxtClazzModule, IxtDeploymentModule, IxtEbnfModule, IxtFlowModule, IxtGanntModule, IxtNetworkModule, IxtSankeyModule, IxtWireframeModule ], providers: [ IxtEmployeeFormHandler, IxtEmployeeFormProvider, IxtExpressionHelper, IxtExpressionProvider, IxtLayerManager, IxtLayerProvider, IxtTreeHandler, IxtTreeProvider, IxtTableProvider ], schemas: [ CUSTOM_ELEMENTS_SCHEMA // Added schema for custom elements ], bootstrap: [AppComponent] }) export class AppModule { }
    +-- assets
    |   --- .gitkeep: <empty file>
    |   --- logo.png: <image file>
    |   --- logo2.png: <image file>
    +-- components
    |   +-- ixt-table
    |   |   +-- editors
    |   |   |   +-- airport-code
    |   |   |   |   --- airport-code-editor.component.ts: import { Component, Input, forwardRef, OnInit, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { IxtDialogService } from '../../../ixt-dialog/ixt-dialog.service'; import { MatrixEditor, MatrixEditorConfig } from '../editor.interface'; @Component({ selector: 'airport-code-editor', template: ` <div class="editor-container"> <input type="text" [formControl]="inputControl" class="w-24 px-2 py-1 border rounded" [class.border-red-500]="hasError" [attr.maxlength]="config?.['maxLength'] || 3" (blur)="onTouched()" /> <div *ngIf="hasError" class="text-red-500 text-sm mt-1"> {{ errorMessage }} </div> </div> `, styles: [` .editor-container { position: relative; } `], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AirportCodeEditorComponent), multi: true } ] }) export class AirportCodeEditorComponent implements ControlValueAccessor, OnInit, MatrixEditor { @Input() config?: MatrixEditorConfig; @Input() existingCodes: string[] = []; @Input() field: string = 'code'; inputControl = new FormControl(''); hasError = false; errorMessage = ''; // MatrixEditor implementation component: Type<any> = AirportCodeEditorComponent; // ControlValueAccessor implementations public onChanged: (value: string) => void = () => {}; public onTouched: () => void = () => {}; constructor(private dialogService: IxtDialogService) {} ngOnInit() { this.setupValueChanges(); } // MatrixEditor methods getEditConfig(): MatrixEditorConfig { return { existingValues: this.existingCodes, maxLength: 3, pattern: /^[A-Z]+$/ }; } getDefaultValue(): string { return ''; } validate(value: any): boolean { if (!value) return false; const code = String(value).toUpperCase(); if (code.length !== 3) return false; if (!/^[A-Z]+$/.test(code)) return false; if (this.existingCodes.includes(code)) return false; return true; } format(value: any): string { return value ? String(value).toUpperCase() : ''; } private async setupValueChanges() { this.inputControl.valueChanges.subscribe(async value => { if (value !== null) { const upperValue = value.toUpperCase(); if (upperValue !== value) { this.inputControl.setValue(upperValue, { emitEvent: false }); } if (await this.validateValue(upperValue)) { console.log('Editor emitting code change:', upperValue); this.onChanged(upperValue); } } }); } private async validateValue(value: string): Promise<boolean> { this.hasError = false; this.errorMessage = ''; if (!value) return false; if (value.length !== (this.config?.['maxLength'] || 3)) { this.hasError = true; this.errorMessage = `Code must be exactly ${this.config?.['maxLength'] || 3} characters`; return false; } const pattern = this.config?.['pattern'] || /^[A-Z]+$/; if (!pattern.test(value)) { this.hasError = true; this.errorMessage = 'Only letters are allowed'; return false; } if (this.config?.existingValues?.includes(value)) { this.hasError = true; this.errorMessage = 'This code already exists'; // await this.dialogService.warning( // `The code "${value}" already exists. Please enter a different code.`, // 'Duplicate Code' // ); return false; } return true; } // ControlValueAccessor interface implementation writeValue(value: string): void { console.log('AirportCodeEditor writeValue:', value); this.inputControl.setValue(value, { emitEvent: false }); } registerOnChange(fn: (value: string) => void): void { console.log('AirportCodeEditor registerOnChange'); this.onChanged = fn; } registerOnTouched(fn: () => void): void { this.onTouched = fn; } setDisabledState(isDisabled: boolean): void { if (isDisabled) { this.inputControl.disable(); } else { this.inputControl.enable(); } } }
    |   |   |   +-- binary-editor
    |   |   |   |   --- binary-editor.component.ts: // src/components/ixt-matrix/matrix-editors/binary-editor/binary-editor.component.ts import { Component, Input, forwardRef, Output, EventEmitter, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { MatrixEditor, MatrixEditorConfig } from '../editor.interface'; interface BinaryConfig extends MatrixEditorConfig { trueValue?: any; falseValue?: any; trueDisplay?: string; falseDisplay?: string; rowData?: any; rowIndex?: number; } interface SelectionEvent { selected: boolean; rowData?: any; rowIndex?: number; } @Component({ selector: 'binary-editor', template: ` <div class="editor-container"> <input type="checkbox" [formControl]="inputControl" [checked]="isChecked" (change)="onCheckboxChange($event)" class="w-4 h-4 rounded border-gray-300" /> <span *ngIf="showLabel" class="ml-2"> {{ isChecked ? config.trueDisplay : config.falseDisplay }} </span> </div> `, providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => BinaryEditorComponent), multi: true } ] }) export class BinaryEditorComponent implements ControlValueAccessor, MatrixEditor { @Input() config: BinaryConfig = {}; @Output() selectionChange = new EventEmitter<SelectionEvent>(); inputControl = new FormControl<boolean | null>(false); component: Type<any> = BinaryEditorComponent; showLabel = false; isChecked = false; private onChange: (value: any) => void = () => { }; private onTouch: () => void = () => { }; constructor() { this.setupDefaults(); this.isChecked = false; } ngOnInit() { this.setupDefaults(); this.setupValueChanges(); } private setupDefaults() { this.config = { trueValue: true, falseValue: false, trueDisplay: 'True', falseDisplay: 'False', ...this.config }; } private setupValueChanges(): void { this.inputControl.valueChanges.subscribe((checked: boolean | null) => { if (checked !== null) { const value = checked ? this.config.trueValue : this.config.falseValue; this.isChecked = checked; this.onChange(value); this.selectionChange.emit({ selected: checked, rowData: this.config.rowData, rowIndex: this.config.rowIndex }); } }); } onCheckboxChange(event: Event) { const checkbox = event.target as HTMLInputElement; this.inputControl.setValue(checkbox.checked); this.onTouch(); } getEditConfig(): BinaryConfig { return { trueValue: this.config.trueValue || true, falseValue: this.config.falseValue || false, trueDisplay: this.config.trueDisplay || 'True', falseDisplay: this.config.falseDisplay || 'False' }; } writeValue(value: any): void { const checked = value === this.config.trueValue; this.isChecked = checked; this.inputControl.setValue(checked, { emitEvent: false }); } registerOnChange(fn: any): void { this.onChange = fn; } registerOnTouched(fn: any): void { this.onTouch = fn; } setDisabledState(isDisabled: boolean): void { if (isDisabled) { this.inputControl.disable(); } else { this.inputControl.enable(); } } }
    |   |   |   +-- coordinate
    |   |   |   |   --- coordinate-editor.component.ts: // src/components/ixt-matrix/matrix-editors/coordinate/coordinate-editor.component.ts import { Component, Input, forwardRef, OnInit, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { IxtDialogService } from '../../../ixt-dialog/ixt-dialog.service'; import { MatrixEditor, MatrixEditorConfig } from '../editor.interface'; @Component({ selector: 'coordinate-editor', template: ` <div class="editor-container"> <input type="number" step="any" [min]="config?.['type'] === 'lat' ? -90 : -180" [max]="config?.['type'] === 'lat' ? 90 : 180" [formControl]="inputControl" class="w-24 px-2 py-1 border rounded" [class.border-red-500]="hasError" [placeholder]="config?.['type'] === 'lat' ? '(-90 to 90)' : '(-180 to 180)'" (blur)="onBlur()" /> <div *ngIf="hasError" class="text-red-500 text-sm mt-1"> {{ errorMessage }} </div> </div>`, providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => CoordinateEditorComponent), multi: true } ] }) export class CoordinateEditorComponent implements ControlValueAccessor, OnInit, MatrixEditor { @Input() config?: MatrixEditorConfig; inputControl = new FormControl(''); hasError = false; errorMessage = ''; // MatrixEditor implementation component: Type<any> = CoordinateEditorComponent; private onChange: (value: number) => void = () => { }; private onTouch: () => void = () => { }; constructor(private dialogService: IxtDialogService) { } ngOnInit() { this.setupValueChanges(); } getEditConfig(): MatrixEditorConfig { return { type: this.config?.['type'] || 'lat' }; } validate(value: any): boolean { const num = Number(value); const isLat = this.config?.['type'] === 'lat'; return isLat ? (num >= -90 && num <= 90) : (num >= -180 && num <= 180); } // private setupValueChanges() { // this.inputControl.valueChanges.subscribe(value => { // if (value !== null) { // // Convert string to number for validation // const numValue = Number(value); // if (this.validateValue(numValue)) { // this.onChange(numValue); // } // } // }); // } setupValueChanges() { this.inputControl.valueChanges.subscribe(value => { if (value !== null) { const numValue = Number(value); if (!isNaN(numValue) && this.validateValue(numValue)) { this.onChange(numValue); } else { // Reset to last valid value or empty this.inputControl.setValue('', {emitEvent: false}); } } }); } private validateValue(value: number): boolean { this.hasError = false; this.errorMessage = ''; if (isNaN(value)) { this.hasError = true; this.errorMessage = 'Must be a valid number'; return false; } const isLat = this.config?.['type'] === 'lat'; const min = isLat ? -90 : -180; const max = isLat ? 90 : 180; if (value < min || value > max) { this.hasError = true; this.errorMessage = `Must be between ${min} and ${max}`; return false; } return true; } // ControlValueAccessor methods writeValue(value: number): void { this.inputControl.setValue(value?.toString() || '', { emitEvent: false }); } registerOnChange(fn: any): void { this.onChange = fn; } registerOnTouched(fn: any): void { this.onTouch = fn; } onBlur(): void { this.onTouch(); } }
    |   |   |   --- DatePickerComponent.ts: // matrix-editors/date-picker.component.ts import { Component, Input, Output, EventEmitter } from '@angular/core'; @Component({ selector: 'ixt-date-picker', template: ` <input type="date" [value]="value | date:'yyyy-MM-dd'" (change)="onChange($event)" class="ixt-date-picker__input"> `, styles: [` .ixt-date-picker__input { width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 4px; } `] }) export class DatePickerComponent { @Input() value: Date | null = null; @Output() valueChange = new EventEmitter<Date>(); onChange(event: Event) { const value = (event.target as HTMLInputElement).value; this.valueChange.emit(new Date(value)); } }
    |   |   |   --- color.editor.ts: <empty file>
    |   |   |   --- date.editor.ts: import { Injectable } from "@angular/core"; import { MatrixEditor } from "./editor.interface"; import { formatDate } from "@angular/common"; import { DatePickerComponent } from "./DatePickerComponent"; // matrix-editors/date.editor.ts @Injectable() export class DateEditor implements MatrixEditor { component = DatePickerComponent; getEditConfig() { return { format: 'yyyy-MM-dd', showTimeSelect: false }; } format(value: Date): string { return formatDate(value, 'shortDate', 'en-US'); } }
    |   |   |   --- editor.interface.ts: import { Type } from "@angular/core"; export interface MatrixEditorConfig { existingValues?: any[]; validators?: any[]; field?: string; [key: string]: any; } export interface MatrixEditor { component: Type<any>; getEditConfig(): any; validate?(value: any): boolean; format?(value: any): string; getDefaultValue?(): any; }
    |   |   +-- services
    |   |   |   +-- edit
    |   |   |   |   --- edit.model.ts: // src/components/ixt-matrix/services/edit/edit.model.ts import { FormControl } from '@angular/forms'; export interface RowChanges { [key: string]: any; } export interface EditState { editingRows: Set<number>; newRows: any[]; rowChanges: Map<number, RowChanges>; editControls: Map<string, FormControl>; } export interface EditEvent { rowIndex: number; field: string; value: any; }
    |   |   |   |   --- edit.service.ts: // src/components/ixt-matrix/services/edit/edit.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { FormControl } from '@angular/forms'; import { EditState, RowChanges, EditEvent } from './edit.model'; import { ColumnConfig } from '../../ixt-table.interfaces'; @Injectable({ providedIn: 'root' }) export class EditService { private readonly initialState: EditState = { editingRows: new Set<number>(), newRows: [], rowChanges: new Map<number, RowChanges>(), editControls: new Map<string, FormControl>() }; private state = new BehaviorSubject<EditState>(this.initialState); public state$ = this.state.asObservable(); private getDefaultValueForType(type: string | any): any { switch (type) { case 'number': return 0; case 'enum': return ''; case 'text': default: return ''; } } public addNewRow(columnConfigs: Record<string, ColumnConfig>): void { const newRow: any = {}; if (columnConfigs) { Object.entries(columnConfigs).forEach(([field, config]) => { newRow[field] = this.getDefaultValueForType(config.type); }); } const currentState = this.state.getValue(); const newRows = [...currentState.newRows]; newRows.unshift(newRow); // Start editing the new row const editingRows = new Set(currentState.editingRows); editingRows.add(-newRows.length); this.state.next({ ...currentState, newRows, editingRows }); } public startEditing(rowIndex: number): void { const currentState = this.state.getValue(); const editingRows = new Set(currentState.editingRows); editingRows.add(rowIndex); this.state.next({ ...currentState, editingRows }); } public cancelEditing(rowIndex: number): void { const currentState = this.state.getValue(); const editingRows = new Set(currentState.editingRows); const rowChanges = new Map(currentState.rowChanges); editingRows.delete(rowIndex); rowChanges.delete(rowIndex); this.state.next({ ...currentState, editingRows, rowChanges }); } public onValueChange(event: EditEvent): void { const { rowIndex, field, value } = event; const currentState = this.state.getValue(); const rowChanges = new Map(currentState.rowChanges); let changes = rowChanges.get(rowIndex) || {}; changes = { ...changes, [field]: value }; rowChanges.set(rowIndex, changes); this.state.next({ ...currentState, rowChanges }); } public getEditControl(rowIndex: number, field: string): FormControl { const key = `${rowIndex}-${field}`; const currentState = this.state.getValue(); let control = currentState.editControls.get(key); if (!control) { control = new FormControl(''); const editControls = new Map(currentState.editControls); editControls.set(key, control); this.state.next({ ...currentState, editControls }); } return control; } public saveChanges(data: any[]): any[] { const currentState = this.state.getValue(); const updatedData = [...data]; // Apply changes to existing rows currentState.rowChanges.forEach((changes, rowIndex) => { if (rowIndex >= 0) { updatedData[rowIndex] = { ...updatedData[rowIndex], ...changes }; } }); // Add new rows if (currentState.newRows.length) { // Apply any changes to new rows const processedNewRows = currentState.newRows.map((row, index) => { const changes = currentState.rowChanges.get(-index - 1); return changes ? { ...row, ...changes } : row; }); updatedData.unshift(...processedNewRows); } // Reset state this.state.next(this.initialState); return updatedData; } public isNewRow(index: number): boolean { return index < this.state.getValue().newRows.length; } public isEditing(rowIndex: number): boolean { return this.state.getValue().editingRows.has(rowIndex); } public hasChanges(): boolean { const currentState = this.state.getValue(); return currentState.rowChanges.size > 0 || currentState.newRows.length > 0; } public getNewRows(): any[] { return this.state.getValue().newRows; } public getRowChanges(rowIndex: number): RowChanges | undefined { return this.state.getValue().rowChanges.get(rowIndex); } public getRowIndex(displayIndex: number): number { return displayIndex - this.state.getValue().newRows.length; } public clearEditing(): void { this.state.next(this.initialState); } }
    |   |   |   +-- filter
    |   |   |   |   --- filter.model.ts: // src/components/ixt-matrix/services/filter/filter.model.ts import { FormControl } from '@angular/forms'; export type FilterOperator = 'equals' | 'startsWith' | 'contains' | 'between' | '>' | '<' | '>=' | '<=' | '!='; export interface FilterState { field: string; operator: FilterOperator; value: any; secondaryValue?: any; } export interface FilterControls { value: FormControl; operator?: FormControl<string>; }
    |   |   |   |   --- filter.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; import { FormControl } from '@angular/forms'; import { FilterState, FilterOperator, FilterControls } from './filter.model'; import { ColumnConfig } from '../../ixt-table.interfaces'; @Injectable({ providedIn: 'root' }) export class FilterService { private activeFilters = new Map<string, FilterState>(); private filterControls = new Map<string, FilterControls>(); private activeFilterColumn?: string; private showFilters = false; private filtersChanged = new BehaviorSubject<Map<string, FilterState>>(new Map()); public filtersChanged$ = this.filtersChanged.asObservable(); public initializeFilter(field: string, config: ColumnConfig): void { const controls: FilterControls = { value: new FormControl('') }; if (config.type === 'number') { // Fix: Explicitly type the FormControl controls.operator = new FormControl<string>('=', { nonNullable: true }); } this.filterControls.set(field, controls); } public getFilterControl(field: string): FormControl | undefined { return this.filterControls.get(field)?.value; } public getOperatorControl(field: string): FormControl<string> | undefined { return this.filterControls.get(field)?.operator; } public onFilterChange(field: string, value: any, config?: ColumnConfig): void { if (value || value === 0) { const defaultOperator: FilterOperator = config?.type === 'number' ? 'equals' : 'contains'; const operator = this.getOperatorControl(field)?.value || defaultOperator; this.activeFilters.set(field, { field, operator: operator as FilterOperator, value: config?.type === 'number' ? Number(value) : value }); } else { this.activeFilters.delete(field); } this.filtersChanged.next(this.activeFilters); } public onOperatorChange(field: string): void { const currentValue = this.getFilterControl(field)?.value; if (currentValue || currentValue === 0) { this.onFilterChange(field, currentValue); } } public clearAllFilters(): void { this.activeFilters.clear(); this.filterControls.forEach(controls => { controls.value.reset(); controls.operator?.reset('='); }); this.filtersChanged.next(this.activeFilters); } public toggleFilters(column: string): void { if (this.activeFilterColumn === column) { this.activeFilterColumn = undefined; this.showFilters = false; } else { this.activeFilterColumn = column; this.showFilters = true; } } public matchesFilter(item: any, filter: FilterState): boolean { if (item === undefined || item === null) return false; // Handle numeric comparisons if (typeof item === 'number' || !isNaN(Number(item))) { const numValue = Number(item); const numFilterValue = Number(filter.value); return this.handleNumericComparison(numValue, numFilterValue, filter.operator); } // String handling const itemValue = String(item).toLowerCase(); const filterValue = String(filter.value).toLowerCase(); switch (filter.operator) { case 'startsWith': return itemValue.startsWith(filterValue); case 'equals': return itemValue === filterValue; case '!=': return itemValue !== filterValue; default: return itemValue.includes(filterValue); } } private handleNumericComparison(numValue: number, numFilterValue: number, operator: FilterOperator): boolean { switch (operator) { case '>': return numValue > numFilterValue; case '<': return numValue < numFilterValue; case '>=': return numValue >= numFilterValue; case '<=': return numValue <= numFilterValue; case '!=': return numValue !== numFilterValue; case 'equals': return numValue === numFilterValue; default: return false; } } public get isShowingFilters(): boolean { return this.showFilters; } public get activeColumn(): string | undefined { return this.activeFilterColumn; } public getActiveFilters(): Map<string, FilterState> { return this.activeFilters; } public hasActiveFilters(): boolean { return this.activeFilters.size > 0; } }
    |   |   |   +-- selection
    |   |   |   |   --- selection.model.ts: // src/components/ixt-matrix/services/selection/selection.model.ts export interface SelectionState { selectedRows: Set<number>; allSelected: boolean; }
    |   |   |   |   --- selection.service.ts: // src/components/ixt-matrix/services/selection/selection.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { SelectionState } from './selection.model'; @Injectable({ providedIn: 'root' }) export class SelectionService { private state = new BehaviorSubject<SelectionState>({ selectedRows: new Set<number>(), allSelected: false }); public state$ = this.state.asObservable(); public selectRow(index: number, selected: boolean = true): void { const currentState = this.state.getValue(); const newSelectedRows = new Set(currentState.selectedRows); if (selected) { newSelectedRows.add(index); } else { newSelectedRows.delete(index); } this.state.next({ selectedRows: newSelectedRows, allSelected: currentState.allSelected }); } public toggleAllRows(selected: boolean, totalRows: number): void { const newSelectedRows = new Set<number>(); if (selected) { // Add all row indices for (let i = 0; i < totalRows; i++) { newSelectedRows.add(i); } } this.state.next({ selectedRows: newSelectedRows, allSelected: selected }); } public clearSelection(): void { this.state.next({ selectedRows: new Set<number>(), allSelected: false }); } public getSelectedRows(): Set<number> { return this.state.getValue().selectedRows; } public isSelected(index: number): boolean { return this.state.getValue().selectedRows.has(index); } public isAllSelected(): boolean { return this.state.getValue().allSelected; } public getSelectedCount(): number { return this.state.getValue().selectedRows.size; } public setSelectedRows(indices: number[]): void { const newSelectedRows = new Set(indices); this.state.next({ selectedRows: newSelectedRows, allSelected: false // Reset all selected state when manually setting rows }); } public isPartiallySelected(totalRows: number): boolean { const selectedCount = this.getSelectedCount(); return selectedCount > 0 && selectedCount < totalRows; } }
    |   |   |   +-- sort
    |   |   |   |   --- sort.model.ts: // src/components/ixt-matrix/services/sort/sort.model.ts export type SortDirection = 'asc' | 'desc' | null; export interface SortState { column: string | null; direction: SortDirection; }
    |   |   |   |   --- sort.service.ts: // src/components/ixt-matrix/services/sort/sort.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { SortState, SortDirection } from './sort.model'; @Injectable({ providedIn: 'root' }) export class SortService { private readonly initialState: SortState = { column: null, direction: null }; private state = new BehaviorSubject<SortState>(this.initialState); public state$ = this.state.asObservable(); public toggleSort(column: string): void { const currentState = this.state.getValue(); let newDirection: SortDirection = null; if (currentState.column === column) { // Cycle through: null -> asc -> desc -> null if (currentState.direction === null) { newDirection = 'asc'; } else if (currentState.direction === 'asc') { newDirection = 'desc'; } else { newDirection = null; } } else { // New column, start with ascending newDirection = 'asc'; } this.state.next({ column: newDirection ? column : null, direction: newDirection }); } public getSortIcon(column: string): string { const { column: sortColumn, direction } = this.state.getValue(); if (sortColumn !== column) { return 'unfold_more'; } return direction === 'asc' ? 'arrow_upward' : 'arrow_downward'; } public sortData<T>(data: T[]): T[] { const { column, direction } = this.state.getValue(); if (!column || !direction) { return data; } return [...data].sort((a, b) => { const aVal = a[column as keyof T]; const bVal = b[column as keyof T]; if (aVal == null) return 1; if (bVal == null) return -1; let comparison: number; if (typeof aVal === 'string') { comparison = String(aVal).toLowerCase().localeCompare(String(bVal).toLowerCase()); } else { comparison = aVal < bVal ? -1 : (aVal > bVal ? 1 : 0); } return direction === 'asc' ? comparison : -comparison; }); } public clearSort(): void { this.state.next(this.initialState); } public getCurrentSort(): SortState { return this.state.getValue(); } public isColumnSorted(column: string): boolean { return this.state.getValue().column === column; } public getSortDirection(column: string): SortDirection { const { column: sortColumn, direction } = this.state.getValue(); return sortColumn === column ? direction : null; } }
    |   |   |   --- pagination.model.ts: // src/components/ixt-matrix/services/pagination/pagination.model.ts export interface PaginationState { currentPage: number; pageSize: number | 'all'; totalItems: number; } export interface PageSize { value: number | 'all'; label: string; }
    |   |   |   --- pagination.service.ts: // src/components/ixt-matrix/services/pagination/pagination.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; import { PageSize, PaginationState } from './pagination.model'; @Injectable({ providedIn: 'root' }) export class PaginationService { private readonly DEFAULT_PAGE_SIZES: PageSize[] = [ { value: 10, label: '10' }, { value: 100, label: '100' }, { value: 'all', label: 'All' } ]; private readonly MINIMUM_ROWS_FOR_PAGINATION = 50; private state = new BehaviorSubject<PaginationState>({ currentPage: 1, pageSize: 10, totalItems: 0 }); public state$ = this.state.asObservable(); public initialize(totalItems: number): void { this.updateState({ currentPage: 1, pageSize: 10, totalItems }); } public shouldShowPagination(): boolean { return this.state.getValue().totalItems > this.MINIMUM_ROWS_FOR_PAGINATION; } public getCurrentPage(): number { return this.state.getValue().currentPage; } public getPageSize(): number | 'all' { return this.state.getValue().pageSize; } public getPageSizes(): PageSize[] { return this.DEFAULT_PAGE_SIZES; } public getTotalPages(): number { const { totalItems, pageSize } = this.state.getValue(); if (pageSize === 'all' || totalItems <= this.MINIMUM_ROWS_FOR_PAGINATION) { return 1; } return Math.ceil(totalItems / +pageSize); } public getVisiblePages(): number[] { const totalPages = this.getTotalPages(); const currentPage = this.getCurrentPage(); if (totalPages <= 1) return []; const pages: number[] = [1]; const WINDOW_SIZE = 4; let start = Math.max(2, currentPage - WINDOW_SIZE); let end = Math.min(totalPages - 1, currentPage + WINDOW_SIZE); if (start > 2) { pages.push(-1); } for (let i = start; i <= end; i++) { pages.push(i); } if (end < totalPages - 1) { pages.push(-1); } if (totalPages > 1) { pages.push(totalPages); } return pages; } public onPageChange(page: number): void { const totalPages = this.getTotalPages(); if (page >= 1 && page <= totalPages) { this.updateState({ ...this.state.getValue(), currentPage: page }); } } public onPageSizeChange(newSize: number | 'all'): void { this.updateState({ ...this.state.getValue(), pageSize: newSize, currentPage: 1 }); } public getPaginatedData<T>(data: T[]): T[] { const { pageSize, currentPage } = this.state.getValue(); if (pageSize === 'all' || data.length <= this.MINIMUM_ROWS_FOR_PAGINATION) { return data; } const start = (currentPage - 1) * (+pageSize); const end = start + (+pageSize); return data.slice(start, end); } private updateState(newState: Partial<PaginationState>): void { this.state.next({ ...this.state.getValue(), ...newState }); } }
    |   |   --- ixt-table.component.html: <div class="ixt-table__toolbar"> <button class="ixt-table__action-button" (click)="addNewRow()"> <span class="material-icons">add</span> </button> <button class="ixt-table__action-button" [disabled]="!hasChanges && newRowsLength === 0" (click)="saveChanges()"> <span class="material-icons">save</span> </button> </div> <ng-container *ngIf="hasData; else noData"> <div class="ixt-table"> <!-- Header --> <div class="ixt-table__header"> <div class="ixt-table__cell"> <binary-editor [config]="{ rowIndex: -1 }" [(ngModel)]="allSelected" (selectionChange)="toggleAllRows($event.selected)"> </binary-editor> </div> <div class="ixt-table__cell" *ngFor="let col of columns" [class.ixt-table__cell--first]="col === columns[0]"> <div class="ixt-table__cell-content"> {{columnConfigs?.[col]?.label || col}} <div class="ixt-table__cell-actions"> <button class="ixt-table__sort-toggle" (click)="toggleSort(col)"> <span class="material-icons">{{getSortIcon(col)}}</span> </button> <button class="ixt-table__filter-toggle" (click)="toggleFilters(col)"> <span class="material-icons">filter_alt</span> </button> </div> </div> </div> <div class="ixt-table__cell">Actions</div> </div> <!-- Filter Row --> <div class="ixt-table__header" *ngIf="showFilters"> <div class="ixt-table__cell"></div> <div class="ixt-table__cell" *ngFor="let col of columns" [class.ixt-table__cell--first]="col === columns[0]"> <ng-container *ngIf="activeFilterColumn === col && columnConfigs?.[col]"> <ng-container [ngSwitch]="getEditorType(columnConfigs?.[col]?.type)"> <!-- Text Filter --> <input *ngSwitchCase="'text'" [formControl]="getFilterControl(col)" [placeholder]="columnConfigs?.[col]?.placeholder || ''" class="ixt-table__filter-input"> <!-- Number Filter --> <div *ngSwitchCase="'number'" class="ixt-table__number-filter"> <select [formControl]="getOperatorControl(col)" (change)="onOperatorChange(col)"> <option value="=">=</option> <option value=">">&gt;</option> <option value="<">&lt;</option> <option value=">=">&gt;=</option> <option value="<=">&lt;=</option> <option value="!=">!=</option> </select> <input type="number" [formControl]="getFilterControl(col)" [placeholder]="columnConfigs?.[col]?.placeholder || ''" class="ixt-table__filter-input"> </div> <!-- Enum Filter --> <div *ngSwitchCase="'enum'"> <select [formControl]="getFilterControl(col)" class="ixt-table__filter-input"> <option value="">All</option> <option *ngFor="let opt of columnConfigs?.[col]?.enumValues" [value]="opt.value"> {{opt.label}} </option> </select> </div> </ng-container> </ng-container> </div> <div class="ixt-table__cell"></div> </div> <!-- Data Rows --> <div class="ixt-table__row" *ngFor="let row of paginatedData; let i = index" [class.ixt-table__row--selected]="isRowSelected(getRowIndex(i))"> <div class="ixt-table__cell"> <binary-editor [config]="{ rowIndex: getRowIndex(i), rowData: row }" [ngModel]="isRowSelected(getRowIndex(i))" (selectionChange)="selectRow(getRowIndex(i), $event.selected)"> </binary-editor> </div> <div class="ixt-table__cell" *ngFor="let col of columns" [class.ixt-table__cell--first]="col === columns[0]"> <ng-container *ngIf="isNewRow(i) || isEditing(getRowIndex(i)); else displayValue"> <ng-container [ngSwitch]="getEditorType(columnConfigs?.[col]?.type)"> <!-- Text Input --> <input *ngSwitchCase="'text'" type="text" [ngModel]="row[col]" (ngModelChange)="onValueChange(getRowIndex(i), col, $event)"> <!-- Number Input --> <input *ngSwitchCase="'number'" type="number" [ngModel]="row[col]" (ngModelChange)="onValueChange(getRowIndex(i), col, $event)"> <!-- Enum Select --> <select *ngSwitchCase="'enum'" [ngModel]="row[col]" (ngModelChange)="onValueChange(getRowIndex(i), col, $event)"> <option *ngFor="let opt of columnConfigs?.[col]?.enumValues" [ngValue]="opt.value"> {{opt.label}} </option> </select> <!-- Custom Editor --> <ng-container *ngSwitchCase="'custom'"> <ng-container *ngTemplateOutlet="customEditorTpl; context: { $implicit: getEditorComponent(columnConfigs?.[col]?.type), row: row, col: col, index: i, control: getEditControl(getRowIndex(i), col) }"> </ng-container> </ng-container> </ng-container> </ng-container> <ng-template #displayValue> <ng-container [ngSwitch]="columnConfigs?.[col]?.type"> <ng-container *ngSwitchCase="CoordinateEditorComponent"> {{formatCoordinate(row[col])}} </ng-container> <ng-container *ngSwitchDefault> {{row[col]}} </ng-container> </ng-container> </ng-template> </div> <div class="ixt-table__cell"> <ng-container *ngIf="!isNewRow(i) && !isEditing(getRowIndex(i))"> <button class="ixt-table__action-button" (click)="startEditing(getRowIndex(i))"> <span class="material-icons">edit</span> </button> </ng-container> <ng-container *ngIf="isNewRow(i) || isEditing(getRowIndex(i))"> <button class="ixt-table__action-button" (click)="cancelEditing(getRowIndex(i))"> <span class="material-icons">close</span> </button> </ng-container> </div> </div> <!-- Pagination --> <div class="ixt-table__footer" *ngIf="showPagination"> <div class="ixt-table__pagination"> <div class="ixt-table__page-size"> <select [formControl]="pageSizeControl"> <option *ngFor="let size of pageSizes" [value]="size.value"> {{size.label}} </option> </select> rows per page </div> <div class="ixt-table__controls"> <button (click)="onPageChange(1)" [disabled]="currentPage === 1"> <span class="material-icons">first_page</span> </button> <button (click)="onPageChange(currentPage - 1)" [disabled]="currentPage === 1"> <span class="material-icons">chevron_left</span> </button> <button *ngFor="let page of visiblePages" [class.active]="page === currentPage" [class.ellipsis]="page === -1" [disabled]="page === -1" (click)="onPageChange(page)"> {{page === -1 ? '...' : page}} </button> <button (click)="onPageChange(currentPage + 1)" [disabled]="currentPage === totalPages"> <span class="material-icons">chevron_right</span> </button> <button (click)="onPageChange(totalPages)" [disabled]="currentPage === totalPages"> <span class="material-icons">last_page</span> </button> </div> </div> </div> </div> </ng-container> <!-- Custom Editor Template --> <ng-template #customEditorTpl let-editor let-row="row" let-col="col" let-index="index" let-control="control"> <coordinate-editor *ngIf="editor?.component === CoordinateEditorComponent" [formControl]="control" [config]="{ type: col === 'lat' ? 'lat' : 'lon' }"> </coordinate-editor> <airport-code-editor *ngIf="editor?.component === AirportCodeEditorComponent" [formControl]="control" [config]="editor.getEditConfig()" [existingCodes]="getCodes(data)"> </airport-code-editor> </ng-template> <!-- No Data Template --> <ng-template #noData> <div class="ixt-table__empty"> No data available </div> </ng-template>
    |   |   --- ixt-table.component.ts: import { ChangeDetectorRef, Component, Input, OnInit, TemplateRef, ViewChild, Type } from '@angular/core'; import { FormControl } from '@angular/forms'; import { ColumnConfig, FilterOperator, FilterState, MatrixNode, PageSize, RowChanges } from './ixt-table.interfaces'; import { debounceTime, distinctUntilChanged } from 'rxjs/operators'; import { IxtDialogService } from '../ixt-dialog/ixt-dialog.index'; import { PaginationService } from './services/pagination.service'; import { FilterService } from './services/filter/filter.service'; import { SortService } from './services/sort/sort.service'; import { SelectionService } from './services/selection/selection.service'; import { EditService } from './services/edit/edit.service'; import { MatrixEditor } from './editors/editor.interface'; import { AirportCodeEditorComponent, CoordinateEditorComponent } from './ixt-table.index'; export type SortDirection = 'asc' | 'desc' | null; @Component({ selector: 'ixt-table', templateUrl: './ixt-table.component.html', styleUrls: ['./ixt-table.component.scss'] }) export class IxtTableComponent implements OnInit { @Input() data: MatrixNode[] = []; @Input() columnConfigs?: Record<string, ColumnConfig>; @ViewChild('noData') noDataTemplate!: TemplateRef<any>; @ViewChild('customEditorTpl') customEditorTpl!: TemplateRef<any>; columns: string[] = []; pageSizeControl = new FormControl<number | 'all'>(10); readonly AirportCodeEditorComponent = AirportCodeEditorComponent; readonly CoordinateEditorComponent = CoordinateEditorComponent; constructor( private dialogService: IxtDialogService, private changeDetectorRef: ChangeDetectorRef, private paginationService: PaginationService, private filterService: FilterService, private sortService: SortService, private selectionService: SelectionService, private editService: EditService ) { } ngOnInit() { this.columns = this.getColumns(this.data); // Initialize pagination this.paginationService.initialize(this.data.length); // Initialize filters if (this.columnConfigs) { Object.entries(this.columnConfigs).forEach(([field, config]) => { this.filterService.initializeFilter(field, config); // Get the control from service and subscribe to changes const control = this.filterService.getFilterControl(field); if (control) { control.valueChanges.pipe( debounceTime(config.debounceTime || 300), distinctUntilChanged() ).subscribe(value => { this.filterService.onFilterChange(field, value, config); }); } }); } // Subscribe to filter changes this.filterService.filtersChanged$.subscribe(() => { this.changeDetectorRef.markForCheck(); }); // Subscribe to pagination changes this.paginationService.state$.subscribe(() => { this.changeDetectorRef.markForCheck(); }); // Subscribe to page size changes this.pageSizeControl.valueChanges.subscribe(value => { if (value) { this.paginationService.onPageSizeChange(value); } }); } // edit logic start addNewRow(): void { this.editService.addNewRow(this.columnConfigs || {}); } cancelEditing(rowIndex: number): void { this.editService.cancelEditing(rowIndex); } getEditorComponent(type: any): MatrixEditor | null { console.log('getEditorComponent called with:', { type, isCoordinate: type === CoordinateEditorComponent, isAirport: type === AirportCodeEditorComponent }); if (type === AirportCodeEditorComponent) { return new AirportCodeEditorComponent(this.dialogService); } if (type === CoordinateEditorComponent) { return new CoordinateEditorComponent(this.dialogService); } return null; } getEditorType(type: any): string { console.log('getEditorType called with:', { type, isString: typeof type === 'string', isCoordinate: type === CoordinateEditorComponent, isAirport: type === AirportCodeEditorComponent }); if (typeof type === 'string') { return type; } if (type === AirportCodeEditorComponent || type === CoordinateEditorComponent) { console.log('Returning custom for editor type'); return 'custom'; } console.log('Falling back to text type'); return 'text'; } getEditControl(rowIndex: number, field: string): FormControl { return this.editService.getEditControl(rowIndex, field); } getRowIndex(displayIndex: number): number { return this.editService.getRowIndex(displayIndex); } get hasChanges(): boolean { return this.editService.hasChanges(); } isEditing(index: number): boolean { return this.editService.isEditing(index); } isNewRow(displayIndex: number): boolean { return this.editService.isNewRow(displayIndex); } get newRowsLength(): number { return this.editService.getNewRows().length; } onValueChange(rowIndex: number, field: string, value: any): void { this.editService.onValueChange({ rowIndex, field, value }); } saveChanges(): void { this.data = this.editService.saveChanges(this.data); this.changeDetectorRef.markForCheck(); } startEditing(rowIndex: number): void { this.editService.startEditing(rowIndex); } // edit logic end // filter logic start get activeFilterColumn(): string | undefined { return this.filterService.activeColumn; } getFilterControl(col: string): FormControl<any> { return this.filterService.getFilterControl(col)!; } getOperatorControl(col: string): FormControl<string> { return this.filterService.getOperatorControl(col)!; } onOperatorChange(field: string): void { this.filterService.onOperatorChange(field); } get showFilters(): boolean { return this.filterService.isShowingFilters; } toggleFilters(col: string): void { this.filterService.toggleFilters(col); } // filter logic end // pagination logic start get currentPage(): number { return this.paginationService.getCurrentPage(); } onPageChange(page: number): void { this.paginationService.onPageChange(page); } onPageSizeChange(size: number | 'all'): void { this.paginationService.onPageSizeChange(size); } get paginatedData(): MatrixNode[] { // Start with combined data let allData = [...this.editService.getNewRows(), ...this.data]; // Apply filters if (this.filterService.hasActiveFilters()) { const activeFilters = this.filterService.getActiveFilters(); const filteredExisting = this.data.filter(item => Array.from(activeFilters.values()).every(filter => this.filterService.matchesFilter(item[filter.field], filter) ) ); allData = [...this.editService.getNewRows(), ...filteredExisting]; } // Apply sorting allData = this.sortService.sortData(allData); // Apply pagination return this.paginationService.getPaginatedData(allData); } get pageSizes(): PageSize[] { return this.paginationService.getPageSizes(); } get showPagination(): boolean { return this.paginationService.shouldShowPagination(); } get totalPages(): number { return this.paginationService.getTotalPages(); } get visiblePages(): number[] { return this.paginationService.getVisiblePages(); } // pagination logic end // selection logic start get allSelected(): boolean { return this.selectionService.isAllSelected(); } set allSelected(value: boolean) { this.selectionService.toggleAllRows(value, this.data.length); } getSelectedRows(): MatrixNode[] { return Array.from(this.selectionService.getSelectedRows()) .map(index => this.data[index]) .filter(row => row !== undefined); } get hasSelectedRows(): boolean { return this.selectionService.getSelectedCount() > 0; } isRowSelected(index: number): boolean { return this.selectionService.isSelected(index); } selectRow(index: number, selected = true): void { this.selectionService.selectRow(index, selected); } setSelectedRows(indices: number[]): void { this.selectionService.setSelectedRows(indices); } toggleAllRows(selected: boolean): void { this.selectionService.toggleAllRows(selected, this.data.length); } // selection logic end // sort logic start getSortIcon(column: string): string { return this.sortService.getSortIcon(column); } toggleSort(column: string): void { this.sortService.toggleSort(column); } // sort logic end // i/o logic start formatCoordinate(value: number): string { return value.toFixed(1); } getCodes(data: MatrixNode[]): string[] { if (!data) return []; return data.map(row => row['code']?.toString() || ''); } // i/o logic end // config logic start getColumns(data: MatrixNode[]): string[] { if (!data?.length) return []; const firstRow = data[0]; return Object.keys(firstRow); } get hasData(): boolean { return !!this.data?.length; } // config logic end }
    |   |   --- ixt-table.index.ts: // src/components/ixt-matrix/index.ts // Fix these import paths to match your folder structure export * from './ixt-table.component'; export * from './ixt-table.interfaces'; export * from './ixt-table.module'; export interface MatrixNode { [key: string]: any; children?: MatrixNode[]; } export * from './editors/airport-code/airport-code-editor.component'; export * from './editors/binary-editor/binary-editor.component'; export * from './editors/coordinate/coordinate-editor.component';
    |   |   --- ixt-table.interfaces.ts: // File: src/components/ixt-table/ixt-table.interfaces.ts import { Type } from "@angular/core"; import { MatrixEditor } from "./editors/editor.interface"; export interface MatrixNode { code?: string; // Add this property [key: string]: any; } export interface PageSize { value: number | 'all'; label: string; } export type FilterOperator = 'equals' | 'startsWith' | 'contains' | 'between' | '>' | '<' | '>=' | '<=' | '!='; export interface FilterState { field: string; operator: FilterOperator; value: any; secondaryValue?: any; } export interface ColumnConfig { type: 'text' | 'number' | 'enum' | Type<MatrixEditor> | MatrixEditor; field: string; label?: string; operator?: FilterOperator; enumValues?: { value: any, label: string }[]; placeholder?: string; debounceTime?: number; editable?: boolean; config?: any; } export interface RowChanges { [key: string]: any; } export type ColumnConfigs = Record<string, ColumnConfig>;
    |   |   --- ixt-table.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { MatIconModule } from '@angular/material/icon'; import { MatAutocompleteModule } from '@angular/material/autocomplete'; import { IxtTableComponent } from './ixt-table.component'; import { AirportCodeEditorComponent } from './editors/airport-code/airport-code-editor.component'; import { CoordinateEditorComponent } from './editors/coordinate/coordinate-editor.component'; import { BinaryEditorComponent } from './editors/binary-editor/binary-editor.component'; @NgModule({ declarations: [ IxtTableComponent, AirportCodeEditorComponent, CoordinateEditorComponent, BinaryEditorComponent ], imports: [ CommonModule, FormsModule, // Make sure this is here ReactiveFormsModule, MatIconModule, MatAutocompleteModule ], exports: [IxtTableComponent] }) export class IxtTableModule { }
    |   |   --- ixt-table.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject, combineLatest, Observable } from 'rxjs'; import { map } from 'rxjs/operators'; import { MatrixRow } from './matrix-base.type'; import { PageSize } from './ixt-matrix.interfaces'; export interface PaginationState { currentPage: number; pageSize: number | 'all'; totalPages: number; } @Injectable({ providedIn: 'root' }) export class MatrixDataService { private dataSubject = new BehaviorSubject<MatrixRow[]>([]); private newRowsSubject = new BehaviorSubject<MatrixRow[]>([]); private paginationStateSubject = new BehaviorSubject<PaginationState>({ currentPage: 1, pageSize: 10, totalPages: 1 }); readonly pageSizes: PageSize[] = [ { value: 10, label: '10' }, { value: 100, label: '100' }, { value: 'all', label: 'All' } ]; constructor() { } // Data operations setData(data: MatrixRow[]): void { this.dataSubject.next(data); this.updateTotalPages(); } getData(): Observable<MatrixRow[]> { return this.dataSubject.asObservable(); } // New rows operations addNewRow(row: MatrixRow): void { const currentNewRows = this.newRowsSubject.value; this.newRowsSubject.next([row, ...currentNewRows]); } getNewRows(): Observable<MatrixRow[]> { return this.newRowsSubject.asObservable(); } commitNewRows(): void { const currentData = this.dataSubject.value; const newRows = this.newRowsSubject.value; this.dataSubject.next([...newRows, ...currentData]); this.newRowsSubject.next([]); this.updateTotalPages(); } // Pagination operations setPaginationState(state: Partial<PaginationState>): void { const currentState = this.paginationStateSubject.value; this.paginationStateSubject.next({ ...currentState, ...state }); this.updateTotalPages(); } getPaginationState(): Observable<PaginationState> { return this.paginationStateSubject.asObservable(); } getPaginatedData(): Observable<MatrixRow[]> { return this.combineData().pipe( map(allData => this.paginateData(allData)) ); } private combineData(): Observable<MatrixRow[]> { return combineLatest([ this.dataSubject, this.newRowsSubject ]).pipe( map(([data, newRows]) => [...newRows, ...data]) ); } private paginateData(data: MatrixRow[]): MatrixRow[] { const state = this.paginationStateSubject.value; if (state.pageSize === 'all' || data.length <= 50) { return data; } const start = (state.currentPage - 1) * (+state.pageSize); const end = start + (+state.pageSize); return data.slice(start, end); } private updateTotalPages(): void { const currentState = this.paginationStateSubject.value; const totalItems = this.dataSubject.value.length + this.newRowsSubject.value.length; const totalPages = currentState.pageSize === 'all' || totalItems <= 50 ? 1 : Math.ceil(totalItems / +currentState.pageSize); this.paginationStateSubject.next({ ...currentState, totalPages }); } }
    |   |   --- ixt-table.type.ts: export interface MatrixRow { [key: string]: any; }
    |   \-- theme
    |       +-- styles
    |       |   \-- themes
    |       --- indext.ts: // src/components/theme/index.ts export * from './theme.types'; export * from './theme.colors';
    |       --- theme.colors.ts: import { ThemeColors } from "./theme.types"; // src/app/theme/theme.colors.ts export const baseThemeColors: ThemeColors = { primary: { base: '#4169E1', // Royal Blue hover: '#2850c9', active: '#1e40af', text: '#ffffff' }, secondary: { base: '#6c757d', hover: '#5c636a', active: '#4d5154', text: '#ffffff' }, tertiary: { base: '#003057', // Rhapsody Blue (Pantone 289) hover: '#002649', // Darker shade for hover state active: '#001C3B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, success: { base: '#28a745', hover: '#218838', active: '#1e7e34', text: '#ffffff' }, danger: { base: '#dc3545', hover: '#c82333', active: '#bd2130', text: '#ffffff' }, warning: { base: '#ffc107', hover: '#e0a800', active: '#d39e00', text: '#000000' }, info: { base: '#17a2b8', hover: '#138496', active: '#117a8b', text: '#ffffff' }, light: { base: '#f8f9fa', hover: '#e2e6ea', active: '#dae0e5', text: '#000000' }, dark: { base: '#343a40', hover: '#23272b', active: '#1d2124', text: '#ffffff' }, default: { base: '#ffffff', hover: '#f8f9fa', active: '#e9ecef', text: '#000000' } }; // src/app/theme/theme.colors.ts export const unitedThemeColors: ThemeColors = { primary: { base: '#0033A0', // United Blue hover: '#00297A', // Darker shade for hover state active: '#002060', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, secondary: { base: '#6D2077', // Atlantic Amethyst hover: '#5A1A63', // Darker shade for hover state active: '#48154F', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, tertiary: { base: '#003057', // Rhapsody Blue (Pantone 289) hover: '#002649', // Darker shade for hover state active: '#001C3B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, success: { base: '#4CAF50', // Subtle green hover: '#43A047', // Darker shade for hover state active: '#388E3C', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, warning: { base: '#FF9800', // Warm yellow-orange hover: '#FB8C00', // Darker shade for hover state active: '#F57C00', // Even darker shade for active state text: '#000000' // Black text for readability }, danger: { base: '#E53935', // Tomato red hover: '#D32F2F', // Darker shade for hover state active: '#C62828', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, info: { base: '#17A2B8', // Standard info blue hover: '#138496', // Darker shade for hover state active: '#117A8B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, light: { base: '#F8F9FA', // Light gray hover: '#E2E6EA', // Darker shade for hover state active: '#DAE0E5', // Even darker shade for active state text: '#000000' // Black text for readability }, dark: { base: '#343A40', // Dark gray hover: '#23272B', // Darker shade for hover state active: '#1D2124', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, default: { base: '#FFFFFF', // White hover: '#F8F9FA', // Light gray for hover state active: '#E9ECEF', // Darker gray for active state text: '#000000' // Black text for readability } };
    |       --- theme.colors.united.ts: <empty file>
    |       --- theme.module.ts: // src/components/theme/theme.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [CommonModule], exports: [] }) export class ThemeModule {}
    |       --- theme.types.ts: // src/app/theme/theme.types.ts export type ThemeVariant = | 'primary' // Main brand color, key actions | 'secondary' // Supporting color | 'tertiary' | 'success' // Positive actions/states | 'danger' // Errors, destructive actions | 'warning' // Caution states | 'info' // Informational states | 'light' // Light backgrounds | 'dark' // Dark text/backgrounds | 'default'; // Default state export interface ThemeColor { base: string; hover: string; active: string; text: string; } export type ThemeColors = Record<ThemeVariant, ThemeColor>;
    +-- services
    |   --- breadcrumb.service.ts: import { Injectable } from '@angular/core'; import { Router, NavigationEnd, ActivatedRoute } from '@angular/router'; import { filter, map } from 'rxjs/operators'; import { Observable } from 'rxjs'; export interface Breadcrumb { label: string; url: string; } @Injectable({ providedIn: 'root' }) export class BreadcrumbService { breadcrumbs$: Observable<Breadcrumb[]>; constructor(private router: Router, private activatedRoute: ActivatedRoute) { this.breadcrumbs$ = this.router.events.pipe( filter(event => event instanceof NavigationEnd), map(event => { const root = this.activatedRoute.root; return this.createBreadcrumbs(root); }) ); } private createBreadcrumbs(route: ActivatedRoute, url: string = '', breadcrumbs: Breadcrumb[] = []): Breadcrumb[] { const children: ActivatedRoute[] = route.children; if (children.length === 0) { return breadcrumbs; } for (const child of children) { const routeURL: string = child.snapshot.url.map(segment => segment.path).join('/'); if (routeURL !== '') { url += `/${routeURL}`; } const label = child.snapshot.data['breadcrumb']; if (label) { breadcrumbs.push({ label, url }); } return this.createBreadcrumbs(child, url, breadcrumbs); } return breadcrumbs; } }
    --- index.html: <!doctype html> <html> <head> <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> <meta charset="utf-8"> <title>Ixtlan Demo</title> <base href="/"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="icon" type="image/x-icon" href="favicon.ico"> </head> <body> <app-root></app-root> </body> </html>
    --- main.ts: import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module'; platformBrowserDynamic().bootstrapModule(AppModule) .catch(err => console.error(err));
    --- public-api.ts: // File: src/public-api.ts export * from './components/ixt-table/ixt-table.interfaces'; // Core UI Components export * from './components/ixt-button/ixt-button.index'; export * from './components/ixt-dialog/ixt-dialog.index'; export * from './components/ixt-tabset/ixt-tabset.index'; export * from './components/ixt-panel/ixt-panel.index'; export * from './components/ixt-menu/ixt-menu.index'; export * from './components/ixt-tree/ixt-tree.index'; export * from './components/ixt-accordian/ixt-accordian.index'; // Canvas & Viewport Components export * from './components/ixt-canvas/ixt-canvas.index'; export * from './components/ixt-viewport/ixt-viewport.index'; // Form Components export * from './components/ixt-expression-builder/ixt-expression-builder.index'; // Diagram Components export * from './components/ixt-diagram/ixt-diagram.index'; export * from './components/ixt-diagram/types/clazz/ixt-clazz.index'; export * from './components/ixt-diagram/types/deployment/ixt-deployment.index'; export * from './components/ixt-diagram/types/EBNF/ixt.ebnf.index'; export * from './components/ixt-diagram/types/flow/ixt-flow.index'; export * from './components/ixt-diagram/types/gannt/gannt.index'; export * from './components/ixt-diagram/types/network/ixt-network.index'; export * from './components/ixt-diagram/types/sankey/ixt-sankey.index'; export * from './components/ixt-diagram/types/wireframe/ixt-wireframe.index'; // Layer Management export * from './components/ixt-layer-manager/ixt-layer-manager.index'; // Calendar Component export * from './components/ixt-calendar/ixt-calendar.index'; // Map Component export * from './components/ixt-map/ixt-map.index'; // Split Pane Component export * from './components/ixt-splitpane/index'; // Add to src/public-api.ts export * from './components/theme/theme.types'; export * from './components/theme/theme.colors'; // In src/public-api.ts, add: export interface TableConfig { columns: { [key: string]: { title: string; type?: string; sortable?: boolean; filterable?: boolean; } }; sortable?: boolean; filterable?: boolean; pageSize?: number; }
