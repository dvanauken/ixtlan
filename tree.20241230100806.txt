    |   +-- ixt-table-tree
    |   |   --- ixt-table-tree.component.ts: import { Component, Input, Output, EventEmitter, OnInit } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { TableTreeColumn, TreeNode, TreeNodeData } from './tree-node.model'; @Component({ selector: 'ixt-table-tree', templateUrl: './ixt-table-tree.component.html', styleUrls: ['./ixt-table-tree.component.scss'] }) export class IxtTableTreeComponent implements OnInit { @Input() src!: string; @Output() nodesMoved = new EventEmitter<{nodes: TreeNode[], type: string}>(); columns: TableTreeColumn[] = []; flatNodes: TreeNode[] = []; selectedNode: TreeNode | null = null; dropPosition: 'top' | 'bottom' | null = null; private rootNodes: TreeNode[] = []; constructor(private http: HttpClient) {} ngOnInit() { this.loadData(); } private async loadData() { try { const data = await this.http.get<{ items: TreeNodeData[] }>(this.src).toPromise(); if (!data) throw new Error('No data received'); this.detectColumns(data); this.buildTreeStructure(data); this.flattenNodes(); } catch (error) { console.error('Error loading data:', error); } } private detectColumns(data: any) { const sample = data.items[0]; this.columns = Object.keys(sample) .filter(key => key !== 'children' && key !== 'id') .map(key => ({ field: key, header: key.charAt(0).toUpperCase() + key.slice(1), type: this.detectColumnType(sample[key]) })); } private detectColumnType(value: any): 'string' | 'number' | 'date' | 'progress' { if (typeof value === 'number') { return value <= 100 && value >= 0 ? 'progress' : 'number'; } if (!isNaN(Date.parse(value))) return 'date'; return 'string'; } private buildTreeStructure(data: { items: TreeNodeData[] }) { const processNode = (node: TreeNodeData, level: number, parent?: TreeNode): TreeNode => { const treeNode: TreeNode = { id: node.id, level, expanded: true, data: { ...node }, parent }; if (node.children) { treeNode.children = node.children.map(child => processNode(child, level + 1, treeNode) ); } return treeNode; }; this.rootNodes = data.items.map(item => processNode(item, 0)); } private flattenNodes() { this.flatNodes = []; const processNode = (node: TreeNode) => { this.flatNodes.push(node); if (node.expanded && node.children) { node.children.forEach(processNode); } }; this.rootNodes.forEach(processNode); } selectNode(node: TreeNode) { this.selectedNode = node; } toggle(node: TreeNode, event: Event) { event.stopPropagation(); node.expanded = !node.expanded; this.flattenNodes(); } hasChildren(node: TreeNode): boolean { return Boolean(node?.children?.length); } increaseLevel() { // if (!this.selectedNode) return; // Ensure a selected node exists // const index = this.flatNodes.indexOf(this.selectedNode); // if (index <= 0 || this.selectedNode.level === 0) return; // Ensure it's not the first node and is at a valid level // const previousSibling = this.flatNodes[index - 1]; // if (!previousSibling || previousSibling.level !== this.selectedNode.level) return; // Ensure previous sibling exists and is at the same level // const currentParent = this.selectedNode.parent; // if (!currentParent || !Array.isArray(currentParent.children)) return; // Ensure parent and children array exist // // Remove the node from its current parent's children array // currentParent.children = currentParent.children.filter( // child => child && child.id !== this.selectedNode.id // ); // // Add the node to the previous sibling's children array // if (!Array.isArray(previousSibling.children)) { // previousSibling.children = []; // Initialize children array if not already present // } // previousSibling.children.push(this.selectedNode); // // Update the parent and level of the selected node // this.selectedNode.parent = previousSibling; // this.selectedNode.level++; // // Rebuild the flat node structure and emit the change event // this.flattenNodes(); // this.nodesMoved.emit({ nodes: [this.selectedNode], type: 'level-changed' }); } decreaseLevel() { // if (!this.selectedNode || !this.selectedNode.parent) return; // const parentNode = this.selectedNode.parent; // const grandParent = parentNode.parent; // if (grandParent) { // parentNode.children = parentNode.children?.filter( // child => child.id !== this.selectedNode.id // ); // const parentIndex = grandParent.children?.indexOf(parentNode) ?? -1; // if (parentIndex >= 0) { // grandParent.children?.splice(parentIndex + 1, 0, this.selectedNode); // this.selectedNode.parent = grandParent; // this.selectedNode.level--; // this.flattenNodes(); // this.nodesMoved.emit({nodes: [this.selectedNode], type: 'level-changed'}); // } // } } moveUp() { if (!this.selectedNode) return; const index = this.flatNodes.indexOf(this.selectedNode); if (index > 0) { const prevNode = this.flatNodes[index - 1]; if (prevNode.level === this.selectedNode.level) { const parent = this.selectedNode.parent; const siblings = parent?.children ?? this.rootNodes; const nodeIndex = siblings.indexOf(this.selectedNode); if (nodeIndex > 0) { [siblings[nodeIndex - 1], siblings[nodeIndex]] = [siblings[nodeIndex], siblings[nodeIndex - 1]]; this.flattenNodes(); this.nodesMoved.emit({nodes: [this.selectedNode], type: 'reordered'}); } } } } moveDown() { if (!this.selectedNode) return; const index = this.flatNodes.indexOf(this.selectedNode); if (index < this.flatNodes.length - 1) { const nextNode = this.flatNodes[index + 1]; if (nextNode.level === this.selectedNode.level) { const parent = this.selectedNode.parent; const siblings = parent?.children ?? this.rootNodes; const nodeIndex = siblings.indexOf(this.selectedNode); if (nodeIndex < siblings.length - 1) { [siblings[nodeIndex], siblings[nodeIndex + 1]] = [siblings[nodeIndex + 1], siblings[nodeIndex]]; this.flattenNodes(); this.nodesMoved.emit({nodes: [this.selectedNode], type: 'reordered'}); } } } } onDrop(event: any) { const node = event.item.data; const newIndex = event.currentIndex; const oldIndex = event.previousIndex; if (newIndex !== oldIndex) { const parent = this.selectedNode?.parent; const siblings = parent?.children ?? this.rootNodes; siblings.splice(oldIndex, 1); siblings.splice(newIndex, 0, node); this.flattenNodes(); this.nodesMoved.emit({nodes: [node], type: 'dragged'}); } } canMoveUp(): boolean { if (!this.selectedNode) return false; const index = this.flatNodes.indexOf(this.selectedNode); return index > 0 && this.flatNodes[index - 1].level === this.selectedNode.level; } canMoveDown(): boolean { if (!this.selectedNode) return false; const index = this.flatNodes.indexOf(this.selectedNode); return index < this.flatNodes.length - 1 && this.flatNodes[index + 1].level === this.selectedNode.level; } }
    |   |   --- ixt-table-tree.index.ts: <empty file>
    |   |   --- ixt-table-tree.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { HttpClientModule } from '@angular/common/http'; import { IxtTableTreeComponent } from './ixt-table-tree.component'; @NgModule({ declarations: [ IxtTableTreeComponent // Declare the component ], imports: [ CommonModule, // Angular common directives like ngIf, ngFor FormsModule, // Two-way binding with [(ngModel)] HttpClientModule // Include for HttpClient usage in the component ], exports: [ IxtTableTreeComponent // Make the component available to other modules ] }) export class IxtTreeNodeModule { }
    |   |   --- tree-node.model.ts: export interface TreeNode { id: string; level: number; expanded?: boolean; children?: TreeNode[]; data: Record<string, any>; parent?: TreeNode; } export interface TreeNodeData { id: string; children?: TreeNodeData[]; [key: string]: any; } export interface TableTreeColumn { field: string; type: 'string' | 'number' | 'date' | 'progress'; header: string; }
    --- public-api.ts: // public-api.ts //---------------------------------- Core Components & Services ---------------------------------- export { IxtTableModule, IxtTableComponent, AirportCodeEditorComponent, CoordinateEditorComponent, BinaryEditorComponent, TableEditor, ColumnConfigs, EditService, FilterService, SortService, SelectionService, PaginationService } from './components/ixt-table/ixt-table.index'; export { IxtDialogModule, IxtDialogComponent, IxtDialogService } from './components/ixt-dialog/ixt-dialog.index'; export { IxtTabsetModule, IxtTabComponent, IxtTabsetComponent, ITabContent, ITabsetConfig } from './components/ixt-tabset/ixt-tabset.index'; //------------------------------------ Basic UI Components ------------------------------------- export { IxtButtonModule, IxtButtonComponent, ButtonSize } from './components/ixt-button/ixt-button.index'; export { IxtPanelModule, IxtPanelComponent } from './components/ixt-panel/ixt-panel.index'; export { IxtMenuModule, IxtMenuComponent } from './components/ixt-menu/ixt-menu.index'; export { IxtTreeModule, IxtTreeComponent } from './components/ixt-tree/ixt-tree.index'; export { IxtAccordianModule, IxtAccordianComponent } from './components/ixt-accordian/ixt-accordian.index'; //--------------------------------- Canvas & View Components ---------------------------------- export { IxtCanvasModule, IxtCanvasComponent } from './components/ixt-canvas/ixt-canvas.index'; //------------------------------------ Form Components --------------------------------------- export { IxtFormModule, IxtInputModule, IxtSelectModule, IxtTextModule, IxtDateModule, IxtTimeModule, IxtBinaryModule, IxtFormComponent, IxtTextEditor, IxtInputEditor, IxtSelectEditor, IxtDateEditor, IxtTimeEditor, IxtBinaryEditor, FormFieldConfig } from './components/ixt-form/ixt-form.index'; //------------------------------------ Expression Builder Components --------------------------------------- export { IxtExpressionBuilderComponent, IxtExpressionBuilderModule } from './components/ixt-expression-builder/ixt-expression-builder.index'; //----------------------------------- Diagram Components ------------------------------------ export { IxtDiagramModule, IxtDiagramComponent } from './components/ixt-diagram/ixt-diagram.index'; export { IxtClazzDiagram, IxtClazzModule } from './components/ixt-diagram/types/clazz/ixt-clazz.index'; export { IxtDeploymentDiagram, IxtDeploymentModule } from './components/ixt-diagram/types/deployment/ixt-deployment.index'; export { IxtEbnfDiagram, IxtEbnfModule } from './components/ixt-diagram/types/EBNF/ixt-ebnf.index'; export { IxtFlowDiagram, IxtFlowModule } from './components/ixt-diagram/types/flow/ixt-flow.index'; export { IxtGanntDiagram, IxtGanntModule } from './components/ixt-diagram/types/gannt/gannt.index'; export { IxtNetworkDiagram, IxtNetworkModule } from './components/ixt-diagram/types/network/ixt-network.index'; export { IxtSankeyDiagram, IxtSankeyModule } from './components/ixt-diagram/types/sankey/ixt-sankey.index'; export { IxtWireframeDiagram, IxtWireframeModule } from './components/ixt-diagram/types/wireframe/ixt-wireframe.index'; //-------------------------------- Map & Layer Components ---------------------------------- export { IxtMapModule, IxtMapComponent, IxtLayerComponent, MapService, GeoProcessingService, LayerRenderService, LayerEventService, LayerStateService, MapErrorService, RouteProcessorService, MapDimensions, MapState, MapContainer, MapSelection, PathSelection, MapServiceState, LayerEventHandlers, LayerRenderOptions, LayerState, MapError, MapErrorCode, RouteProcessingConfig, GeoFeatureProperties, GeoProcessingOptions, } from './components/ixt-map/ixt-map.index'; //----------------------------- Utility & Layout Components -------------------------------- export { IxtSplitPaneComponent, IxtSplitPaneModule } from './components/ixt-splitpane/index'; export { IxtCalendarComponent, IxtCalendarModule } from './components/ixt-calendar/ixt-calendar.index'; //------------------------------------ Theme Exports -------------------------------------- export { ThemeVariant, ThemeColor, ThemeColors } from './components/theme/theme.types'; export { baseThemeColors, unitedThemeColors } from './components/theme/theme.colors'; export { TableTreeColumn, TreeNode, TreeNodeData, ixt-table-tree.component, ixt-table-tree.module } from './components/ixt-table-tree/ixt-table-tree.index';
