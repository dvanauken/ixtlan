\-- src
    +-- components
    |   +-- ixt-map
    |   |   +-- models
    |   |   |   \-- sphere
    |   |   |       +-- types
    |   |   |       |   --- GeometryCollection.ts: <empty file>
    |   |   |       |   --- LineString.ts: <empty file>
    |   |   |       |   --- MultiLineString.ts: <empty file>
    |   |   |       |   --- MultiPoint.ts: <empty file>
    |   |   |       |   --- MultiPolygon.ts: <empty file>
    |   |   |       |   --- Point.ts: <empty file>
    |   |   |       |   --- Polygon.ts: <empty file>
    |   |   |       --- Angle.ts: <empty file>
    |   |   |       --- Arc.ts: <empty file>
    |   |   |       --- Azimuth.ts: <empty file>
    |   |   |       --- Bearing.ts: <empty file>
    |   |   |       --- Collection.ts: <empty file>
    |   |   |       --- Coordinate.ts: <empty file>
    |   |   |       --- Geodesic.ts: <empty file>
    |   |   |       --- GreatCircle.ts: <empty file>
    |   |   |       --- Horizon.ts: <empty file>
    |   |   |       --- Luxodrome.ts: <empty file>
    |   |   |       --- Nadir.ts: <empty file>
    |   |   |       --- Point.ts: <empty file>
    |   |   |       --- Polygon.ts: <empty file>
    |   |   |       --- Rhumb.ts: <empty file>
    |   |   |       --- SmallCircle.ts: <empty file>
    |   |   |       --- Sphere.ts: <empty file>
    |   |   |       --- Triangle.ts: <empty file>
    |   |   |       --- Zenith.ts: <empty file>
    |   |   +-- types
    |   |   |   +-- azimuthal
    |   |   |   |   +-- gnomic
    |   |   |   |   |   --- gnomic.projection.ts: <empty file>
    |   |   |   |   +-- orthographic
    |   |   |   |   |   --- orthographic.projection.ts: <empty file>
    |   |   |   |   +-- perspective
    |   |   |   |   |   --- perspective.projection.ts: <empty file>
    |   |   |   |   --- azimuthal.projection.ts: <empty file>
    |   |   |   +-- conical
    |   |   |   |   \-- lambert
    |   |   |   |       --- lambert.projection.ts: <empty file>
    |   |   |   \-- cylindrical
    |   |   |       \-- utm
    |   |   |           --- utm.projection.ts: <empty file>
    |   |   --- geo-processing.service.ts: // Create the GeoJSON processing service (geo-processing.service.ts) import { Injectable } from '@angular/core'; import { Feature, LineString, GeoJsonProperties, Geometry } from 'geojson'; import * as d3 from 'd3'; import { GeoFeatureProperties, GeoProcessingOptions } from './geo.types'; @Injectable({ providedIn: 'root' }) export class GeoProcessingService { processFeatures(features: Feature[], options: GeoProcessingOptions = {}): Feature[] { let processedFeatures = [...features]; // Apply route interpolation if needed if (options.interpolateRoutes) { processedFeatures = this.interpolateRoutes(processedFeatures, { pointsPerRoute: options.pointsPerRoute, minPoints: options.minPointsPerRoute }); } // Apply filtering if expression provided if (options.filterExpression) { processedFeatures = this.filterFeatures(processedFeatures, options.filterExpression); } return processedFeatures; } private interpolateRoutes( features: Feature[], options: { pointsPerRoute?: number; minPoints?: number } = {} ): Feature[] { const minPoints = options.minPoints || 5; return features.map(feature => { if (feature.geometry.type !== 'LineString') { return feature; } const line = feature.geometry as LineString; const coordinates = line.coordinates; if (coordinates.length !== 2) { return feature; } const start = coordinates[0] as [number, number]; const end = coordinates[1] as [number, number]; const route = d3.geoInterpolate(start, end); // Calculate distance and points const distance = d3.geoDistance(start, end) * 3959; // Earth radius in miles const pointsPer5Miles = Math.ceil(distance / 5); const numPoints = Math.max(minPoints, options.pointsPerRoute || pointsPer5Miles); const newCoordinates = Array.from({ length: numPoints }, (_, i) => { const t = i / (numPoints - 1); return route(t); }); return { ...feature, geometry: { ...line, coordinates: newCoordinates } }; }); } private filterFeatures(features: Feature[], expression: string): Feature[] { const filterFn = this.createFilterFunction(expression); return features.filter(feature => { try { return filterFn ? filterFn(feature) : true; } catch (e) { console.error('Error applying filter to feature:', e); return true; } }); } private createFilterFunction(expression: string): Function | null { if (!expression) return null; try { return new Function('feature', ` try { const properties = feature.properties; return ${expression}; } catch (e) { console.error('Filter expression error:', e); return true; } `); } catch (e) { console.error('Error creating filter function:', e); return null; } } // private createFilterFunction(): Function | null { // if (!this.filterExpression) return null; // console.log('Creating filter with expression:', this.filterExpression); // return new Function('feature', ` // try { // const properties = feature.properties; // //console.log('Evaluating:', properties); // return ${this.filterExpression}; // } catch (e) { // console.error('Filter expression error:', e); // return true; // If there's an error, include the feature // } // `); // } }
    |   |   --- geo.types.ts: // First, let's create the interfaces (geo.types.ts) export interface GeoFeatureProperties { [key: string]: any; } export interface GeoProcessingOptions { interpolateRoutes?: boolean; pointsPerRoute?: number; minPointsPerRoute?: number; filterExpression?: string; }
    |   |   --- ixt-layer.component.ts: import { Component, Input, Output, EventEmitter, ElementRef, Host, ChangeDetectionStrategy, ChangeDetectorRef, SimpleChanges } from '@angular/core'; import * as d3 from 'd3'; import { IxtMapComponent } from './ixt-map.component'; import { GeoProcessingService } from './geo-processing.service'; import { LayerRenderService } from './layer-render.service'; import { LayerEventHandlers, LayerEventService } from './layer-event.service'; import { LayerStateService } from './layer-state.service'; import { Feature } from 'geojson'; @Component({ selector: 'ixt-layer', template: ` <svg:g> <ng-content></ng-content> </svg:g> `, changeDetection: ChangeDetectionStrategy.OnPush }) export class IxtLayerComponent { @Input() src: string = ''; @Input() stroke: string = 'black'; @Input() fill: string = 'none'; @Output() click = new EventEmitter<MouseEvent>(); @Output() hover = new EventEmitter<MouseEvent>(); private initialized = false; private pathGenerator!: d3.GeoPath; private filterExpression: string = ''; constructor( @Host() private mapComponent: IxtMapComponent, private elementRef: ElementRef, private cdr: ChangeDetectorRef, private geoProcessingService: GeoProcessingService, private layerRenderService: LayerRenderService, private layerEventService: LayerEventService, private layerStateService: LayerStateService ) { } ngOnChanges(changes: SimpleChanges) { if ((changes['src'] || changes['stroke'] || changes['fill']) && this.initialized) { this.initializeLayer(); } } ngAfterContentInit() { const content = this.elementRef.nativeElement.textContent?.trim(); if (content) { this.filterExpression = content; } } setProjection(pathGenerator: d3.GeoPath): void { this.pathGenerator = pathGenerator; this.initializeLayer(); } async initializeLayer(): Promise<void> { if (this.initialized) return; if (!this.validateContainer()) return; try { const features = await this.loadGeoJsonData(); const handlers = this.createEventHandlers(); this.renderLayer(features, handlers); this.initialized = true; } catch (error) { console.error('Layer initialization failed:', error); } } private validateContainer(): boolean { const container = this.mapComponent.getContainer(); if (!container || !this.pathGenerator) { console.error('Map container or projection not ready'); return false; } return true; } private async loadGeoJsonData(): Promise<Feature[]> { const data = await d3.json(this.src) as { features: Feature[] }; return this.geoProcessingService.processFeatures(data.features, { interpolateRoutes: true, filterExpression: this.filterExpression }); } private async renderLayer(features: any, handlers: any): Promise<void> { const container = this.mapComponent.getContainer(); const selection = this.layerRenderService.createLayer( d3.select(container.nativeElement), features, { stroke: this.stroke, fill: this.fill }, handlers ); this.layerStateService.addSelection(selection); this.cdr.markForCheck(); } private createEventHandlers(): LayerEventHandlers { return { onClick: (event: MouseEvent, datum: any) => { this.layerEventService.handleClick(event, this.mapComponent); this.click.emit(event); }, onMouseOver: (event: MouseEvent) => { this.layerEventService.handleMouseOver(event, this.mapComponent); this.hover.emit(event); }, onMouseOut: () => this.layerEventService.handleMouseOut(), onMouseMove: (event: MouseEvent) => event.stopPropagation() }; } ngOnDestroy(): void { this.layerStateService.clearSelections(); } }
    |   |   --- ixt-layer.module.ts: // src/components/ixt-map/layer/ixt-layer.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtLayerComponent } from './ixt-layer.component'; @NgModule({ declarations: [ IxtLayerComponent ], imports: [ CommonModule ], exports: [ IxtLayerComponent ] }) export class IxtLayerModule { }
    |   |   --- ixt-map.component.ts: import { Component, Input, ViewChild, ElementRef, ContentChildren, QueryList, AfterContentInit, OnDestroy, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core'; import * as d3 from 'd3'; import { IxtLayerComponent } from './ixt-layer.component'; import { GeoProjection, GeoPath } from 'd3'; import { BehaviorSubject, Subscription } from 'rxjs'; import { MapService } from './map.service'; import { MapDimensions, MapSelection, PathSelection, MapContainer } from './map.types'; @Component({ selector: 'ixt-map', template: ` <svg #mapSvg [attr.width]="width" [attr.height]="height" [attr.viewBox]="getViewBox()" style="display: block; background: lightgray;"> <g #mapGroup> <ng-content></ng-content> </g> </svg> `, styles: [` :host { display: block; } svg { display: block; } `], changeDetection: ChangeDetectionStrategy.OnPush }) export class IxtMapComponent implements AfterContentInit, OnDestroy { @Input() width: string | number = 800; @Input() height: string | number = 600; @Input() scale: string | number = 1; @Input() translate: string = '0,0'; @ViewChild('mapSvg') mapSvg!: ElementRef<SVGSVGElement>; @ViewChild('mapGroup') mapGroup!: MapContainer; @ContentChildren(IxtLayerComponent) layers!: QueryList<IxtLayerComponent>; private projection!: GeoProjection; private pathGenerator!: GeoPath; private selectedElement: SVGPathElement | null = null; private mapSubscriptions = new Subscription(); private projectionReady = new BehaviorSubject<boolean>(false); projectionReady$ = this.projectionReady.asObservable(); constructor( private cdr: ChangeDetectorRef, private mapService: MapService ) {} private getDimensions(): MapDimensions { return { width: this.mapService.getBaseDimension(this.width), height: this.mapService.getBaseDimension(this.height), scale: Number(this.scale), translate: this.translate }; } getViewBox(): string { const { width, height } = this.getDimensions(); return `0 0 ${width} ${height}`; } private initializeMap(): void { const dimensions = this.getDimensions(); const { projection, pathGenerator } = this.mapService.initializeProjection( dimensions.width, dimensions.height ); this.projection = projection; this.pathGenerator = pathGenerator; this.projectionReady.next(true); if (this.mapGroup) { const mapSelection = d3.select<SVGGElement, unknown>(this.mapGroup.nativeElement); mapSelection.on('click', () => this.clearSelection()); } setTimeout(() => { this.layers.forEach(layer => { layer.setProjection(this.pathGenerator); }); }); } getContainer(): MapContainer { return this.mapGroup; } getPathGenerator(): GeoPath { return this.pathGenerator; } clearSelection(): void { if (this.selectedElement) { d3.select<SVGPathElement, unknown>(this.selectedElement) .attr('stroke', function(this: SVGPathElement) { return this.getAttribute('data-original-stroke') || ''; }) .attr('stroke-width', '1'); this.selectedElement = null; this.cdr.markForCheck(); } } setSelection(element: SVGPathElement | null): void { this.clearSelection(); if (element) { this.selectedElement = element; this.cdr.markForCheck(); } } ngAfterContentInit(): void { this.initializeMap(); this.mapSubscriptions.add( this.layers.changes.subscribe(() => { this.initializeMap(); this.cdr.markForCheck(); }) ); } ngOnDestroy(): void { this.mapSubscriptions.unsubscribe(); this.selectedElement = null; this.projection = null as any; this.pathGenerator = null as any; } }
    |   |   --- ixt-map.index.ts: // map.types.ts import { GeoProjection, GeoPath } from 'd3'; import { ElementRef } from '@angular/core'; export interface MapDimensions { width: number; height: number; scale: number; translate: string; } export interface MapState { projection: GeoProjection; pathGenerator: GeoPath; dimensions: MapDimensions; } export interface MapSelection extends d3.Selection<SVGGElement, unknown, null, undefined> {} export interface PathSelection extends d3.Selection<SVGPathElement, unknown, null, undefined> {} export interface MapContainer extends ElementRef<SVGGElement> {} // Move interface from map.service.ts here export interface MapServiceState { selectedElement: SVGPathElement | null; dimensions: MapDimensions; }
    |   |   --- ixt-map.module.ts: // ixt-map.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtMapComponent } from './ixt-map.component'; import { IxtLayerComponent } from './ixt-layer.component'; import { GeoProcessingService } from './geo-processing.service'; import { LayerEventService } from './layer-event.service'; import { LayerRenderService } from './layer-render.service'; import { LayerStateService } from './layer-state.service'; import { MapErrorService } from './map-error.service'; import { MapService } from './map.service'; import { RouteProcessorService } from './route-processor.service'; @NgModule({ declarations: [ IxtMapComponent, IxtLayerComponent ], imports: [ CommonModule ], exports: [ IxtMapComponent, IxtLayerComponent ], providers: [ MapService, GeoProcessingService, LayerRenderService, LayerEventService, LayerStateService, MapErrorService, RouteProcessorService ] }) export class IxtMapModule { }
    |   |   --- layer-event.service.ts: // layer-event.service.ts import { Injectable } from '@angular/core'; import { MapService } from './map.service'; import * as d3 from 'd3'; export interface LayerEventHandlers { onClick: (event: MouseEvent, datum: any) => void; onMouseOver: (event: MouseEvent) => void; onMouseOut: () => void; onMouseMove: (event: MouseEvent) => void; } @Injectable({ providedIn: 'root' }) export class LayerEventService { private hoveredElement: SVGPathElement | null = null; constructor(private mapService: MapService) {} handleClick(event: MouseEvent, mapRef: any): void { event.stopPropagation(); const clickedPath = event.currentTarget as SVGPathElement; if (clickedPath === mapRef['selectedElement']) { mapRef.setSelection(null); this.applyHoverEffect(clickedPath, false); } else { if (mapRef['selectedElement']) { this.applyHoverEffect(mapRef['selectedElement'], false); } mapRef.setSelection(clickedPath); this.applyHoverEffect(clickedPath, true); } } handleMouseOver(event: MouseEvent, mapRef: any): void { event.stopPropagation(); const currentPath = event.currentTarget as SVGPathElement; if (currentPath !== mapRef['selectedElement']) { this.applyHoverEffect(currentPath, true); this.hoveredElement = currentPath; } } handleMouseOut(): void { if (this.hoveredElement) { this.clearHoverState(this.hoveredElement); this.hoveredElement = null; } } private applyHoverEffect(element: SVGPathElement, isHover: boolean): void { const d3Element = d3.select(element); const currentFill = element.getAttribute('data-original-fill'); if (currentFill && currentFill !== 'none') { d3Element .attr('fill', currentFill) .attr('stroke-width', isHover ? '2' : '1'); } else { d3Element.attr('stroke-width', isHover ? '2' : '1'); } } private clearHoverState(element: SVGPathElement): void { const d3Element = d3.select(element); const originalFill = element.getAttribute('data-original-fill'); d3Element .attr('fill', originalFill) .attr('stroke-width', '1'); } }
    |   |   --- layer-render.service.ts: // layer-render.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { Feature, GeoJsonProperties, Geometry } from 'geojson'; import { MapService } from './map.service'; export interface LayerRenderOptions { stroke: string; fill: string; } @Injectable({ providedIn: 'root' }) export class LayerRenderService { constructor(private mapService: MapService) {} createLayer( container: d3.Selection<any, any, any, any>, features: Feature[], options: LayerRenderOptions, eventHandlers: { onClick: (event: MouseEvent, datum: any) => void; onMouseOver: (event: MouseEvent) => void; onMouseOut: (event: MouseEvent) => void; onMouseMove: (event: MouseEvent) => void; } ): d3.Selection<any, any, any, any> { const layerGroup = container .append('g') .attr('class', 'map-layer'); return layerGroup .selectAll('path') .data(features) .enter() .append('path') .attr('d', (datum) => this.mapService.getPathGenerator()(datum) || '') .attr('stroke', options.stroke) .attr('fill', options.fill) .attr('stroke-width', '1') .attr('data-original-fill', options.fill) .attr('data-original-stroke', options.stroke) .attr('vector-effect', 'non-scaling-stroke') .style('cursor', 'pointer') .on('click', eventHandlers.onClick) .on('mouseover', eventHandlers.onMouseOver) .on('mouseout', eventHandlers.onMouseOut) .on('mousemove', eventHandlers.onMouseMove); } }
    |   |   --- layer-state.service.ts: // layer-state.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; export interface LayerState { hoveredElement: SVGPathElement | null; selections: d3.Selection<any, any, any, any>[]; } @Injectable({ providedIn: 'root' }) export class LayerStateService { private state = new BehaviorSubject<LayerState>({ hoveredElement: null, selections: [] }); state$ = this.state.asObservable(); setHoveredElement(element: SVGPathElement | null): void { this.updateState({ hoveredElement: element }); } addSelection(selection: d3.Selection<any, any, any, any>): void { const currentState = this.state.value; this.updateState({ selections: [...currentState.selections, selection] }); } clearSelections(): void { const currentState = this.state.value; currentState.selections.forEach(selection => { if (selection && !selection.empty()) { selection.remove(); } }); this.updateState({ selections: [] }); } private updateState(partialState: Partial<LayerState>): void { this.state.next({ ...this.state.value, ...partialState }); } ngOnDestroy(): void { this.clearSelections(); this.state.complete(); } }
    |   |   --- map-error.service.ts: // map-error.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; export interface MapError { code: MapErrorCode; message: string; timestamp: Date; context?: any; } export enum MapErrorCode { INITIALIZATION_FAILED = 'INIT_FAILED', PROJECTION_FAILED = 'PROJ_FAILED', DATA_LOAD_FAILED = 'DATA_LOAD_FAILED', SELECTION_FAILED = 'SELECT_FAILED', INVALID_DIMENSIONS = 'INVALID_DIMS' } @Injectable({ providedIn: 'root' }) export class MapErrorService { private errorSubject = new BehaviorSubject<MapError | null>(null); private retryAttemptsMap = new Map<string, number>(); readonly maxRetryAttempts = 3; readonly errors$ = this.errorSubject.asObservable(); reportError(code: MapErrorCode, message: string, context?: any): void { const error: MapError = { code, message, timestamp: new Date(), context }; this.errorSubject.next(error); console.error(`Map Error [${code}]:`, message, context); } clearError(): void { this.errorSubject.next(null); } shouldRetry(operationKey: string): boolean { const attempts = this.retryAttemptsMap.get(operationKey) || 0; if (attempts < this.maxRetryAttempts) { this.retryAttemptsMap.set(operationKey, attempts + 1); return true; } return false; } resetRetryCount(operationKey: string): void { this.retryAttemptsMap.delete(operationKey); } }
    |   |   --- map.service.ts: // map.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { GeoProjection, GeoPath } from 'd3'; import { BehaviorSubject, Observable } from 'rxjs'; import { MapError, MapErrorCode, MapErrorService } from './map-error.service'; export interface MapDimensions { width: number; height: number; } export interface MapState { projection: GeoProjection; pathGenerator: GeoPath; dimensions: MapDimensions; } @Injectable({ providedIn: 'root' }) export class MapService { private projection!: GeoProjection; private pathGenerator!: GeoPath; private selectedElementSource = new BehaviorSubject<SVGPathElement | null>(null); private dimensions = new BehaviorSubject<MapDimensions>({ width: 800, height: 600 }); readonly selectedElement$ = this.selectedElementSource.asObservable(); readonly dimensions$ = this.dimensions.asObservable(); private errorSubject = new BehaviorSubject<MapError | null>(null); private retryAttemptsMap = new Map<string, number>(); readonly maxRetryAttempts = 3; readonly errors$ = this.errorSubject.asObservable(); constructor(private errorService: MapErrorService) {} initializeProjection(width: number, height: number): { projection: GeoProjection; pathGenerator: d3.GeoPath } { try { if (width <= 0 || height <= 0) { throw new Error('Invalid dimensions'); } this.projection = d3.geoMercator() .fitSize([width, height], { type: 'Sphere' }); this.pathGenerator = d3.geoPath().projection(this.projection); return { projection: this.projection, pathGenerator: this.pathGenerator }; } catch (error) { this.errorService.reportError( MapErrorCode.INITIALIZATION_FAILED, 'Failed to initialize map projection', { width, height, error } ); throw error; } } getProjection(): GeoProjection { return this.projection; } getPathGenerator(): GeoPath { return this.pathGenerator; } getDimensions(): MapDimensions { return this.dimensions.value; } setSelection(element: SVGPathElement | null): void { const previousElement = this.selectedElementSource.value; if (previousElement) { d3.select(previousElement) .attr('stroke', d3.select(previousElement).attr('data-original-stroke')) .attr('stroke-width', '1'); } this.selectedElementSource.next(element); } clearSelection(): void { this.setSelection(null); } getBaseDimension(value: string | number): number { if (typeof value === 'number') return value; const num = parseFloat(value); return isNaN(num) ? 800 : num; } reportError(code: MapErrorCode, message: string, context?: any): void { const error: MapError = { code, message, timestamp: new Date(), context }; this.errorSubject.next(error); console.error(`Map Error [${code}]:`, message, context); } clearError(): void { this.errorSubject.next(null); } shouldRetry(operationKey: string): boolean { const attempts = this.retryAttemptsMap.get(operationKey) || 0; if (attempts < this.maxRetryAttempts) { this.retryAttemptsMap.set(operationKey, attempts + 1); return true; } return false; } resetRetryCount(operationKey: string): void { this.retryAttemptsMap.delete(operationKey); } }
    |   |   --- map.types.ts: // map.types.ts import { GeoProjection, GeoPath } from 'd3'; import { ElementRef } from '@angular/core'; export interface MapDimensions { width: number; height: number; scale: number; translate: string; } export interface MapState { projection: GeoProjection; pathGenerator: GeoPath; dimensions: MapDimensions; } export interface MapSelection extends d3.Selection<SVGGElement, unknown, null, undefined> {} export interface PathSelection extends d3.Selection<SVGPathElement, unknown, null, undefined> {} export interface MapContainer extends ElementRef<SVGGElement> {} // Move interface from map.service.ts here export interface MapServiceState { selectedElement: SVGPathElement | null; dimensions: MapDimensions; }
    |   |   --- route-processor.service.ts: // route-processor.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { Feature, LineString, GeoJsonProperties } from 'geojson'; export interface RouteProcessingConfig { pointsPerMile?: number; minPoints?: number; earthRadiusMiles?: number; } const DEFAULT_CONFIG: RouteProcessingConfig = { pointsPerMile: 0.2, // 1 point every 5 miles minPoints: 5, earthRadiusMiles: 3959 }; @Injectable({ providedIn: 'root' }) export class RouteProcessorService { private config: RouteProcessingConfig; constructor() { this.config = DEFAULT_CONFIG; } setConfig(config: Partial<RouteProcessingConfig>): void { this.config = { ...DEFAULT_CONFIG, ...config }; } interpolateRoute(feature: Feature<LineString, GeoJsonProperties>): Feature<LineString, GeoJsonProperties> { const line = feature.geometry; const coordinates = line.coordinates; if (coordinates.length !== 2) { return feature; } const start = coordinates[0] as [number, number]; const end = coordinates[1] as [number, number]; const route = d3.geoInterpolate(start, end); const distance = d3.geoDistance(start, end) * this.config.earthRadiusMiles!; const numPoints = Math.max( this.config.minPoints!, Math.ceil(distance * this.config.pointsPerMile!) ); const newCoordinates = Array.from({ length: numPoints }, (_, i) => { const t = i / (numPoints - 1); return route(t); }); return { ...feature, geometry: { ...line, coordinates: newCoordinates } }; } calculateRouteDistance(coordinates: [number, number][]): number { if (coordinates.length < 2) return 0; return coordinates.reduce((total, coord, i) => { if (i === 0) return 0; const distance = d3.geoDistance(coordinates[i - 1], coord) * this.config.earthRadiusMiles!; return total + distance; }, 0); } }
    |   +-- ixt-menu
    |   |   --- ixt-menu.component.ts: import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { baseThemeColors, unitedThemeColors } from '../theme/theme.colors'; import { ThemeVariant, ThemeColors } from '../theme/theme.types'; interface MenuItem { name: string; link: string; } interface MenuConfig { items: MenuItem[]; } @Component({ selector: 'ixt-menu', templateUrl: './ixt-menu.component.html', styleUrls: ['./ixt-menu.component.scss'] }) export class IxtMenuComponent implements OnInit { @Input() linkAlignment: string = 'start'; @Input() src: string = ''; @Input() brandName: string = ''; @Input() brandLogo?: string; @Input() brandLink: string = '/'; @Input() showSearch: boolean = false; @Input() searchPlaceholder: string = 'Search...'; // Theme inputs @Input() variant: ThemeVariant = 'tertiary'; @Input() theme: ThemeColors = unitedThemeColors; @Output() searchSubmitted = new EventEmitter<string>(); menuItems: MenuItem[] = []; searchTerm: string = ''; get themeStyles() { const colors = this.theme[this.variant]; return { 'background-color': colors.base, 'color': colors.text, '--theme-hover': colors.hover, '--theme-active': colors.active }; } constructor(private http: HttpClient) { } ngOnInit(): void { if (this.src) { this.loadMenu(); } } loadMenu() { this.http.get<MenuConfig>(this.src).subscribe({ next: (data) => { this.menuItems = data.items; }, error: (error) => { console.error('Error loading menu:', error); } }); } onSearch(event: Event) { event.preventDefault(); if (this.searchTerm.trim()) { this.searchSubmitted.emit(this.searchTerm); } } }
    |   |   --- ixt-menu.index.ts: // ixt-menu.index.ts export * from './ixt-menu.component'; export * from './ixt-menu.module'; export interface MenuItem { name: string; link: string; } export interface MenuConfig { items: MenuItem[]; brandName?: string; brandLogo?: string; brandLink?: string; showSearch?: boolean; searchPlaceholder?: string; linkAlignment?: 'start' | 'center' | 'end'; }
    |   |   --- ixt-menu.model.ts: <empty file>
    |   |   --- ixt-menu.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { RouterModule } from '@angular/router'; import { IxtMenuComponent } from './ixt-menu.component'; @NgModule({ declarations: [ IxtMenuComponent ], imports: [ CommonModule, FormsModule, RouterModule ], exports: [ IxtMenuComponent ] }) export class IxtMenuModule { }
    |   +-- ixt-panel
    |   |   --- ixt-panel.component.ts: import { Component, Input } from '@angular/core'; @Component({ selector: 'ixt-panel', templateUrl: './ixt-panel.component.html', styleUrls: ['./ixt-panel.component.scss'] }) export class IxtPanelComponent { @Input() title?: string; @Input() caption?: string; @Input() padding = true; @Input() bordered = true; @Input() elevated = false; }
    |   |   --- ixt-panel.index.ts: export * from './ixt-panel.component'; export * from './ixt-panel.module';
    |   |   --- ixt-panel.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtPanelComponent } from './ixt-panel.component'; @NgModule({ declarations: [ IxtPanelComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtPanelComponent ] }) export class IxtPanelModule { }
    |   +-- ixt-progress
    |   |   +-- types
    |   |   |   +-- composite
    |   |   |   |   --- composite.progress.ts: <empty file>
    |   |   |   +-- determinate
    |   |   |   |   --- determinite.progress.ts: <empty file>
    |   |   |   \-- indeterminite
    |   |   |       --- indeterminate.progress.ts: <empty file>
    |   |   --- ixt-progress.component.ts: // progress.component.ts import { Component, Input, Output, EventEmitter, OnInit, OnDestroy } from '@angular/core'; import { ProgressService } from './progress.service'; import { Subject } from 'rxjs'; import { takeUntil } from 'rxjs/operators'; import { BaseProgressConfig, ProgressState } from './progress.types'; @Component({ selector: 'app-progress', templateUrl: './ixt-progress.component.html', styleUrls: ['./ixt-progress.component.scss'] }) export class ProgressComponent implements OnInit, OnDestroy { @Input() config!: BaseProgressConfig; @Output() progressChange = new EventEmitter<ProgressState>(); @Output() completed = new EventEmitter<void>(); @Output() cancelled = new EventEmitter<void>(); @Output() error = new EventEmitter<Error>(); private destroy$ = new Subject<void>(); constructor(private progressService: ProgressService) {} ngOnInit(): void { this.initializeProgress(); this.subscribeToProgress(); } private initializeProgress(): void { try { this.validateConfig(); this.progressService.start(this.config); } catch (error) { this.handleError(error as Error); } } private validateConfig(): void { if (!this.config) { throw new Error('Progress configuration is required'); } // Add more validation as needed } private subscribeToProgress(): void { this.progressService.progress$ .pipe(takeUntil(this.destroy$)) .subscribe({ next: (state) => { this.progressChange.emit(state); if (state.status === ProgressStatus.COMPLETED) { this.handleCompletion(); } }, error: (error) => this.handleError(error) }); } private handleCompletion(): void { this.completed.emit(); if (this.config.autoClose) { setTimeout(() => { this.destroy(); }, this.config.autoCloseDelay || 1000); } } private handleError(error: Error): void { this.error.emit(error); if (this.config.onError) { this.config.onError(error); } } pause(): void { if (this.config.pausable) { this.progressService.pause(); } } resume(): void { this.progressService.resume(); } cancel(): void { if (this.config.cancelable) { this.progressService.cancel(); this.cancelled.emit(); if (this.config.onCancel) { this.config.onCancel(); } } } ngOnDestroy(): void { this.destroy(); } private destroy(): void { this.destroy$.next(); this.destroy$.complete(); this.progressService.destroy(); } } // adaptive-estimator.ts class AdaptiveEstimator { private readonly history: ProgressHistoryEntry[]; private readonly config: HistoricalConfig; private readonly similarityThreshold: number = 0.2; constructor(history: ProgressHistoryEntry[], config: HistoricalConfig) { this.history = history; this.config = config; } estimate(elapsedTime: number): { progress: number; remaining: number } { const similarRuns = this.findSimilarRuns(); if (similarRuns.length === 0) { return this.fallbackEstimate(elapsedTime); } return this.calculateEstimate(similarRuns, elapsedTime); } private findSimilarRuns(): ProgressHistoryEntry[] { return this.history.filter(entry => { const sizeSimilarity = Math.abs(entry.dataSize - this.config.dataSize) / this.config.dataSize; const complexitySimilarity = this.config.complexityFactor && entry.complexityFactor ? Math.abs(entry.complexityFactor - this.config.complexityFactor) / this.config.complexityFactor : 0; return sizeSimilarity <= this.similarityThreshold && complexitySimilarity <= this.similarityThreshold && entry.success; }); } private calculateEstimate(similarRuns: ProgressHistoryEntry[], elapsedTime: number): { progress: number; remaining: number } { const averageDuration = similarRuns.reduce((acc, run) => acc + run.duration, 0) / similarRuns.length; const progress = Math.min((elapsedTime / averageDuration) * 100, 100); const remaining = Math.max(averageDuration - elapsedTime, 0); return { progress, remaining }; } private fallbackEstimate(elapsedTime: number): { progress: number; remaining: number } { const estimatedTotal = this.config.averageTime; const progress = Math.min((elapsedTime / estimatedTotal) * 100, 100); const remaining = Math.max(estimatedTotal - elapsedTime, 0); return { progress, remaining }; } }
    |   |   --- ixt-progress.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtProgressComponent } from './ixt-progress.component'; @NgModule({ declarations: [ IxtProgressComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtProgressComponent ] }) export class IxtTableModule { }
    |   |   --- progress.service.ts: // progress.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable, Subject, timer } from 'rxjs'; import { takeUntil, map, filter } from 'rxjs/operators'; import { BaseProgressConfig, FixedDurationConfig, HistoricalConfig, IndeterminateConfig, ProgressHistoryEntry, ProgressMode, ProgressState, ProgressStatus, StepsConfig } from './progress.types'; @Injectable({ providedIn: 'root' }) export class ProgressService { private progressSubject = new BehaviorSubject<ProgressState>({ status: ProgressStatus.IDLE, progress: 0, elapsedTime: 0, estimatedTimeRemaining: null }); private destroySubject = new Subject<void>(); private startTime: number = 0; private historyCache: Map<string, ProgressHistoryEntry[]> = new Map(); progress$ = this.progressSubject.asObservable(); start(config: BaseProgressConfig): void { this.startTime = Date.now(); this.initializeProgress(config); } private initializeProgress(config: BaseProgressConfig): void { switch (config.mode) { case ProgressMode.FIXED_DURATION: this.handleFixedDuration(config as FixedDurationConfig); break; case ProgressMode.STEPS_BASED: this.handleStepsBased(config as StepsConfig); break; case ProgressMode.INDETERMINATE: this.handleIndeterminate(config as IndeterminateConfig); break; case ProgressMode.HISTORICAL: this.handleHistorical(config as HistoricalConfig); break; } } private handleFixedDuration(config: FixedDurationConfig): void { const updateInterval = config.updateInterval || 100; const smoothing = config.smoothing !== false; timer(0, updateInterval) .pipe( takeUntil(this.destroySubject), map(() => { const elapsed = Date.now() - this.startTime; const rawProgress = Math.min((elapsed / config.totalDuration) * 100, 100); return smoothing ? this.smoothProgress(rawProgress) : rawProgress; }), filter(progress => progress <= 100) ) .subscribe(progress => { this.updateProgress({ status: progress === 100 ? ProgressStatus.COMPLETED : ProgressStatus.RUNNING, progress, elapsedTime: Date.now() - this.startTime, estimatedTimeRemaining: this.calculateTimeRemaining(progress, config.totalDuration) }); }); } private handleStepsBased(config: StepsConfig): void { // Implementation for steps-based progress if (config.bytesLoaded !== undefined && config.totalBytes) { this.updateProgress({ status: ProgressStatus.RUNNING, progress: (config.bytesLoaded / config.totalBytes) * 100, currentStep: config.currentStep, elapsedTime: Date.now() - this.startTime, estimatedTimeRemaining: this.estimateTimeFromBytes(config.bytesLoaded, config.totalBytes) }); } else { this.updateProgress({ status: ProgressStatus.RUNNING, progress: ((config.currentStep || 0) / config.totalSteps) * 100, currentStep: config.currentStep, elapsedTime: Date.now() - this.startTime, estimatedTimeRemaining: null }); } } private handleIndeterminate(config: IndeterminateConfig): void { if (config.statusMessages?.length) { timer(0, config.messageRotationInterval || 3000) .pipe(takeUntil(this.destroySubject)) .subscribe(tick => { const messageIndex = tick % config.statusMessages.length; this.updateProgress({ status: ProgressStatus.RUNNING, progress: -1, elapsedTime: Date.now() - this.startTime, estimatedTimeRemaining: null, currentMessage: config.statusMessages[messageIndex] }); }); } } private handleHistorical(config: HistoricalConfig): void { const historicalData = this.getHistoricalData(config); if (config.adaptiveEstimation && historicalData.length > 0) { this.startAdaptiveEstimation(config, historicalData); } else { this.startBasicEstimation(config); } } private startAdaptiveEstimation(config: HistoricalConfig, history: ProgressHistoryEntry[]): void { const estimator = new AdaptiveEstimator(history, config); timer(0, 1000) .pipe(takeUntil(this.destroySubject)) .subscribe(() => { const estimation = estimator.estimate(Date.now() - this.startTime); this.updateProgress({ status: ProgressStatus.RUNNING, progress: estimation.progress, elapsedTime: Date.now() - this.startTime, estimatedTimeRemaining: estimation.remaining }); }); } private smoothProgress(rawProgress: number): number { // Implement smoothing algorithm (e.g., exponential moving average) return rawProgress; } private calculateTimeRemaining(progress: number, totalDuration: number): number { if (progress === 0) return totalDuration; const elapsed = Date.now() - this.startTime; return (elapsed / progress) * (100 - progress); } private estimateTimeFromBytes(loaded: number, total: number): number { const elapsed = Date.now() - this.startTime; const bytesPerMs = loaded / elapsed; return (total - loaded) / bytesPerMs; } private updateProgress(state: Partial<ProgressState>): void { this.progressSubject.next({ ...this.progressSubject.getValue(), ...state }); } pause(): void { if (this.progressSubject.getValue().status === ProgressStatus.RUNNING) { this.updateProgress({ status: ProgressStatus.PAUSED }); this.destroySubject.next(); } } resume(): void { if (this.progressSubject.getValue().status === ProgressStatus.PAUSED) { this.startTime = Date.now() - this.progressSubject.getValue().elapsedTime; this.updateProgress({ status: ProgressStatus.RUNNING }); } } cancel(): void { this.updateProgress({ status: ProgressStatus.CANCELLED }); this.destroy(); } destroy(): void { this.destroySubject.next(); this.destroySubject.complete(); } private getHistoricalData(config: HistoricalConfig): ProgressHistoryEntry[] { const cacheKey = this.generateCacheKey(config); return this.historyCache.get(cacheKey) || []; } private generateCacheKey(config: HistoricalConfig): string { return `${config.dataSize}-${config.complexityFactor || 1}`; } }
    |   |   --- progress.types.ts: // progress.types.ts export enum ProgressMode { FIXED_DURATION = 'FIXED_DURATION', STEPS_BASED = 'STEPS_BASED', INDETERMINATE = 'INDETERMINATE', HISTORICAL = 'HISTORICAL' } export enum DisplayMode { EMBEDDED = 'EMBEDDED', MODAL = 'MODAL' } export enum ProgressStatus { IDLE = 'IDLE', RUNNING = 'RUNNING', PAUSED = 'PAUSED', COMPLETED = 'COMPLETED', ERROR = 'ERROR', CANCELLED = 'CANCELLED' } export interface BaseProgressConfig { mode: ProgressMode; displayMode: DisplayMode; title?: string; description?: string; theme?: 'light' | 'dark' | 'system'; cancelable?: boolean; pausable?: boolean; autoClose?: boolean; autoCloseDelay?: number; showPercentage?: boolean; showTimeRemaining?: boolean; showElapsedTime?: boolean; errorRetryCount?: number; onComplete?: () => void; onError?: (error: Error) => void; onCancel?: () => void; } export interface FixedDurationConfig extends BaseProgressConfig { mode: ProgressMode.FIXED_DURATION; totalDuration: number; startTime?: number; smoothing?: boolean; updateInterval?: number; } export interface StepsConfig extends BaseProgressConfig { mode: ProgressMode.STEPS_BASED; totalSteps: number; currentStep?: number; stepLabels?: string[]; stepDescriptions?: string[]; bytesLoaded?: number; totalBytes?: number; showStepDetails?: boolean; } export interface IndeterminateConfig extends BaseProgressConfig { mode: ProgressMode.INDETERMINATE; statusMessages?: string[]; spinnerType?: 'circular' | 'linear' | 'pulse'; messageRotationInterval?: number; showSpinner?: boolean; } export interface HistoricalConfig extends BaseProgressConfig { mode: ProgressMode.HISTORICAL; averageTime: number; dataSize: number; complexityFactor?: number; previousRuns?: ProgressHistoryEntry[]; adaptiveEstimation?: boolean; confidenceThreshold?: number; } export interface ProgressHistoryEntry { timestamp: number; duration: number; dataSize: number; complexityFactor?: number; success: boolean; } export interface ProgressState { status: ProgressStatus; progress: number; elapsedTime: number; estimatedTimeRemaining: number | null; currentStep?: number; currentMessage?: string; error?: Error; }
    |   +-- ixt-splitpane
    |   |   --- index.ts: // public-api.ts (or index.ts) export * from './ixt-split-pane.component'; export * from './ixt-split-pane.module';
    |   |   --- ixt-split-pane.component.ts: import { Component, ElementRef, HostListener, Input, ViewChild } from '@angular/core'; @Component({ selector: 'ixt-split-pane', template: ` <div class="split-container"> <div class="first-panel" [style.flexBasis.%]="firstPanelSize"> <ng-content select=".left-pane"></ng-content> </div> <div #divider class="divider" (mousedown)="startResize($event)"> </div> <div class="second-panel" [style.flexBasis.%]="100 - firstPanelSize"> <ng-content select=".right-pane"></ng-content> </div> </div> `, styles: [` :host { display: flex; flex: 1; min-height: 0; min-width: 0; font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', Arial, sans-serif; font-size: 14px; color: #2c3e50; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } .split-container { display: flex; flex: 1; min-height: 0; min-width: 0; background: #ffffff; border: 1px solid #e0e4e8; border-radius: 4px; } .first-panel, .second-panel { display: flex; flex: 1; min-height: 0; min-width: 0; overflow: auto; background: white; padding: 16px; /* Table styles for your file list */ ::ng-deep { table { width: 100%; border-collapse: collapse; } th { text-align: left; font-weight: 500; color: #546e7a; padding: 8px 16px; border-bottom: 2px solid #e0e4e8; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px; } td { padding: 12px 16px; border-bottom: 1px solid #f0f2f5; color: #37474f; font-size: 14px; } tr:hover { background-color: #f8fafc; } } /* Scrollbar styling */ &::-webkit-scrollbar { width: 8px; height: 8px; } &::-webkit-scrollbar-track { background: #f5f6f8; border-radius: 4px; } &::-webkit-scrollbar-thumb { background: #dde1e6; border-radius: 4px; &:hover { background: #c7ccd1; } } } .divider { display: flex; justify-content: center; width: 16px; flex-shrink: 0; cursor: col-resize; background: transparent; transition: background-color 0.2s; &:hover { background: #f5f6f8; .divider-line { background: #c7ccd1; } } } .divider { width: 6px; background: #ccc; cursor: col-resize; flex-shrink: 0; border-left: 1px solid #b4b4b4; border-right: 1px solid #b4b4b4; &:hover { background: #999; } } `] }) export class IxtSplitPaneComponent { firstPanelSize = 50; // default size isDragging = false; startPosition = 0; startSize = 0; @ViewChild('divider') divider!: ElementRef; startResize(e: MouseEvent) { this.isDragging = true; this.startPosition = e.pageX; this.startSize = this.firstPanelSize; document.addEventListener('mousemove', this.resize.bind(this)); document.addEventListener('mouseup', this.stopResize.bind(this)); } @HostListener('window:mousemove', ['$event']) resize(e: MouseEvent) { if (!this.isDragging) return; const containerRect = this.divider.nativeElement.parentElement.getBoundingClientRect(); const difference = e.pageX - this.startPosition; let newSize = this.startSize + (difference / containerRect.width * 100); newSize = Math.max(0, Math.min(100, newSize)); this.firstPanelSize = newSize; } stopResize() { this.isDragging = false; document.removeEventListener('mousemove', this.resize.bind(this)); document.removeEventListener('mouseup', this.stopResize.bind(this)); } }
    |   |   --- ixt-split-pane.module.ts: // ixt-split-pane.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtSplitPaneComponent } from './ixt-split-pane.component'; @NgModule({ declarations: [ IxtSplitPaneComponent ], imports: [ CommonModule ], exports: [ IxtSplitPaneComponent ] }) export class IxtSplitPaneModule { }
    |   +-- ixt-table
    |   |   +-- editors
    |   |   |   +-- airport-code
    |   |   |   |   --- airport-code-editor.component.ts: import { Component, Input, forwardRef, OnInit, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { IxtDialogService } from '../../../ixt-dialog/ixt-dialog.service'; import { TableEditor, TableEditorConfig } from '../editor.interface'; @Component({ selector: 'airport-code-editor', template: ` <div class="editor-container"> <input type="text" [formControl]="inputControl" class="w-24 px-2 py-1 border rounded" [class.border-red-500]="hasError" [attr.maxlength]="config?.['maxLength'] || 3" (blur)="onTouched()" /> <div *ngIf="hasError" class="text-red-500 text-sm mt-1"> {{ errorMessage }} </div> </div> `, styles: [` .editor-container { position: relative; } `], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AirportCodeEditorComponent), multi: true } ] }) export class AirportCodeEditorComponent implements ControlValueAccessor, OnInit, TableEditor { @Input() config?: TableEditorConfig; @Input() existingCodes: string[] = []; @Input() field: string = 'code'; inputControl = new FormControl(''); hasError = false; errorMessage = ''; // TableEditor implementation component: Type<any> = AirportCodeEditorComponent; // ControlValueAccessor implementations public onChanged: (value: string) => void = () => {}; public onTouched: () => void = () => {}; constructor(private dialogService: IxtDialogService) {} ngOnInit() { this.setupValueChanges(); } // TableEditor methods getEditConfig(): TableEditorConfig { return { existingValues: this.existingCodes, maxLength: 3, pattern: /^[A-Z]+$/ }; } getDefaultValue(): string { return ''; } validate(value: any): boolean { if (!value) return false; const code = String(value).toUpperCase(); if (code.length !== 3) return false; if (!/^[A-Z]+$/.test(code)) return false; if (this.existingCodes.includes(code)) return false; return true; } format(value: any): string { return value ? String(value).toUpperCase() : ''; } private async setupValueChanges() { this.inputControl.valueChanges.subscribe(async value => { if (value !== null) { const upperValue = value.toUpperCase(); if (upperValue !== value) { this.inputControl.setValue(upperValue, { emitEvent: false }); } if (await this.validateValue(upperValue)) { console.log('Editor emitting code change:', upperValue); this.onChanged(upperValue); } } }); } private async validateValue(value: string): Promise<boolean> { this.hasError = false; this.errorMessage = ''; if (!value) return false; if (value.length !== (this.config?.['maxLength'] || 3)) { this.hasError = true; this.errorMessage = `Code must be exactly ${this.config?.['maxLength'] || 3} characters`; return false; } const pattern = this.config?.['pattern'] || /^[A-Z]+$/; if (!pattern.test(value)) { this.hasError = true; this.errorMessage = 'Only letters are allowed'; return false; } if (this.config?.existingValues?.includes(value)) { this.hasError = true; this.errorMessage = 'This code already exists'; // await this.dialogService.warning( // `The code "${value}" already exists. Please enter a different code.`, // 'Duplicate Code' // ); return false; } return true; } // ControlValueAccessor interface implementation writeValue(value: string): void { console.log('AirportCodeEditor writeValue:', value); this.inputControl.setValue(value, { emitEvent: false }); } registerOnChange(fn: (value: string) => void): void { console.log('AirportCodeEditor registerOnChange'); this.onChanged = fn; } registerOnTouched(fn: () => void): void { this.onTouched = fn; } setDisabledState(isDisabled: boolean): void { if (isDisabled) { this.inputControl.disable(); } else { this.inputControl.enable(); } } }
    |   |   |   +-- binary-editor
    |   |   |   |   --- binary-editor.component.ts: // src/components/ixt-table/table-editors/binary-editor/binary-editor.component.ts import { Component, Input, forwardRef, Output, EventEmitter, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { TableEditor, TableEditorConfig } from '../editor.interface'; interface BinaryConfig extends TableEditorConfig { trueValue?: any; falseValue?: any; trueDisplay?: string; falseDisplay?: string; rowData?: any; rowIndex?: number; } interface SelectionEvent { selected: boolean; rowData?: any; rowIndex?: number; } @Component({ selector: 'binary-editor', template: ` <div class="editor-container"> <input type="checkbox" [formControl]="inputControl" [checked]="isChecked" (change)="onCheckboxChange($event)" class="w-4 h-4 rounded border-gray-300" /> <span *ngIf="showLabel" class="ml-2"> {{ isChecked ? config.trueDisplay : config.falseDisplay }} </span> </div> `, providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => BinaryEditorComponent), multi: true } ] }) export class BinaryEditorComponent implements ControlValueAccessor, TableEditor { @Input() config: BinaryConfig = {}; @Output() selectionChange = new EventEmitter<SelectionEvent>(); inputControl = new FormControl<boolean | null>(false); component: Type<any> = BinaryEditorComponent; showLabel = false; isChecked = false; private onChange: (value: any) => void = () => { }; private onTouch: () => void = () => { }; constructor() { this.setupDefaults(); this.isChecked = false; } ngOnInit() { this.setupDefaults(); this.setupValueChanges(); } private setupDefaults() { this.config = { trueValue: true, falseValue: false, trueDisplay: 'True', falseDisplay: 'False', ...this.config }; } private setupValueChanges(): void { this.inputControl.valueChanges.subscribe((checked: boolean | null) => { if (checked !== null) { const value = checked ? this.config.trueValue : this.config.falseValue; this.isChecked = checked; this.onChange(value); this.selectionChange.emit({ selected: checked, rowData: this.config.rowData, rowIndex: this.config.rowIndex }); } }); } onCheckboxChange(event: Event) { const checkbox = event.target as HTMLInputElement; this.inputControl.setValue(checkbox.checked); this.onTouch(); } getEditConfig(): BinaryConfig { return { trueValue: this.config.trueValue || true, falseValue: this.config.falseValue || false, trueDisplay: this.config.trueDisplay || 'True', falseDisplay: this.config.falseDisplay || 'False' }; } writeValue(value: any): void { const checked = value === this.config.trueValue; this.isChecked = checked; this.inputControl.setValue(checked, { emitEvent: false }); } registerOnChange(fn: any): void { this.onChange = fn; } registerOnTouched(fn: any): void { this.onTouch = fn; } setDisabledState(isDisabled: boolean): void { if (isDisabled) { this.inputControl.disable(); } else { this.inputControl.enable(); } } }
    |   |   |   +-- coordinate
    |   |   |   |   --- coordinate-editor.component.ts: // src/components/ixt-table/table-editors/coordinate/coordinate-editor.component.ts import { Component, Input, forwardRef, OnInit, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { IxtDialogService } from '../../../ixt-dialog/ixt-dialog.service'; import { TableEditor, TableEditorConfig } from '../editor.interface'; @Component({ selector: 'coordinate-editor', template: ` <div class="editor-container"> <input type="number" step="any" [min]="config?.['type'] === 'lat' ? -90 : -180" [max]="config?.['type'] === 'lat' ? 90 : 180" [formControl]="inputControl" class="w-24 px-2 py-1 border rounded" [class.border-red-500]="hasError" [placeholder]="config?.['type'] === 'lat' ? '(-90 to 90)' : '(-180 to 180)'" (blur)="onBlur()" /> <div *ngIf="hasError" class="text-red-500 text-sm mt-1"> {{ errorMessage }} </div> </div>`, providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => CoordinateEditorComponent), multi: true } ] }) export class CoordinateEditorComponent implements ControlValueAccessor, OnInit, TableEditor { @Input() config?: TableEditorConfig; inputControl = new FormControl(''); hasError = false; errorMessage = ''; // TableEditor implementation component: Type<any> = CoordinateEditorComponent; private onChange: (value: number) => void = () => { }; private onTouch: () => void = () => { }; constructor(private dialogService: IxtDialogService) { } ngOnInit() { this.setupValueChanges(); } getEditConfig(): TableEditorConfig { return { type: this.config?.['type'] || 'lat' }; } validate(value: any): boolean { const num = Number(value); const isLat = this.config?.['type'] === 'lat'; return isLat ? (num >= -90 && num <= 90) : (num >= -180 && num <= 180); } // private setupValueChanges() { // this.inputControl.valueChanges.subscribe(value => { // if (value !== null) { // // Convert string to number for validation // const numValue = Number(value); // if (this.validateValue(numValue)) { // this.onChange(numValue); // } // } // }); // } setupValueChanges() { this.inputControl.valueChanges.subscribe(value => { if (value !== null) { const numValue = Number(value); if (!isNaN(numValue) && this.validateValue(numValue)) { this.onChange(numValue); } else { // Reset to last valid value or empty this.inputControl.setValue('', {emitEvent: false}); } } }); } private validateValue(value: number): boolean { this.hasError = false; this.errorMessage = ''; if (isNaN(value)) { this.hasError = true; this.errorMessage = 'Must be a valid number'; return false; } const isLat = this.config?.['type'] === 'lat'; const min = isLat ? -90 : -180; const max = isLat ? 90 : 180; if (value < min || value > max) { this.hasError = true; this.errorMessage = `Must be between ${min} and ${max}`; return false; } return true; } // ControlValueAccessor methods writeValue(value: number): void { this.inputControl.setValue(value?.toString() || '', { emitEvent: false }); } registerOnChange(fn: any): void { this.onChange = fn; } registerOnTouched(fn: any): void { this.onTouch = fn; } onBlur(): void { this.onTouch(); } }
    |   |   |   --- editor.interface.ts: import { Type } from "@angular/core"; export interface TableEditorConfig { existingValues?: any[]; validators?: any[]; field?: string; [key: string]: any; } export interface TableEditor { component: Type<any>; getEditConfig(): any; validate?(value: any): boolean; format?(value: any): string; getDefaultValue?(): any; }
    |   |   +-- services
    |   |   |   +-- edit
    |   |   |   |   --- edit.model.ts: // src/components/ixt-table/services/edit/edit.model.ts import { FormControl } from '@angular/forms'; export interface RowChanges { [key: string]: any; } export interface EditState { editingRows: Set<number>; newRows: any[]; rowChanges: Map<number, RowChanges>; editControls: Map<string, FormControl>; } export interface EditEvent { rowIndex: number; field: string; value: any; }
    |   |   |   |   --- edit.service.ts: // src/components/ixt-table/services/edit/edit.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { FormControl } from '@angular/forms'; import { ColumnConfig } from '../../ixt-table.interfaces'; import { EditEvent, EditState, RowChanges } from './edit.model'; @Injectable({ providedIn: 'root' }) export class EditService { private readonly initialState: EditState = { editingRows: new Set<number>(), newRows: [], rowChanges: new Map<number, RowChanges>(), editControls: new Map<string, FormControl>() }; private state = new BehaviorSubject<EditState>(this.initialState); public state$ = this.state.asObservable(); private getDefaultValueForType(type: string | any): any { switch (type) { case 'number': return 0; case 'enum': return ''; case 'text': default: return ''; } } public addNewRow(columnConfigs: Record<string, ColumnConfig>): void { const newRow: any = {}; if (columnConfigs) { Object.entries(columnConfigs).forEach(([field, config]) => { newRow[field] = this.getDefaultValueForType(config.type); }); } const currentState = this.state.getValue(); const newRows = [...currentState.newRows]; newRows.unshift(newRow); // Start editing the new row const editingRows = new Set(currentState.editingRows); editingRows.add(-newRows.length); this.state.next({ ...currentState, newRows, editingRows }); } public startEditing(rowIndex: number): void { const currentState = this.state.getValue(); const editingRows = new Set(currentState.editingRows); editingRows.add(rowIndex); this.state.next({ ...currentState, editingRows }); } public cancelEditing(rowIndex: number): void { const currentState = this.state.getValue(); const editingRows = new Set(currentState.editingRows); const rowChanges = new Map(currentState.rowChanges); editingRows.delete(rowIndex); rowChanges.delete(rowIndex); this.state.next({ ...currentState, editingRows, rowChanges }); } public onValueChange(event: EditEvent): void { const { rowIndex, field, value } = event; const currentState = this.state.getValue(); const rowChanges = new Map(currentState.rowChanges); let changes = rowChanges.get(rowIndex) || {}; changes = { ...changes, [field]: value }; rowChanges.set(rowIndex, changes); this.state.next({ ...currentState, rowChanges }); } public getEditControl(rowIndex: number, field: string): FormControl { const key = `${rowIndex}-${field}`; const currentState = this.state.getValue(); let control = currentState.editControls.get(key); if (!control) { control = new FormControl(''); const editControls = new Map(currentState.editControls); editControls.set(key, control); this.state.next({ ...currentState, editControls }); } return control; } public saveChanges(data: any[]): any[] { const currentState = this.state.getValue(); const updatedData = [...data]; // Apply changes to existing rows currentState.rowChanges.forEach((changes, rowIndex) => { if (rowIndex >= 0) { updatedData[rowIndex] = { ...updatedData[rowIndex], ...changes }; } }); // Add new rows if (currentState.newRows.length) { // Apply any changes to new rows const processedNewRows = currentState.newRows.map((row, index) => { const changes = currentState.rowChanges.get(-index - 1); return changes ? { ...row, ...changes } : row; }); updatedData.unshift(...processedNewRows); } // Reset state this.state.next(this.initialState); return updatedData; } public isNewRow(index: number): boolean { return index < this.state.getValue().newRows.length; } public isEditing(rowIndex: number): boolean { return this.state.getValue().editingRows.has(rowIndex); } public hasChanges(): boolean { const currentState = this.state.getValue(); return currentState.rowChanges.size > 0 || currentState.newRows.length > 0; } public getNewRows(): any[] { return this.state.getValue().newRows; } public getRowChanges(rowIndex: number): RowChanges | undefined { return this.state.getValue().rowChanges.get(rowIndex); } public getRowIndex(displayIndex: number): number { return displayIndex - this.state.getValue().newRows.length; } public clearEditing(): void { this.state.next(this.initialState); } }
    |   |   |   +-- filter
    |   |   |   |   --- filter.model.ts: // 3. filter.model.ts import { FormControl } from '@angular/forms'; export type FilterOperator = 'equals' | 'startsWith' | 'contains' | 'between' | '>' | '<' | '>=' | '<=' | '!='; export interface FilterState { field: string; operator: FilterOperator; value: any; secondaryValue?: any; } export interface FilterControls { value: FormControl; operator?: FormControl<string>; }
    |   |   |   |   --- filter.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; import { FormControl } from '@angular/forms'; import { FilterState, FilterOperator, FilterControls } from './filter.model'; import { ColumnConfig } from '../../ixt-table.interfaces'; @Injectable({ providedIn: 'root' }) export class FilterService { private activeFilters = new Map<string, FilterState>(); private filterControls = new Map<string, FilterControls>(); private activeFilterColumn?: string; private showFilters = false; private filtersChanged = new BehaviorSubject<Map<string, FilterState>>(new Map()); public filtersChanged$ = this.filtersChanged.asObservable(); public initializeFilter(field: string, config: ColumnConfig): void { const controls: FilterControls = { value: new FormControl('') }; if (config.type === 'number') { // Fix: Explicitly type the FormControl controls.operator = new FormControl<string>('=', { nonNullable: true }); } this.filterControls.set(field, controls); } public getFilterControl(field: string): FormControl | undefined { return this.filterControls.get(field)?.value; } public getOperatorControl(field: string): FormControl<string> | undefined { return this.filterControls.get(field)?.operator; } public onFilterChange(field: string, value: any, config?: ColumnConfig): void { if (value || value === 0) { const defaultOperator: FilterOperator = config?.type === 'number' ? 'equals' : 'contains'; const operator = this.getOperatorControl(field)?.value || defaultOperator; this.activeFilters.set(field, { field, operator: operator as FilterOperator, value: config?.type === 'number' ? Number(value) : value }); } else { this.activeFilters.delete(field); } this.filtersChanged.next(this.activeFilters); } public onOperatorChange(field: string): void { const currentValue = this.getFilterControl(field)?.value; if (currentValue || currentValue === 0) { this.onFilterChange(field, currentValue); } } public clearAllFilters(): void { this.activeFilters.clear(); this.filterControls.forEach(controls => { controls.value.reset(); controls.operator?.reset('='); }); this.filtersChanged.next(this.activeFilters); } public toggleFilters(column: string): void { if (this.activeFilterColumn === column) { this.activeFilterColumn = undefined; this.showFilters = false; } else { this.activeFilterColumn = column; this.showFilters = true; } } public matchesFilter(item: any, filter: FilterState): boolean { if (item === undefined || item === null) return false; // Handle numeric comparisons if (typeof item === 'number' || !isNaN(Number(item))) { const numValue = Number(item); const numFilterValue = Number(filter.value); return this.handleNumericComparison(numValue, numFilterValue, filter.operator); } // String handling const itemValue = String(item).toLowerCase(); const filterValue = String(filter.value).toLowerCase(); switch (filter.operator) { case 'startsWith': return itemValue.startsWith(filterValue); case 'equals': return itemValue === filterValue; case '!=': return itemValue !== filterValue; default: return itemValue.includes(filterValue); } } private handleNumericComparison(numValue: number, numFilterValue: number, operator: FilterOperator): boolean { switch (operator) { case '>': return numValue > numFilterValue; case '<': return numValue < numFilterValue; case '>=': return numValue >= numFilterValue; case '<=': return numValue <= numFilterValue; case '!=': return numValue !== numFilterValue; case 'equals': return numValue === numFilterValue; default: return false; } } public get isShowingFilters(): boolean { return this.showFilters; } public get activeColumn(): string | undefined { return this.activeFilterColumn; } public getActiveFilters(): Map<string, FilterState> { return this.activeFilters; } public hasActiveFilters(): boolean { return this.activeFilters.size > 0; } }
    |   |   |   +-- selection
    |   |   |   |   --- selection.model.ts: // src/components/ixt-table/services/selection/selection.model.ts export interface SelectionState { selectedRows: Set<number>; allSelected: boolean; }
    |   |   |   |   --- selection.service.ts: // src/components/ixt-table/services/selection/selection.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { SelectionState } from './selection.model'; @Injectable({ providedIn: 'root' }) export class SelectionService { private state = new BehaviorSubject<SelectionState>({ selectedRows: new Set<number>(), allSelected: false }); public state$ = this.state.asObservable(); public selectRow(index: number, selected: boolean = true): void { const currentState = this.state.getValue(); const newSelectedRows = new Set(currentState.selectedRows); if (selected) { newSelectedRows.add(index); } else { newSelectedRows.delete(index); } this.state.next({ selectedRows: newSelectedRows, allSelected: currentState.allSelected }); } public toggleAllRows(selected: boolean, totalRows: number): void { const newSelectedRows = new Set<number>(); if (selected) { // Add all row indices for (let i = 0; i < totalRows; i++) { newSelectedRows.add(i); } } this.state.next({ selectedRows: newSelectedRows, allSelected: selected }); } public clearSelection(): void { this.state.next({ selectedRows: new Set<number>(), allSelected: false }); } public getSelectedRows(): Set<number> { return this.state.getValue().selectedRows; } public isSelected(index: number): boolean { return this.state.getValue().selectedRows.has(index); } public isAllSelected(): boolean { return this.state.getValue().allSelected; } public getSelectedCount(): number { return this.state.getValue().selectedRows.size; } public setSelectedRows(indices: number[]): void { const newSelectedRows = new Set(indices); this.state.next({ selectedRows: newSelectedRows, allSelected: false // Reset all selected state when manually setting rows }); } public isPartiallySelected(totalRows: number): boolean { const selectedCount = this.getSelectedCount(); return selectedCount > 0 && selectedCount < totalRows; } }
    |   |   |   +-- sort
    |   |   |   |   --- sort.model.ts: // src/components/ixt-table/services/sort/sort.model.ts export type SortDirection = 'asc' | 'desc' | null; export interface SortState { column: string | null; direction: SortDirection; }
    |   |   |   |   --- sort.service.ts: // src/components/ixt-table/services/sort/sort.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { SortState, SortDirection } from './sort.model'; @Injectable({ providedIn: 'root' }) export class SortService { private readonly initialState: SortState = { column: null, direction: null }; private state = new BehaviorSubject<SortState>(this.initialState); public state$ = this.state.asObservable(); public toggleSort(column: string): void { const currentState = this.state.getValue(); let newDirection: SortDirection = null; if (currentState.column === column) { // Cycle through: null -> asc -> desc -> null if (currentState.direction === null) { newDirection = 'asc'; } else if (currentState.direction === 'asc') { newDirection = 'desc'; } else { newDirection = null; } } else { // New column, start with ascending newDirection = 'asc'; } this.state.next({ column: newDirection ? column : null, direction: newDirection }); } public getSortIcon(column: string): string { const { column: sortColumn, direction } = this.state.getValue(); if (sortColumn !== column) { return 'unfold_more'; } return direction === 'asc' ? 'arrow_upward' : 'arrow_downward'; } public sortData<T>(data: T[]): T[] { const { column, direction } = this.state.getValue(); if (!column || !direction) { return data; } return [...data].sort((a, b) => { const aVal = a[column as keyof T]; const bVal = b[column as keyof T]; if (aVal == null) return 1; if (bVal == null) return -1; let comparison: number; if (typeof aVal === 'string') { comparison = String(aVal).toLowerCase().localeCompare(String(bVal).toLowerCase()); } else { comparison = aVal < bVal ? -1 : (aVal > bVal ? 1 : 0); } return direction === 'asc' ? comparison : -comparison; }); } public clearSort(): void { this.state.next(this.initialState); } public getCurrentSort(): SortState { return this.state.getValue(); } public isColumnSorted(column: string): boolean { return this.state.getValue().column === column; } public getSortDirection(column: string): SortDirection { const { column: sortColumn, direction } = this.state.getValue(); return sortColumn === column ? direction : null; } }
    |   |   |   --- pagination.model.ts: // src/components/ixt-table/services/pagination/pagination.model.ts export interface PaginationState { currentPage: number; pageSize: number | 'all'; totalItems: number; } export interface PageSize { value: number | 'all'; label: string; }
    |   |   |   --- pagination.service.ts: // src/components/ixt-table/services/pagination/pagination.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; import { PageSize, PaginationState } from './pagination.model'; @Injectable({ providedIn: 'root' }) export class PaginationService { private readonly DEFAULT_PAGE_SIZES: PageSize[] = [ { value: 10, label: '10' }, { value: 100, label: '100' }, { value: 'all', label: 'All' } ]; private readonly MINIMUM_ROWS_FOR_PAGINATION = 50; private state = new BehaviorSubject<PaginationState>({ currentPage: 1, pageSize: 10, totalItems: 0 }); public state$ = this.state.asObservable(); public initialize(totalItems: number): void { this.updateState({ currentPage: 1, pageSize: 10, totalItems }); } public shouldShowPagination(): boolean { return this.state.getValue().totalItems > this.MINIMUM_ROWS_FOR_PAGINATION; } public getCurrentPage(): number { return this.state.getValue().currentPage; } public getPageSize(): number | 'all' { return this.state.getValue().pageSize; } public getPageSizes(): PageSize[] { return this.DEFAULT_PAGE_SIZES; } public getTotalPages(): number { const { totalItems, pageSize } = this.state.getValue(); if (pageSize === 'all' || totalItems <= this.MINIMUM_ROWS_FOR_PAGINATION) { return 1; } return Math.ceil(totalItems / +pageSize); } public getVisiblePages(): number[] { const totalPages = this.getTotalPages(); const currentPage = this.getCurrentPage(); if (totalPages <= 1) return []; const pages: number[] = [1]; const WINDOW_SIZE = 4; let start = Math.max(2, currentPage - WINDOW_SIZE); let end = Math.min(totalPages - 1, currentPage + WINDOW_SIZE); if (start > 2) { pages.push(-1); } for (let i = start; i <= end; i++) { pages.push(i); } if (end < totalPages - 1) { pages.push(-1); } if (totalPages > 1) { pages.push(totalPages); } return pages; } public onPageChange(page: number): void { const totalPages = this.getTotalPages(); if (page >= 1 && page <= totalPages) { this.updateState({ ...this.state.getValue(), currentPage: page }); } } public onPageSizeChange(newSize: number | 'all'): void { this.updateState({ ...this.state.getValue(), pageSize: newSize, currentPage: 1 }); } public getPaginatedData<T>(data: T[]): T[] { const { pageSize, currentPage } = this.state.getValue(); if (pageSize === 'all' || data.length <= this.MINIMUM_ROWS_FOR_PAGINATION) { return data; } const start = (currentPage - 1) * (+pageSize); const end = start + (+pageSize); return data.slice(start, end); } private updateState(newState: Partial<PaginationState>): void { this.state.next({ ...this.state.getValue(), ...newState }); } }
    |   |   --- ixt-table.component.ts: import { ChangeDetectorRef, Component, Input, OnInit, TemplateRef, ViewChild, Type } from '@angular/core'; import { FormControl } from '@angular/forms'; import { ColumnConfig, TableNode} from './ixt-table.interfaces'; import { debounceTime, distinctUntilChanged } from 'rxjs/operators'; import { IxtDialogService } from '../ixt-dialog/ixt-dialog.index'; import { PaginationService } from './services/pagination.service'; import { FilterService } from './services/filter/filter.service'; import { SortService } from './services/sort/sort.service'; import { SelectionService } from './services/selection/selection.service'; import { EditService } from './services/edit/edit.service'; import { TableEditor } from './editors/editor.interface'; import { AirportCodeEditorComponent, CoordinateEditorComponent, PageSize } from './ixt-table.index'; @Component({ selector: 'ixt-table', templateUrl: './ixt-table.component.html', styleUrls: ['./ixt-table.component.scss'] }) export class IxtTableComponent implements OnInit { @Input() data: TableNode[] = []; @Input() columnConfigs?: Record<string, ColumnConfig>; @ViewChild('noData') noDataTemplate!: TemplateRef<any>; @ViewChild('customEditorTpl') customEditorTpl!: TemplateRef<any>; columns: string[] = []; pageSizeControl = new FormControl<number | 'all'>(10); readonly AirportCodeEditorComponent = AirportCodeEditorComponent; readonly CoordinateEditorComponent = CoordinateEditorComponent; constructor( private dialogService: IxtDialogService, private changeDetectorRef: ChangeDetectorRef, private paginationService: PaginationService, private filterService: FilterService, private sortService: SortService, private selectionService: SelectionService, private editService: EditService ) { } ngOnInit() { this.columns = this.getColumns(this.data); // Initialize pagination this.paginationService.initialize(this.data.length); // Initialize filters if (this.columnConfigs) { Object.entries(this.columnConfigs).forEach(([field, config]) => { this.filterService.initializeFilter(field, config); // Get the control from service and subscribe to changes const control = this.filterService.getFilterControl(field); if (control) { control.valueChanges.pipe( debounceTime(config.debounceTime || 300), distinctUntilChanged() ).subscribe(value => { this.filterService.onFilterChange(field, value, config); }); } }); } // Subscribe to filter changes this.filterService.filtersChanged$.subscribe(() => { this.changeDetectorRef.markForCheck(); }); // Subscribe to pagination changes this.paginationService.state$.subscribe(() => { this.changeDetectorRef.markForCheck(); }); // Subscribe to page size changes this.pageSizeControl.valueChanges.subscribe(value => { if (value) { this.paginationService.onPageSizeChange(value); } }); } // edit logic start addNewRow(): void { this.editService.addNewRow(this.columnConfigs || {}); } cancelEditing(rowIndex: number): void { this.editService.cancelEditing(rowIndex); } getEditorComponent(type: any): TableEditor | null { console.log('getEditorComponent called with:', { type, isCoordinate: type === CoordinateEditorComponent, isAirport: type === AirportCodeEditorComponent }); if (type === AirportCodeEditorComponent) { return new AirportCodeEditorComponent(this.dialogService); } if (type === CoordinateEditorComponent) { return new CoordinateEditorComponent(this.dialogService); } return null; } getEditorType(type: any): string { console.log('getEditorType called with:', { type, isString: typeof type === 'string', isCoordinate: type === CoordinateEditorComponent, isAirport: type === AirportCodeEditorComponent }); if (typeof type === 'string') { return type; } if (type === AirportCodeEditorComponent || type === CoordinateEditorComponent) { console.log('Returning custom for editor type'); return 'custom'; } console.log('Falling back to text type'); return 'text'; } getEditControl(rowIndex: number, field: string): FormControl { return this.editService.getEditControl(rowIndex, field); } getRowIndex(displayIndex: number): number { return this.editService.getRowIndex(displayIndex); } get hasChanges(): boolean { return this.editService.hasChanges(); } isEditing(index: number): boolean { return this.editService.isEditing(index); } isNewRow(displayIndex: number): boolean { return this.editService.isNewRow(displayIndex); } get newRowsLength(): number { return this.editService.getNewRows().length; } onValueChange(rowIndex: number, field: string, value: any): void { this.editService.onValueChange({ rowIndex, field, value }); } saveChanges(): void { this.data = this.editService.saveChanges(this.data); this.changeDetectorRef.markForCheck(); } startEditing(rowIndex: number): void { this.editService.startEditing(rowIndex); } // edit logic end // filter logic start get activeFilterColumn(): string | undefined { return this.filterService.activeColumn; } getFilterControl(col: string): FormControl<any> { return this.filterService.getFilterControl(col)!; } getOperatorControl(col: string): FormControl<string> { return this.filterService.getOperatorControl(col)!; } onOperatorChange(field: string): void { this.filterService.onOperatorChange(field); } get showFilters(): boolean { return this.filterService.isShowingFilters; } toggleFilters(col: string): void { this.filterService.toggleFilters(col); } // filter logic end // pagination logic start get currentPage(): number { return this.paginationService.getCurrentPage(); } onPageChange(page: number): void { this.paginationService.onPageChange(page); } onPageSizeChange(size: number | 'all'): void { this.paginationService.onPageSizeChange(size); } get paginatedData(): TableNode[] { // Start with combined data let allData = [...this.editService.getNewRows(), ...this.data]; // Apply filters if (this.filterService.hasActiveFilters()) { const activeFilters = this.filterService.getActiveFilters(); const filteredExisting = this.data.filter(item => Array.from(activeFilters.values()).every(filter => this.filterService.matchesFilter(item[filter.field], filter) ) ); allData = [...this.editService.getNewRows(), ...filteredExisting]; } // Apply sorting allData = this.sortService.sortData(allData); // Apply pagination return this.paginationService.getPaginatedData(allData); } get pageSizes(): PageSize[] { return this.paginationService.getPageSizes(); } get showPagination(): boolean { return this.paginationService.shouldShowPagination(); } get totalPages(): number { return this.paginationService.getTotalPages(); } get visiblePages(): number[] { return this.paginationService.getVisiblePages(); } // pagination logic end // selection logic start get allSelected(): boolean { return this.selectionService.isAllSelected(); } set allSelected(value: boolean) { this.selectionService.toggleAllRows(value, this.data.length); } getSelectedRows(): TableNode[] { return Array.from(this.selectionService.getSelectedRows()) .map(index => this.data[index]) .filter(row => row !== undefined); } get hasSelectedRows(): boolean { return this.selectionService.getSelectedCount() > 0; } isRowSelected(index: number): boolean { return this.selectionService.isSelected(index); } selectRow(index: number, selected = true): void { this.selectionService.selectRow(index, selected); } setSelectedRows(indices: number[]): void { this.selectionService.setSelectedRows(indices); } toggleAllRows(selected: boolean): void { this.selectionService.toggleAllRows(selected, this.data.length); } // selection logic end // sort logic start getSortIcon(column: string): string { return this.sortService.getSortIcon(column); } toggleSort(column: string): void { this.sortService.toggleSort(column); } // sort logic end // i/o logic start formatCoordinate(value: number): string { return value.toFixed(1); } getCodes(data: TableNode[]): string[] { if (!data) return []; return data.map(row => row['code']?.toString() || ''); } // i/o logic end // config logic start getColumns(data: TableNode[]): string[] { if (!data?.length) return []; const firstRow = data[0]; return Object.keys(firstRow); } get hasData(): boolean { return !!this.data?.length; } // config logic end }
    |   |   --- ixt-table.index.ts: // ixt-table.index.ts // Core export * from './ixt-table.component'; export * from './ixt-table.interfaces'; export * from './ixt-table.module'; export * from './ixt-table.type'; // Editors export * from './editors/editor.interface'; export * from './editors/airport-code/airport-code-editor.component'; export * from './editors/binary-editor/binary-editor.component'; export * from './editors/coordinate/coordinate-editor.component'; // Services and Models export * from './services/edit/edit.model'; export * from './services/edit/edit.service'; export * from './services/filter/filter.model'; export * from './services/filter/filter.service'; export * from './services/sort/sort.model'; export * from './services/sort/sort.service'; export * from './services/selection/selection.model'; export * from './services/selection/selection.service'; export * from './services/pagination.model'; export * from './services/pagination.service';
    |   |   --- ixt-table.interfaces.ts: // 1. ixt-table.interfaces.ts - Keep only core table interfaces import { Type } from "@angular/core"; import { TableEditor } from "./editors/editor.interface"; import { FilterOperator } from "./services/filter/filter.model"; export interface ColumnConfig { type: 'text' | 'number' | 'enum' | Type<TableEditor> | TableEditor; field: string; label?: string; operator?: FilterOperator; enumValues?: { value: any, label: string }[]; placeholder?: string; debounceTime?: number; editable?: boolean; config?: any; } export type ColumnConfigs = Record<string, ColumnConfig>; export interface TableNode { code?: string; [key: string]: any; }
    |   |   --- ixt-table.module.ts: import { NgModule } from '@angular/core'; import { CommonModule, DatePipe } from '@angular/common'; import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { MatIconModule } from '@angular/material/icon'; import { MatAutocompleteModule } from '@angular/material/autocomplete'; // Components import { IxtTableComponent } from './ixt-table.component'; import { AirportCodeEditorComponent } from './editors/airport-code/airport-code-editor.component'; import { CoordinateEditorComponent } from './editors/coordinate/coordinate-editor.component'; import { BinaryEditorComponent } from './editors/binary-editor/binary-editor.component'; // Services import { EditService } from './services/edit/edit.service'; import { FilterService } from './services/filter/filter.service'; import { SortService } from './services/sort/sort.service'; import { SelectionService } from './services/selection/selection.service'; import { PaginationService } from './services/pagination.service'; import { TableDataService } from './ixt-table.service'; const COMPONENTS = [ IxtTableComponent, AirportCodeEditorComponent, CoordinateEditorComponent, BinaryEditorComponent ]; const SERVICES = [ EditService, FilterService, SortService, SelectionService, PaginationService, TableDataService ]; @NgModule({ declarations: [ ...COMPONENTS ], imports: [ CommonModule, FormsModule, ReactiveFormsModule, MatIconModule, MatAutocompleteModule ], providers: [ ...SERVICES, DatePipe ], exports: [ ...COMPONENTS ] }) export class IxtTableModule { }
    |   |   --- ixt-table.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject, combineLatest, Observable } from 'rxjs'; import { map } from 'rxjs/operators'; import { PageSize } from './ixt-table.index'; import { TableRow } from './ixt-table.type'; export interface PaginationState { currentPage: number; pageSize: number | 'all'; totalPages: number; } @Injectable({ providedIn: 'root' }) export class TableDataService { private dataSubject = new BehaviorSubject<TableRow[]>([]); private newRowsSubject = new BehaviorSubject<TableRow[]>([]); private paginationStateSubject = new BehaviorSubject<PaginationState>({ currentPage: 1, pageSize: 10, totalPages: 1 }); readonly pageSizes: PageSize[] = [ { value: 10, label: '10' }, { value: 100, label: '100' }, { value: 'all', label: 'All' } ]; constructor() { } // Data operations setData(data: TableRow[]): void { this.dataSubject.next(data); this.updateTotalPages(); } getData(): Observable<TableRow[]> { return this.dataSubject.asObservable(); } // New rows operations addNewRow(row: TableRow): void { const currentNewRows = this.newRowsSubject.value; this.newRowsSubject.next([row, ...currentNewRows]); } getNewRows(): Observable<TableRow[]> { return this.newRowsSubject.asObservable(); } commitNewRows(): void { const currentData = this.dataSubject.value; const newRows = this.newRowsSubject.value; this.dataSubject.next([...newRows, ...currentData]); this.newRowsSubject.next([]); this.updateTotalPages(); } // Pagination operations setPaginationState(state: Partial<PaginationState>): void { const currentState = this.paginationStateSubject.value; this.paginationStateSubject.next({ ...currentState, ...state }); this.updateTotalPages(); } getPaginationState(): Observable<PaginationState> { return this.paginationStateSubject.asObservable(); } getPaginatedData(): Observable<TableRow[]> { return this.combineData().pipe( map(allData => this.paginateData(allData)) ); } private combineData(): Observable<TableRow[]> { return combineLatest([ this.dataSubject, this.newRowsSubject ]).pipe( map(([data, newRows]) => [...newRows, ...data]) ); } private paginateData(data: TableRow[]): TableRow[] { const state = this.paginationStateSubject.value; if (state.pageSize === 'all' || data.length <= 50) { return data; } const start = (state.currentPage - 1) * (+state.pageSize); const end = start + (+state.pageSize); return data.slice(start, end); } private updateTotalPages(): void { const currentState = this.paginationStateSubject.value; const totalItems = this.dataSubject.value.length + this.newRowsSubject.value.length; const totalPages = currentState.pageSize === 'all' || totalItems <= 50 ? 1 : Math.ceil(totalItems / +currentState.pageSize); this.paginationStateSubject.next({ ...currentState, totalPages }); } }
    |   |   --- ixt-table.type.ts: export interface TableRow { [key: string]: any; }
    |   +-- ixt-tabset
    |   |   --- ixt-tab.component.ts: import { Component, Input, TemplateRef, ViewChild } from '@angular/core'; @Component({ selector: 'ixt-tab', templateUrl: './ixt-tab.component.html', styleUrls: ['./ixt-tab.component.scss'] }) export class IxtTabComponent { @Input() title: string = ''; @ViewChild(TemplateRef, { static: true }) implicitContent!: TemplateRef<any>; }
    |   |   --- ixt-tabset.component.ts: import { Component, ContentChildren, QueryList, AfterContentInit } from '@angular/core'; import { IxtTabComponent } from './ixt-tab.component'; @Component({ selector: 'ixt-tabset', templateUrl: './ixt-tabset.component.html', styleUrls: ['./ixt-tabset.component.scss'] }) export class IxtTabsetComponent implements AfterContentInit { @ContentChildren(IxtTabComponent) tabs!: QueryList<IxtTabComponent>; selectedIndex: number = 0; notificationText: string = 'Content Band Icons or Info'; ngAfterContentInit() { // Set initial active tab if there are tabs if (this.tabs?.first) { this.selectTab(this.tabs.first); } // Listen for dynamic tab changes this.tabs?.changes.subscribe(() => { if (this.tabs.length && this.selectedIndex >= this.tabs.length) { this.selectTab(this.tabs.last); } }); } selectTab(tab: IxtTabComponent) { this.selectedIndex = this.tabs.toArray().indexOf(tab); } }
    |   |   --- ixt-tabset.index.ts: export * from './ixt-tabset.component'; export * from './ixt-tab.component'; // Updated path export * from './ixt-tabset.interfaces'; export * from './ixt-tabset.module';
    |   |   --- ixt-tabset.interfaces.ts: export interface ITabContent { id: string; title: string; content: string; active: boolean; } export interface ITabsetConfig { notificationText?: string; showNotificationBand?: boolean; animationDuration?: number; }
    |   |   --- ixt-tabset.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtTabsetComponent } from './ixt-tabset.component'; import { IxtTabComponent } from './ixt-tab.component'; // Updated path @NgModule({ declarations: [ IxtTabsetComponent, IxtTabComponent ], imports: [ CommonModule ], exports: [ IxtTabsetComponent, IxtTabComponent ] }) export class IxtTabsetModule { }
    |   +-- ixt-textra
    |   |   --- ixt-textra.component.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
    |   +-- ixt-tree
    |   |   --- ixt-tree.component.ts: // ixt-tree.component.ts import { Component, Input, Output, EventEmitter } from '@angular/core'; export interface TreeNode { id: string; label: string; expanded?: boolean; children?: TreeNode[]; isLeaf?: boolean; } @Component({ selector: 'ixt-tree', templateUrl: './ixt-tree.component.html', styleUrls: ['./ixt-tree.component.scss'] }) export class IxtTreeComponent { @Input() nodes: TreeNode[] = []; @Output() nodeExpanded = new EventEmitter<TreeNode>(); @Output() nodeCollapsed = new EventEmitter<TreeNode>(); @Output() nodeSelected = new EventEmitter<TreeNode>(); toggleNode(node: TreeNode, event: Event): void { event.stopPropagation(); if (node.children && node.children.length > 0) { node.expanded = !node.expanded; if (node.expanded) { this.nodeExpanded.emit(node); } else { this.nodeCollapsed.emit(node); } } } selectNode(node: TreeNode, event: Event): void { event.stopPropagation(); this.nodeSelected.emit(node); } trackByFn(index: number, item: TreeNode): string { return item.id; } }
    |   |   --- ixt-tree.index.ts: // ixt-tree.index.ts export * from './ixt-tree.component'; export * from './ixt-tree.module'; export interface TreeNode { id: string; label: string; expanded?: boolean; children?: TreeNode[]; isLeaf?: boolean; }
    |   |   --- ixt-tree.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTreeComponent } from './ixt-tree.component'; @NgModule({ declarations: [ IxtTreeComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtTreeComponent ] }) export class IxtTreeModule { }
    |   +-- ixt-viewport
    |   |   --- ixt-viewport.component.ts: // ixt-canvas.component.ts import { Component, ElementRef, ViewChild, AfterViewInit, HostListener } from '@angular/core'; interface Point { x: number; y: number; } interface Rect { x: number; y: number; width: number; height: number; } @Component({ selector: 'ixt-viewport', templateUrl: './ixt-viewport.component.html', styleUrls: ['./ixt-viewport.component.scss'] }) export class IxtViewportComponent implements AfterViewInit { @ViewChild('canvas') private canvasRef!: ElementRef<HTMLCanvasElement>; private ctx!: CanvasRenderingContext2D; // Drawing state private isDrawing = false; private lastPoint: Point | null = null; // Zooming state private isZooming = false; private zoomStart: Point | null = null; private zoomRect: Rect | null = null; private transform = { scale: 1, offsetX: 0, offsetY: 0 }; // Drawing settings private lineWidth = 2; private strokeStyle = '#000000'; ngAfterViewInit() { const canvas = this.canvasRef.nativeElement; this.ctx = canvas.getContext('2d')!; this.resizeCanvas(); this.initializeCanvas(); this.drawTestGraphics(); } private drawTestGraphics() { // Clear canvas this.clear(); // Draw some shapes this.ctx.save(); // Apply current transform this.ctx.scale(this.transform.scale, this.transform.scale); this.ctx.translate(this.transform.offsetX, this.transform.offsetY); // Rectangle this.ctx.fillStyle = '#ff0000'; this.ctx.fillRect(50, 50, 100, 100); // Circle this.ctx.beginPath(); this.ctx.fillStyle = '#0000ff'; this.ctx.arc(250, 100, 50, 0, Math.PI * 2); this.ctx.fill(); // Star this.drawStar(400, 100, 5, 50, 25); // Text this.ctx.fillStyle = '#000000'; this.ctx.font = '20px Arial'; this.ctx.fillText('Test Graphics', 50, 200); // Grid pattern this.drawGrid(); this.ctx.restore(); } private drawGrid() { this.ctx.strokeStyle = '#cccccc'; this.ctx.lineWidth = 0.5; // Draw vertical lines for (let x = 0; x < 800; x += 50) { this.ctx.beginPath(); this.ctx.moveTo(x, 0); this.ctx.lineTo(x, 600); this.ctx.stroke(); } // Draw horizontal lines for (let y = 0; y < 600; y += 50) { this.ctx.beginPath(); this.ctx.moveTo(0, y); this.ctx.lineTo(800, y); this.ctx.stroke(); } } private drawStar(cx: number, cy: number, spikes: number, outerRadius: number, innerRadius: number) { this.ctx.beginPath(); this.ctx.fillStyle = '#ffff00'; let rot = Math.PI / 2 * 3; let x = cx; let y = cy; let step = Math.PI / spikes; this.ctx.moveTo(cx, cy - outerRadius); for (let i = 0; i < spikes; i++) { x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; this.ctx.lineTo(x, y); rot += step; x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; this.ctx.lineTo(x, y); rot += step; } this.ctx.lineTo(cx, cy - outerRadius); this.ctx.closePath(); this.ctx.fill(); } @HostListener('window:resize') private resizeCanvas() { const canvas = this.canvasRef.nativeElement; canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; this.initializeCanvas(); this.drawTestGraphics(); } private initializeCanvas() { this.ctx.lineWidth = this.lineWidth; this.ctx.strokeStyle = this.strokeStyle; this.ctx.lineCap = 'round'; this.ctx.lineJoin = 'round'; } @HostListener('mousedown', ['$event']) onMouseDown(event: MouseEvent) { if (event.shiftKey) { // Start zooming when shift is held this.isZooming = true; this.zoomStart = this.getMousePos(event); this.zoomRect = null; } else { this.isDrawing = true; this.lastPoint = this.getMousePos(event); } } @HostListener('mousemove', ['$event']) onMouseMove(event: MouseEvent) { if (this.isZooming && this.zoomStart) { const currentPoint = this.getMousePos(event); // Calculate rubber band rectangle this.zoomRect = { x: Math.min(this.zoomStart.x, currentPoint.x), y: Math.min(this.zoomStart.y, currentPoint.y), width: Math.abs(currentPoint.x - this.zoomStart.x), height: Math.abs(currentPoint.y - this.zoomStart.y) }; // Redraw scene with rubber band this.drawTestGraphics(); this.drawRubberBand(); } else if (this.isDrawing && this.lastPoint) { const currentPoint = this.getMousePos(event); this.draw(this.lastPoint, currentPoint); this.lastPoint = currentPoint; } } @HostListener('mouseup', ['$event']) onMouseUp(event: MouseEvent) { if (this.isZooming && this.zoomRect) { // Calculate new transform based on zoom rectangle const canvas = this.canvasRef.nativeElement; const scaleX = canvas.width / this.zoomRect.width; const scaleY = canvas.height / this.zoomRect.height; const newScale = Math.min(scaleX, scaleY); // Update transform this.transform.scale *= newScale; this.transform.offsetX -= this.zoomRect.x / this.transform.scale; this.transform.offsetY -= this.zoomRect.y / this.transform.scale; // Redraw with new transform this.drawTestGraphics(); } this.isDrawing = false; this.isZooming = false; this.lastPoint = null; this.zoomStart = null; this.zoomRect = null; } @HostListener('mouseleave') onMouseLeave() { this.isDrawing = false; this.isZooming = false; this.lastPoint = null; this.zoomStart = null; this.zoomRect = null; } private drawRubberBand() { if (!this.zoomRect) return; this.ctx.save(); this.ctx.strokeStyle = '#000000'; this.ctx.lineWidth = 1; this.ctx.setLineDash([5, 5]); // Draw rubber band rectangle this.ctx.strokeRect( this.zoomRect.x, this.zoomRect.y, this.zoomRect.width, this.zoomRect.height ); this.ctx.restore(); } private getMousePos(event: MouseEvent): Point { const rect = this.canvasRef.nativeElement.getBoundingClientRect(); return { x: event.clientX - rect.left, y: event.clientY - rect.top }; } private draw(start: Point, end: Point) { this.ctx.save(); this.ctx.scale(this.transform.scale, this.transform.scale); this.ctx.translate(this.transform.offsetX, this.transform.offsetY); this.ctx.beginPath(); this.ctx.moveTo(start.x / this.transform.scale, start.y / this.transform.scale); this.ctx.lineTo(end.x / this.transform.scale, end.y / this.transform.scale); this.ctx.stroke(); this.ctx.closePath(); this.ctx.restore(); } // Public methods setColor(color: string) { this.strokeStyle = color; this.ctx.strokeStyle = color; } setLineWidth(width: number) { this.lineWidth = width; this.ctx.lineWidth = width; } clear() { const canvas = this.canvasRef.nativeElement; this.ctx.clearRect(0, 0, canvas.width, canvas.height); } resetZoom() { this.transform = { scale: 1, offsetX: 0, offsetY: 0 }; this.drawTestGraphics(); } }
    |   |   --- ixt-viewport.index.ts: // ixt-canvas.index.ts export * from './ixt-viewport.component'; export * from './ixt-viewport.module'; // // You might want to export interfaces/types if they're needed elsewhere // export interface DrawingConfig { // color?: string; // lineWidth?: number; // }
    |   |   --- ixt-viewport.module.ts: // ixt-canvas.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtViewportComponent } from './ixt-viewport.component'; @NgModule({ declarations: [ IxtViewportComponent ], imports: [ CommonModule ], exports: [ IxtViewportComponent ] }) export class IxtViewportModule { }
    |   \-- theme
    |       +-- styles
    |       |   \-- themes
    |       --- index.ts: // src/components/theme/index.ts export * from './theme.types'; export * from './theme.colors';
    |       --- theme.colors.ts: import { ThemeColors } from "./theme.types"; // src/app/theme/theme.colors.ts export const baseThemeColors: ThemeColors = { primary: { base: '#4169E1', // Royal Blue hover: '#2850c9', active: '#1e40af', text: '#ffffff' }, secondary: { base: '#6c757d', hover: '#5c636a', active: '#4d5154', text: '#ffffff' }, tertiary: { base: '#003057', // Rhapsody Blue (Pantone 289) hover: '#002649', // Darker shade for hover state active: '#001C3B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, success: { base: '#28a745', hover: '#218838', active: '#1e7e34', text: '#ffffff' }, danger: { base: '#dc3545', hover: '#c82333', active: '#bd2130', text: '#ffffff' }, warning: { base: '#ffc107', hover: '#e0a800', active: '#d39e00', text: '#000000' }, info: { base: '#17a2b8', hover: '#138496', active: '#117a8b', text: '#ffffff' }, light: { base: '#f8f9fa', hover: '#e2e6ea', active: '#dae0e5', text: '#000000' }, dark: { base: '#343a40', hover: '#23272b', active: '#1d2124', text: '#ffffff' }, default: { base: '#ffffff', hover: '#f8f9fa', active: '#e9ecef', text: '#000000' } }; // src/app/theme/theme.colors.ts export const unitedThemeColors: ThemeColors = { primary: { base: '#0033A0', // United Blue hover: '#00297A', // Darker shade for hover state active: '#002060', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, secondary: { base: '#6D2077', // Atlantic Amethyst hover: '#5A1A63', // Darker shade for hover state active: '#48154F', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, tertiary: { base: '#003057', // Rhapsody Blue (Pantone 289) hover: '#002649', // Darker shade for hover state active: '#001C3B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, success: { base: '#4CAF50', // Subtle green hover: '#43A047', // Darker shade for hover state active: '#388E3C', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, warning: { base: '#FF9800', // Warm yellow-orange hover: '#FB8C00', // Darker shade for hover state active: '#F57C00', // Even darker shade for active state text: '#000000' // Black text for readability }, danger: { base: '#E53935', // Tomato red hover: '#D32F2F', // Darker shade for hover state active: '#C62828', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, info: { base: '#17A2B8', // Standard info blue hover: '#138496', // Darker shade for hover state active: '#117A8B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, light: { base: '#F8F9FA', // Light gray hover: '#E2E6EA', // Darker shade for hover state active: '#DAE0E5', // Even darker shade for active state text: '#000000' // Black text for readability }, dark: { base: '#343A40', // Dark gray hover: '#23272B', // Darker shade for hover state active: '#1D2124', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, default: { base: '#FFFFFF', // White hover: '#F8F9FA', // Light gray for hover state active: '#E9ECEF', // Darker gray for active state text: '#000000' // Black text for readability } };
    |       --- theme.colors.united.ts: <empty file>
    |       --- theme.module.ts: // src/components/theme/theme.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [CommonModule], exports: [] }) export class ThemeModule {}
    |       --- theme.types.ts: // src/app/theme/theme.types.ts export type ThemeVariant = | 'primary' // Main brand color, key actions | 'secondary' // Supporting color | 'tertiary' | 'success' // Positive actions/states | 'danger' // Errors, destructive actions | 'warning' // Caution states | 'info' // Informational states | 'light' // Light backgrounds | 'dark' // Dark text/backgrounds | 'default'; // Default state export interface ThemeColor { base: string; hover: string; active: string; text: string; } export type ThemeColors = Record<ThemeVariant, ThemeColor>;
    +-- services
    |   --- breadcrumb.service.ts: import { Injectable } from '@angular/core'; import { Router, NavigationEnd, ActivatedRoute } from '@angular/router'; import { filter, map } from 'rxjs/operators'; import { Observable } from 'rxjs'; export interface Breadcrumb { label: string; url: string; } @Injectable({ providedIn: 'root' }) export class BreadcrumbService { breadcrumbs$: Observable<Breadcrumb[]>; constructor(private router: Router, private activatedRoute: ActivatedRoute) { this.breadcrumbs$ = this.router.events.pipe( filter(event => event instanceof NavigationEnd), map(event => { const root = this.activatedRoute.root; return this.createBreadcrumbs(root); }) ); } private createBreadcrumbs(route: ActivatedRoute, url: string = '', breadcrumbs: Breadcrumb[] = []): Breadcrumb[] { const children: ActivatedRoute[] = route.children; if (children.length === 0) { return breadcrumbs; } for (const child of children) { const routeURL: string = child.snapshot.url.map(segment => segment.path).join('/'); if (routeURL !== '') { url += `/${routeURL}`; } const label = child.snapshot.data['breadcrumb']; if (label) { breadcrumbs.push({ label, url }); } return this.createBreadcrumbs(child, url, breadcrumbs); } return breadcrumbs; } }
    --- index.ts: // src/index.ts export * from './public-api';
    --- main.ts: import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module'; platformBrowserDynamic().bootstrapModule(AppModule) .catch(err => console.error(err));
    --- public-api.ts: // public-api.ts //---------------------------------- Core Components & Services ---------------------------------- export { IxtTableModule, IxtTableComponent, AirportCodeEditorComponent, CoordinateEditorComponent, BinaryEditorComponent, TableEditor, ColumnConfigs, EditService, FilterService, SortService, SelectionService, PaginationService } from './components/ixt-table/ixt-table.index'; export { IxtDialogModule, IxtDialogComponent, IxtDialogService } from './components/ixt-dialog/ixt-dialog.index'; export { IxtTabsetModule, IxtTabComponent, IxtTabsetComponent, ITabContent, ITabsetConfig } from './components/ixt-tabset/ixt-tabset.index'; //------------------------------------ Basic UI Components ------------------------------------- export { IxtButtonModule, IxtButtonComponent, ButtonSize } from './components/ixt-button/ixt-button.index'; export { IxtPanelModule, IxtPanelComponent } from './components/ixt-panel/ixt-panel.index'; export { IxtMenuModule, IxtMenuComponent } from './components/ixt-menu/ixt-menu.index'; export { IxtTreeModule, IxtTreeComponent } from './components/ixt-tree/ixt-tree.index'; export { IxtAccordianModule, IxtAccordianComponent } from './components/ixt-accordian/ixt-accordian.index'; //--------------------------------- Canvas & View Components ---------------------------------- export { IxtCanvasModule, IxtCanvasComponent } from './components/ixt-canvas/ixt-canvas.index'; //------------------------------------ Form Components --------------------------------------- export { IxtExpressionBuilderComponent, IxtExpressionBuilderModule } from './components/ixt-expression-builder/ixt-expression-builder.index'; //----------------------------------- Diagram Components ------------------------------------ export { IxtDiagramModule, IxtDiagramComponent } from './components/ixt-diagram/ixt-diagram.index'; export { IxtClazzDiagram, IxtClazzModule } from './components/ixt-diagram/types/clazz/ixt-clazz.index'; export { IxtDeploymentDiagram, IxtDeploymentModule } from './components/ixt-diagram/types/deployment/ixt-deployment.index'; export { IxtEbnfDiagram, IxtEbnfModule } from './components/ixt-diagram/types/EBNF/ixt-ebnf.index'; export { IxtFlowDiagram, IxtFlowModule } from './components/ixt-diagram/types/flow/ixt-flow.index'; export { IxtGanntDiagram, IxtGanntModule } from './components/ixt-diagram/types/gannt/gannt.index'; export { IxtNetworkDiagram, IxtNetworkModule } from './components/ixt-diagram/types/network/ixt-network.index'; export { IxtSankeyDiagram, IxtSankeyModule } from './components/ixt-diagram/types/sankey/ixt-sankey.index'; export { IxtWireframeDiagram, IxtWireframeModule } from './components/ixt-diagram/types/wireframe/ixt-wireframe.index'; //-------------------------------- Map & Layer Components ---------------------------------- //-------------------------------- Map & Layer Components ---------------------------------- export { // Components & Modules IxtMapModule, IxtMapComponent, IxtLayerComponent, IxtLayerModule, // Services MapService, GeoProcessingService, LayerRenderService, LayerEventService, LayerStateService, MapErrorService, RouteProcessorService, // Types & Interfaces MapDimensions, MapState, MapContainer, MapSelection, PathSelection, MapServiceState, LayerEventHandlers, LayerRenderOptions, LayerState, MapError, MapErrorCode, RouteProcessingConfig, GeoFeatureProperties, GeoProcessingOptions, } from './components/ixt-map/ixt-map.index'; //----------------------------- Utility & Layout Components -------------------------------- // export { // IxtSplitPaneModule, // IxtSplitPaneComponent // } from './components/ixt-splitpane/index'; // export { // IxtCalendarModule // } from './components/ixt-calendar/ixt-calendar.index'; // //------------------------------------ Theme Exports -------------------------------------- // export { // ThemeVariant, // ThemeColor, // ThemeColors // } from './components/theme/theme.types'; // export { // baseThemeColors, // unitedThemeColors // } from './components/theme/theme.colors';
