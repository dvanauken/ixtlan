+-- .angular
|   \-- cache
\-- src
    +-- app
    |   +-- accordion
    |   |   --- accordion.data.ts: import { Injectable } from '@angular/core'; import { AccordionPanel } from '../../components/ixt-accordian/ixt-accordian.component'; @Injectable({ providedIn: 'root' }) export class AccordianDataService { getAccordianPanels(): AccordionPanel[] { return [ { title: 'Section 1', content: 'Content for section 1', isOpen: false }, { title: 'Section 2', content: 'Content for section 2', isOpen: false }, { title: 'Section 3', content: 'Content for section 3', isOpen: false } ]; } }
    |   +-- dialog
    |   |   --- ixt-dialog.handler.ts: <empty file>
    |   +-- expression
    |   |   --- ixt-expression.helper.ts: // src/app/expression/ixt-expression.helper.ts import { Injectable } from '@angular/core'; // Add this import { Expression, ExpressionGroup } from '../../components/ixt-expression-builder/ixt-expression-builder.interfaces'; @Injectable() export class IxtExpressionHelper { convertToJsonLogic(group: ExpressionGroup): any { if (group.children.length === 0) return {}; const logic: any = { [group.operator]: group.children.map((child: Expression | ExpressionGroup) => { if (child.type === 'group') { return this.convertToJsonLogic(child); } if (child.type === 'expression') { if (child.operator === 'in' || child.operator === 'not_in') { return { [child.operator === 'in' ? 'in' : '!in']: [ { var: child.field }, child.values || [] ] }; } return { [child.operator]: [ { var: child.field }, child.value ] }; } return {}; }) }; return logic; } }
    |   |   --- ixt-expression.provider.ts: // src/app/expression/ixt-expression.provider.ts import { Injectable } from '@angular/core'; // Add this import { Expression, ExpressionGroup } from '../../components/ixt-expression-builder/ixt-expression-builder.interfaces'; import { IxtExpressionHelper } from './ixt-expression.helper'; @Injectable() // Add this export class IxtExpressionProvider { expressionGroup: ExpressionGroup = { type: 'group', operator: 'and', children: [] }; expressionJsonLogic: any = {}; constructor(private helper: IxtExpressionHelper) {} onExpressionGroupChange(group: ExpressionGroup): void { this.expressionGroup = group; this.expressionJsonLogic = this.helper.convertToJsonLogic(group); } }
    |   +-- form
    |   |   --- ixt-employee-form.handler.ts: // src/app/form/ixt-employee-form.handler.ts import { Injectable } from '@angular/core'; import { IxtEmployeeFormProvider } from './ixt-employee-form.provider'; import { IxtDialogService } from '../../components/ixt-dialog/ixt-dialog.service'; import { EmployeeForm } from './ixt-employee-form.provider'; @Injectable() export class IxtEmployeeFormHandler { constructor( private provider: IxtEmployeeFormProvider, private dialogService: IxtDialogService ) {} async submitForm() { const form = this.provider.getCurrentForm(); // Validate form if (!this.validateForm(form)) { // this.dialogService.show({ // title: 'Validation Error', // message: 'Please fill in all required fields.', // type: DialogType.Error, // okText: 'OK', // showCancel: false, // isModal: true // }); return; } try { // Simulate API call await this.saveEmployee(form); // this.dialogService.show({ // title: 'Success', // message: 'Employee information saved successfully!', // type: DialogType.Success, // okText: 'OK', // showCancel: false, // isModal: true // }); this.provider.resetForm(); } catch (error) { // this.dialogService.show({ // title: 'Error', // message: 'Failed to save employee information. Please try again.', // type: DialogType.Error, // okText: 'OK', // showCancel: false, // isModal: true // }); } } confirmDelete(employeeId: number) { // this.dialogService.show({ // title: 'Confirm Delete', // message: 'Are you sure you want to delete this employee record?', // type: DialogType.Question, // okText: 'Yes', // cancelText: 'No', // showCancel: true, // isModal: true // }); } updateField(field: keyof EmployeeForm, value: any) { this.provider.updateForm({ [field]: value }); } private validateForm(form: EmployeeForm): boolean { return !!( form.firstName && form.lastName && form.email && form.department && form.position && form.hireDate ); } private async saveEmployee(form: EmployeeForm): Promise<void> { // Simulate API call return new Promise((resolve, reject) => { setTimeout(() => { // Simulate 90% success rate if (Math.random() > 0.1) { resolve(); } else { reject(new Error('Failed to save employee')); } }, 1000); }); } showUnsavedChangesDialog(): Promise<boolean> { return new Promise((resolve) => { // this.dialogService.show({ // title: 'Unsaved Changes', // message: 'You have unsaved changes. Do you want to continue?', // type: DialogType.Warning, // okText: 'Yes', // cancelText: 'No', // showCancel: true, // isModal: true // }); }); } resetForm() { // this.dialogService.show({ // title: 'Confirm Reset', // message: 'Are you sure you want to reset the form? All unsaved changes will be lost.', // type: DialogType.Warning, // okText: 'Yes', // cancelText: 'No', // showCancel: true, // isModal: true // }); } }
    |   |   --- ixt-employee-form.provider.ts: // src/app/form/ixt-employee-form.provider.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; export interface EmployeeForm { id?: number; firstName: string; lastName: string; email: string; phone: string; department: string; position: string; hireDate: Date; // Add any other employee fields you need } @Injectable() export class IxtEmployeeFormProvider { private formState = new BehaviorSubject<EmployeeForm>({ firstName: '', lastName: '', email: '', phone: '', department: '', position: '', hireDate: new Date() }); formState$ = this.formState.asObservable(); updateForm(form: Partial<EmployeeForm>) { this.formState.next({ ...this.formState.value, ...form }); } resetForm() { this.formState.next({ firstName: '', lastName: '', email: '', phone: '', department: '', position: '', hireDate: new Date() }); } getCurrentForm(): EmployeeForm { return this.formState.value; } }
    |   +-- layer
    |   |   --- ixt-layer.manager.ts: // src/app/layer/ixt-layer.manager.ts import { Injectable } from '@angular/core'; import { Layer } from '../../components/ixt-layer-manager/ixt-layer-manager.component'; @Injectable({ providedIn: 'root' // Makes it a singleton service available app-wide }) export class IxtLayerManager { onLayerChange(layers: any[]) { console.log('Layers updated:', layers); // Implement your layer update logic here } onLayerOrderChange(layers: any[]) { console.log('Layer order changed:', layers); // Implement your layer order update logic here } }
    |   |   --- ixt-layer.provider.ts: // src/app/layer/ixt-layer.provider.ts import { Injectable } from '@angular/core'; import { Layer } from '../../components/ixt-layer-manager/ixt-layer-manager.component'; @Injectable({ providedIn: 'root' // Makes it a singleton service available app-wide }) export class IxtLayerProvider { mapLayers: Layer[] = [ { id: 'layer1', name: 'Base Map', visible: true, fillColor: '#e3e3e3', strokeColor: '#666666', strokeStyle: 'solid' as const, order: 0 }, { id: 'layer2', name: 'Roads', visible: true, fillColor: '#ffffff', strokeColor: '#333333', strokeStyle: 'solid' as const, order: 1 }, { id: 'layer3', name: 'Points of Interest', visible: true, fillColor: '#ff4444', strokeColor: '#cc0000', strokeStyle: 'dotted' as const, order: 2 } ]; }
    |   +-- menu
    |   |   --- ixt-menu.provider.ts: // ixt-menu.provider.ts import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root' }) export class IxtMenuProvider { }
    |   +-- table
    |   |   --- ixt-table.provider.ts: // src/app/table/ixt-table.provider.ts import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { Observable } from 'rxjs'; import { IxtDialogService } from './../../components/ixt-dialog/ixt-dialog.service'; import { AirportCodeEditorComponent, ColumnConfigs, CoordinateEditorComponent } from './../../components/ixt-table/ixt-table.index'; @Injectable({ providedIn: 'root' }) export class IxtTableProvider { constructor( private http: HttpClient, private dialogService: IxtDialogService ) {} getColumnConfigs(): ColumnConfigs { return { code: { type: AirportCodeEditorComponent as any, field: 'code', editable: true, label: 'IATA Code' }, region: { type: 'text', field: 'region', label: 'Region', editable: true }, name: { type: 'text', field: 'name', label: 'Name', editable: true }, city: { type: 'text', field: 'city', label: 'City', editable: true }, country: { type: 'text', field: 'country', label: 'Country', editable: true }, lat: { type: CoordinateEditorComponent, field: 'lat', label: 'LAT', editable: true }, lon: { type: CoordinateEditorComponent, field: 'lon', label: 'LON', editable: true } }; } getAirportData(): Observable<any[]> { return this.http.get<any[]>('assets/Airport.json'); } getAirportColumnConfigs(): ColumnConfigs { return this.getColumnConfigs(); } }
    |   +-- tree
    |   |   --- ixt-tree.handler.ts: // src/app/tree/ixt-tree.handler.ts import { Injectable } from '@angular/core'; import { TreeNode } from '../../components/ixt-tree/ixt-tree.component'; @Injectable({ providedIn: 'root' }) export class IxtTreeHandler { onNodeExpanded(node: TreeNode): void { console.log('Node expanded:', node); } onNodeCollapsed(node: TreeNode): void { console.log('Node collapsed:', node); } onNodeSelected(node: TreeNode): void { console.log('Node selected:', node); } }
    |   |   --- ixt-tree.provider.ts: // src/app/tree/ixt-tree.provider.ts import { Injectable } from '@angular/core'; import { TreeNode } from '../../components/ixt-tree/ixt-tree.component'; @Injectable({ providedIn: 'root' }) export class IxtTreeProvider { treeData: TreeNode[] = [ { id: '1', label: 'Project Files', children: [ { id: '1.1', label: 'src', children: [ { id: '1.1.1', label: 'app', children: [ { id: '1.1.1.1', label: 'components' }, { id: '1.1.1.2', label: 'services' } ] }, { id: '1.1.2', label: 'assets' } ] }, { id: '1.2', label: 'config', children: [ { id: '1.2.1', label: 'tsconfig.json' }, { id: '1.2.2', label: 'package.json' } ] } ] } ]; }
    |   --- app.component.ts: import { Component, ViewChild, AfterViewInit } from '@angular/core'; import { IxtLayerProvider } from './layer/ixt-layer.provider'; import { IxtLayerManager } from './layer/ixt-layer.manager'; import { IxtTreeProvider } from './tree/ixt-tree.provider'; import { IxtTreeHandler } from './tree/ixt-tree.handler'; import { IxtExpressionProvider } from './expression/ixt-expression.provider'; import { IxtExpressionHelper } from './expression/ixt-expression.helper'; import { IxtEmployeeFormProvider } from './form/ixt-employee-form.provider'; import { IxtEmployeeFormHandler } from './form/ixt-employee-form.handler'; import { IxtTableProvider } from './table/ixt-table.provider'; import { IxtMenuProvider } from './menu/ixt-menu.provider'; import { AccordianDataService } from './accordion/accordion.data'; import { IxtDialogService } from './../components/ixt-dialog/ixt-dialog.service'; import { firstValueFrom } from 'rxjs'; import { NgForm } from '@angular/forms'; import { LunchFormComponent } from './lunch-form.component'; import { ThemeVariant, ThemeColors } from './../components/theme/theme.types'; import { baseThemeColors, unitedThemeColors } from './../components/theme/theme.colors'; // Add to existing AppComponent class export interface ButtonDemo { label: string; variant: ThemeVariant; size?: 'sm' | 'md' | 'lg'; theme?: ThemeColors; disabled: boolean; prefix?: string; suffix?: string; } @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'], providers: [ IxtLayerProvider, IxtLayerManager, IxtTreeProvider, IxtTreeHandler, IxtExpressionProvider, IxtExpressionHelper, IxtEmployeeFormProvider, IxtEmployeeFormHandler, IxtTableProvider, IxtMenuProvider ] }) export class AppComponent implements AfterViewInit { @ViewChild(LunchFormComponent, { static: true }) lunchForm!: LunchFormComponent; protected baseThemeColors = baseThemeColors; protected unitedThemeColors = unitedThemeColors; formData = this.employeeFormProvider.getCurrentForm(); tableAirportData: any[] = []; tableColumnConfigs = this.tableProvider.getAirportColumnConfigs(); accordionPanels = this.accordianDataService.getAccordianPanels(); constructor( private dialog: IxtDialogService, public layerProvider: IxtLayerProvider, public layerManager: IxtLayerManager, public treeProvider: IxtTreeProvider, public treeHandler: IxtTreeHandler, public expressionProvider: IxtExpressionProvider, public expressionHelper: IxtExpressionHelper, public employeeFormProvider: IxtEmployeeFormProvider, public employeeFormHandler: IxtEmployeeFormHandler, public tableProvider: IxtTableProvider, public menuProvider: IxtMenuProvider, private accordianDataService: AccordianDataService ) { } ngOnInit() { this.tableProvider.getAirportData().subscribe(data => { this.tableAirportData = data; }); } ngAfterViewInit() { } select(event: Event): void { console.log('Selected:', event); } highlight(event: Event): void { console.log('Highlighted:', event); } onSearch(searchTerm: string) { console.log('Search term:', searchTerm); } // Dialog examples using improved service ------------------------------------------------------ async showSuccessDialog() { console.log('Starting dialog test'); await this.dialog.success('Success123!', 'Success Dialog 456'); console.log('Dialog completed'); } buttonDemos: ButtonDemo[] = [ { label: 'Submit Form', variant: 'primary', size: 'lg', suffix: '→', disabled: false }, { label: 'Cancel', variant: 'secondary', size: 'lg', disabled: false }, { label: 'Delete Record', variant: 'danger', prefix: '⚠️', disabled: false }, { label: 'United Theme', variant: 'primary', theme: unitedThemeColors, size: 'lg', disabled: false }, { label: 'Processing...', variant: 'primary', disabled: true }, { label: 'View Details', variant: 'info', size: 'sm', disabled: false } ]; handleButtonClick(label: string) { console.log(`Button clicked: ${label}`); } }
    |   --- app.module.ts: import { NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { HttpClientModule } from '@angular/common/http'; import { RouterModule } from '@angular/router'; // Import components individually since library isn't published yet import { IxtButtonModule } from './../components/ixt-button/ixt-button.module'; import { IxtDialogModule } from './../components/ixt-dialog/ixt-dialog.module'; import { IxtTableModule } from './../components/ixt-table/ixt-table.module'; import { IxtTabsetModule } from './../components/ixt-tabset/ixt-tabset.module'; // Fixed name import { IxtTabComponent } from './../components/ixt-tabset/ixt-tab.component'; // Added individual component import { IxtPanelModule } from './../components/ixt-panel/ixt-panel.module'; import { IxtMenuModule } from './../components/ixt-menu/ixt-menu.module'; import { IxtTreeModule } from './../components/ixt-tree/ixt-tree.module'; import { IxtAccordianModule } from './../components/ixt-accordian/ixt-accordian.module'; // Fixed path import { IxtCanvasModule } from './../components/ixt-canvas/ixt-canvas.module'; import { IxtViewportModule } from './../components/ixt-viewport/ixt-viewport.module'; import { IxtExpressionBuilderModule } from './../components/ixt-expression-builder/ixt-expression-builder.module'; import { IxtMapModule } from './../components/ixt-map/ixt-map.module'; import { IxtLayerModule } from './../components/ixt-map/ixt-layer.module'; import { IxtLayerManagerModule } from './../components/ixt-layer-manager/ixt-layer-manager.module'; import { IxtSplitPaneModule } from './../components/ixt-splitpane/ixt-split-pane.module'; import { IxtCalendarModule } from './../components/ixt-calendar/ixt-calendar.module'; // Diagram Modules import { IxtDiagramModule } from './../components/ixt-diagram/ixt-diagram.module'; import { IxtClazzModule } from './../components/ixt-diagram/types/clazz/ixt-clazz.module'; import { IxtDeploymentModule } from './../components/ixt-diagram/types/deployment/ixt-deployment.module'; import { IxtEbnfModule } from './../components/ixt-diagram/types/EBNF/ixt-ebnf.module'; // Fixed path import { IxtFlowModule } from './../components/ixt-diagram/types/flow/ixt-flow.module'; import { IxtGanntModule } from './../components/ixt-diagram/types/gannt/gannt.module'; import { IxtNetworkModule } from './../components/ixt-diagram/types/network/ixt-network.module'; import { IxtSankeyModule } from './../components/ixt-diagram/types/sankey/ixt-sankey.module'; import { IxtWireframeModule } from './../components/ixt-diagram/types/wireframe/ixt-wireframe.module'; // Components import { AppComponent } from './app.component'; import { LunchFormComponent } from './lunch-form.component'; // Providers import { IxtEmployeeFormHandler } from './form/ixt-employee-form.handler'; import { IxtEmployeeFormProvider } from './form/ixt-employee-form.provider'; import { IxtExpressionHelper } from './expression/ixt-expression.helper'; import { IxtExpressionProvider } from './expression/ixt-expression.provider'; import { IxtLayerManager } from './layer/ixt-layer.manager'; import { IxtLayerProvider } from './layer/ixt-layer.provider'; import { IxtTreeHandler } from './tree/ixt-tree.handler'; import { IxtTableProvider } from './table/ixt-table.provider'; import { IxtTreeProvider } from './tree/ixt-tree.provider'; @NgModule({ declarations: [ AppComponent, LunchFormComponent ], imports: [ // Angular Core Modules BrowserModule, BrowserAnimationsModule, FormsModule, ReactiveFormsModule, HttpClientModule, RouterModule.forRoot([]), // Ixtlan Modules IxtAccordianModule, IxtButtonModule, IxtCalendarModule, IxtCanvasModule, IxtDialogModule, IxtDiagramModule, IxtExpressionBuilderModule, IxtLayerModule, // Added Layer module IxtLayerManagerModule, IxtMapModule, IxtMenuModule, IxtPanelModule, IxtSplitPaneModule, IxtTableModule, IxtTreeModule, IxtTabsetModule, IxtViewportModule, // Diagram Type Modules IxtClazzModule, IxtDeploymentModule, IxtEbnfModule, IxtFlowModule, IxtGanntModule, IxtNetworkModule, IxtSankeyModule, IxtWireframeModule ], providers: [ IxtEmployeeFormHandler, IxtEmployeeFormProvider, IxtExpressionHelper, IxtExpressionProvider, IxtLayerManager, IxtLayerProvider, IxtTreeHandler, IxtTreeProvider, IxtTableProvider ], schemas: [ CUSTOM_ELEMENTS_SCHEMA // Added schema for custom elements ], bootstrap: [AppComponent] }) export class AppModule { }
    |   --- lunch-form.component.ts: import { Component, ViewChild, TemplateRef, OnInit, EventEmitter, Output } from '@angular/core'; import { NgForm } from '@angular/forms'; import { IxtDialogService } from './../components/ixt-dialog/ixt-dialog.service'; import { firstValueFrom } from 'rxjs'; interface LunchOrder { sandwich: string; side: string; drink: string; customerName: string; isTakeout: boolean; } @Component({ selector: 'app-lunch-form', templateUrl: './lunch-form.component.html', styleUrls: ['./lunch-form.component.scss'], }) export class LunchFormComponent implements OnInit { @Output() init = new EventEmitter<LunchFormComponent>(); @ViewChild('lunchOrderTemplate') lunchOrderTemplate!: TemplateRef<any>; @ViewChild('orderForm') orderForm!: NgForm; orderData: LunchOrder = { sandwich: '', side: '', drink: '', customerName: '', isTakeout: false }; constructor(private dialogService: IxtDialogService) { } ngOnInit(): void { this.init.emit(this); } private getFormData(): LunchOrder { return { sandwich: this.orderData.sandwich, // Bound to the "Sandwich" field side: this.orderData.side, // Bound to the "Side" field drink: this.orderData.drink, // Bound to the "Drink" field customerName: this.orderData.customerName, // Bound to the "Name for order" field isTakeout: this.orderData.isTakeout, // Bound to the "Takeout?" checkbox }; } private resetForm(): void { // Reset the form fields to default values this.orderData = { sandwich: '', side: '', drink: '', customerName: '', isTakeout: false, }; // Reset the form state if it exists if (this.orderForm) { this.orderForm.resetForm(this.orderData); } } public showLunchOrderDialog(): Promise<{ status: 'OK' | 'Cancel'; data?: LunchOrder }> { // Reset form data and state this.resetForm(); return new Promise((resolve) => { // this.dialogService.template('Lunch Order', this.lunchOrderTemplate, { // buttons: [ // { // text: 'Place Order', // action: () => { // if (this.orderForm?.valid) { // const formData = this.getFormData(); // Get the form data // resolve({ status: 'OK', data: formData }); // Resolve with structured success result // return formData; // Required by the dialogService to process the action // } else { // this.dialogService.warning('Please fill out all required fields'); // return false; // Prevent dialog from closing if validation fails // } // }, // close: true, // Ensure dialog closes // }, // { // text: 'Cancel', // action: () => { // resolve({ status: 'Cancel' }); // Resolve with cancel status // }, // close: true, // Ensure dialog closes // }, // ], // }).subscribe({ // complete: () => { // console.log('Dialog closed'); // Ensure the dialog completes properly // }, // }); }); } }
    +-- assets
    |   --- .gitkeep: <empty file>
    |   --- logo.png: <image file>
    |   --- logo2.png: <image file>
    +-- components
    |   +-- ixt-colorpalette
    |   |   --- ixt-canvas.component.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
    |   +-- ixt-dialog
    |   |   +-- types
    |   |   |   +-- color
    |   |   |   |   --- ixt-color.dialog.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
    |   |   |   +-- confirm
    |   |   |   |   --- ixt-confirm.dialog.ts: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
    |   |   |   +-- error
    |   |   |   |   --- ixt-error.dialog.ts: // ixt-error-template.ts export const ERROR_TEMPLATE = ` <div role="alert"> <p>{{message}}</p> </div> `;
    |   |   |   +-- font
    |   |   |   |   --- ixt-font.dialog.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
    |   |   |   +-- form
    |   |   |   |   --- ixt-form.dialog.ts: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
    |   |   |   +-- info
    |   |   |   |   --- ixt-confirm.dialog.ts: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
    |   |   |   |   --- ixt-info-template.component.ts: // ixt-info-template.component.ts import { Component, Input } from '@angular/core'; @Component({ template: ` <div role="status"> <p>{{message}}</p> </div> `, standalone: true }) export class InfoTemplateComponent { @Input() message!: string; }
    |   |   |   +-- prompt
    |   |   |   |   --- ixt-prompt.dialog.ts: // ixt-confirm-template.ts export const CONFIRM_TEMPLATE = ` <div role="alertdialog"> <p>{{message}}</p> </div> `;
    |   |   |   +-- success
    |   |   |   |   --- ixt-success-dialog.component.ts: // ixt-success-dialog.component.ts import { Component, Input } from '@angular/core'; import { ThemeColors, ThemeVariant } from '../../../theme/theme.types'; import { baseThemeColors } from '../../../theme/theme.colors'; @Component({ selector: 'ixt-success-dialog', templateUrl: './ixt-success-dialog.component.html', styleUrls: ['./ixt-success-dialog.component.scss'] }) export class SuccessDialogComponent { @Input() message?: string; @Input() variant: ThemeVariant = 'success'; @Input() theme: ThemeColors = baseThemeColors; get themeStyles() { const colors = this.theme[this.variant]; return { 'background-color': `${colors.base}15`, // 15% opacity 'color': '#0f0', //colors.base, 'border-color': colors.base }; } }
    |   |   |   \-- warn
    |   |   |       --- ixt-warn.dialog.ts: // ixt-warn-template.ts export const WARN_TEMPLATE = ` <div role="alert"> <p>{{message}}</p> </div> `;
    |   |   |       --- ixt-warn.scss.ts: // ixt-warn-template.ts export const WARN_TEMPLATE = ` <div role="alert"> <p>{{message}}</p> </div> `;
    |   |   --- ixt-dialog.component.ts: import { Component, ViewChild, ElementRef, Input, Output, EventEmitter, ViewContainerRef, ComponentFactoryResolver, Type, AfterViewInit } from '@angular/core'; import { baseThemeColors } from './../theme/theme.colors'; import { ThemeVariant, ThemeColors } from './../theme/theme.types'; @Component({ selector: 'ixt-dialog', templateUrl: './ixt-dialog.component.html', styleUrls: ['./ixt-dialog.component.scss'] }) export class IxtDialogComponent { @ViewChild('dialog') public dialog!: ElementRef<HTMLDialogElement>; @ViewChild('contentHost', { read: ViewContainerRef, static: true }) contentHost!: ViewContainerRef; @Input() modal: boolean = true; @Input() title: string = ''; @Input() variant: ThemeVariant = 'primary'; @Input() theme: ThemeColors = baseThemeColors; @Output() close = new EventEmitter<boolean>(); constructor() {} open() { if (this.modal) { this.dialog.nativeElement.showModal(); } else { this.dialog.nativeElement.show(); } } closeDialog(result: boolean) { this.dialog.nativeElement.close(); this.close.emit(result); } get themeStyles() { const colors = this.theme[this.variant]; return { 'background-color': colors.base, 'color': colors.text, '--theme-hover': colors.hover, '--theme-active': colors.active, '--theme-text': colors.text }; } }
    |   |   --- ixt-dialog.index.ts: export * from './ixt-dialog.module'; export { IxtDialogComponent } from './ixt-dialog.component'; export { IxtDialogService } from './ixt-dialog.service';
    |   |   --- ixt-dialog.module.ts: // ixt-dialog.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { MatButtonModule } from '@angular/material/button'; import { MatIconModule } from '@angular/material/icon'; import { IxtDialogComponent } from './ixt-dialog.component'; import { IxtDialogService } from './ixt-dialog.service'; // Add this import { FormsModule } from '@angular/forms'; import { SuccessDialogComponent } from './types/success/ixt-success-dialog.component'; @NgModule({ declarations: [ IxtDialogComponent, SuccessDialogComponent // Add this ], imports: [ CommonModule, MatButtonModule, MatIconModule, FormsModule ], exports: [IxtDialogComponent], providers: [IxtDialogService] // Add this }) export class IxtDialogModule { }
    |   |   --- ixt-dialog.service.ts: // ixt-dialog.service.ts import { ApplicationRef, ComponentFactoryResolver, ComponentRef, Injectable, Injector, Type, createComponent } from '@angular/core'; import { IxtDialogComponent } from './ixt-dialog.component'; import { firstValueFrom } from 'rxjs'; import { SuccessDialogComponent } from './types/success/ixt-success-dialog.component'; @Injectable({ providedIn: 'root' }) export class IxtDialogService { private dialogComponentRef!: ComponentRef<IxtDialogComponent>; constructor( private componentFactoryResolver: ComponentFactoryResolver, private appRef: ApplicationRef, private injector: Injector ) { } // async openDialog(component: Type<any>, title: string, message: string, modal: boolean = true): Promise<boolean> { // this.dialogComponentRef = this.componentFactoryResolver // .resolveComponentFactory(IxtDialogComponent) // .create(this.injector); // const instance = this.dialogComponentRef.instance; // instance.title = title; // instance.modal = modal; // this.appRef.attachView(this.dialogComponentRef.hostView); // const domElem = (this.dialogComponentRef.hostView as any).rootNodes[0]; // document.body.appendChild(domElem); // // Allow time for component initialization // await new Promise(resolve => requestAnimationFrame(resolve)); // // Just create once and set message // const contentComponent = instance.contentHost.createComponent(component); // contentComponent.instance.message = message; // instance.open(); // // Wait for dialog result // const result = await firstValueFrom(instance.close); // document.body.removeChild(domElem); // this.appRef.detachView(this.dialogComponentRef.hostView); // this.dialogComponentRef.destroy(); // return result; // } async openDialog(component: Type<any>, title: string, message: string, modal: boolean = true): Promise<boolean> { this.dialogComponentRef = this.componentFactoryResolver .resolveComponentFactory(IxtDialogComponent) .create(this.injector); const instance = this.dialogComponentRef.instance; instance.title = title; instance.modal = modal; this.appRef.attachView(this.dialogComponentRef.hostView); const domElem = (this.dialogComponentRef.hostView as any).rootNodes[0]; document.body.appendChild(domElem); // Ensure ViewContainerRef is ready await new Promise(resolve => requestAnimationFrame(resolve)); // Clear any existing content instance.contentHost.clear(); // Create the component in the ViewContainerRef const contentComponentRef = instance.contentHost.createComponent(component); contentComponentRef.instance.message = message; instance.open(); const result = await firstValueFrom(instance.close); document.body.removeChild(domElem); this.appRef.detachView(this.dialogComponentRef.hostView); this.dialogComponentRef.destroy(); return result; } // async openDialog(component: Type<any>, title: string, message: string, modal: boolean = true): Promise<boolean> { // // Dynamically create the dialog component // this.dialogComponentRef = this.componentFactoryResolver // .resolveComponentFactory(IxtDialogComponent) // .create(this.injector); // // Attach the component to the view // this.appRef.attachView(this.dialogComponentRef.hostView); // // Append the component to the DOM // const componentElement = (this.dialogComponentRef.hostView as any).rootNodes[0]; // document.body.appendChild(componentElement); // // Set inputs on the dialog component // const instance = this.dialogComponentRef.instance; // instance.title = title; // instance.message = message; // Set message input // instance.modal = modal; // // Open the dialog // instance.open(); // // Return a promise that resolves when the dialog emits `close` // return firstValueFrom(instance.close); // } closeDialog(result: boolean): void { if (this.dialogComponentRef) { this.dialogComponentRef.instance.closeDialog(result); } } // async success(message: string, title: string): Promise<boolean> { // return await this.openDialog(SuccessDialogComponent, title, true); // } // async success(message: string, title: string): Promise<boolean> { // const dialogRef = this.componentFactoryResolver // .resolveComponentFactory(SuccessDialogComponent) // .create(this.injector); // // Set the message before creating dialog // dialogRef.instance.message = message; // return await this.openDialog(SuccessDialogComponent, message, title, true); // } async success(message: string, title: string): Promise<boolean> { return await this.openDialog(SuccessDialogComponent, title, message, true); } }
    |   +-- ixt-form
    |   |   +-- ixt-binary
    |   |   |   --- ixt-binary..module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTextEditorComponent } from './ixt-text-editor.component'; @NgModule({ declarations: [ IxtTextEditorComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtTextEditorComponent ] }) export class IxtTableModule { }
    |   |   |   --- ixt-binary.editor.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-text-editor', templateUrl: './ixt-text-editor.component.html', styleUrls: ['./ixt-text-editor.component.scss'] }) export class IxtTextEditorComponent { }
    |   |   +-- ixt-date
    |   |   |   --- ixt-date..module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTextEditorComponent } from './ixt-text-editor.component'; @NgModule({ declarations: [ IxtTextEditorComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtTextEditorComponent ] }) export class IxtTableModule { }
    |   |   |   --- ixt-date.editor.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-text-editor', templateUrl: './ixt-text-editor.component.html', styleUrls: ['./ixt-text-editor.component.scss'] }) export class IxtTextEditorComponent { }
    |   |   +-- ixt-input
    |   |   |   --- ixt-input.editor.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-input', templateUrl: './ixt-input.component.html', styleUrls: ['./ixt-input.component.scss'] }) export class IxtInputComponent { }
    |   |   |   --- ixt-input.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtInputComponent } from './ixt-input.component'; @NgModule({ declarations: [ IxtInputComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtInputComponent ] }) export class IxtInputModule { }
    |   |   +-- ixt-select
    |   |   |   --- ixt-select.editor.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-select', templateUrl: './ixt-select.component.html', styleUrls: ['./ixt-select.component.scss'] }) export class IxtSelectComponent { }
    |   |   |   --- ixt-select.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtSelectComponent } from './ixt-select.component'; @NgModule({ declarations: [ IxtSelectComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtSelectComponent ] }) export class IxtSelectModule { }
    |   |   +-- ixt-text
    |   |   |   --- ixt-text.editor.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-text', templateUrl: './ixt-text.component.html', styleUrls: ['./ixt-text.component.scss'] }) export class IxtTextComponent { }
    |   |   |   --- ixt-text.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTableComponent } from './ixt-text.component'; @NgModule({ declarations: [ IxtTextComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtTextComponent ] }) export class IxtTableModule { }
    |   |   +-- ixt-time
    |   |   |   --- ixt-time..module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtTextEditorComponent } from './ixt-text-editor.component'; @NgModule({ declarations: [ IxtTextEditorComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtTextEditorComponent ] }) export class IxtTableModule { }
    |   |   |   --- ixt-time.editor.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-text-editor', templateUrl: './ixt-text-editor.component.html', styleUrls: ['./ixt-text-editor.component.scss'] }) export class IxtTextEditorComponent { }
    |   |   --- ixt-form.component.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-form', templateUrl: './ixt-form.component.html', styleUrls: ['./ixt-form.component.scss'] }) export class IxtFormComponent { }
    |   |   --- ixt-form.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtFormComponent } from './ixt-form.component'; @NgModule({ declarations: [ IxtFormComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtFormComponent ] }) export class IxtFormModule { }
    |   +-- ixt-image
    |   |   --- ixt-image.component.ts: import { Component } from '@angular/core'; @Component({ selector: 'ixt-ixt-image', templateUrl: './ixt-image.component.html', styleUrls: ['./ixt-image.component.scss'] }) export class IxtImageComponent { }
    |   |   --- ixt-image.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { IxtImageComponent } from './ixt-image.component'; @NgModule({ declarations: [ IxtImageComponent ], imports: [ CommonModule, FormsModule ], exports: [ IxtImageComponent ] }) export class IxtImageModule { }
    |   +-- ixt-layer-manager
    |   |   --- ixt-layer-manager.component.ts: // ixt-layer-manager.component.ts import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core'; import { CdkDragDrop, moveItemInArray } from '@angular/cdk/drag-drop'; export interface Layer { id: string; name: string; visible: boolean; fillColor: string; strokeColor: string; strokeStyle: 'solid' | 'dashed' | 'dotted'; order: number; } @Component({ selector: 'ixt-layer-manager', templateUrl: './ixt-layer-manager.component.html', styleUrls: ['./ixt-layer-manager.component.scss'] }) export class IxtLayerManagerComponent implements OnInit { @Input() layers: Layer[] = []; @Output() layerChange = new EventEmitter<Layer[]>(); @Output() layerOrderChange = new EventEmitter<Layer[]>(); selectedLayer: Layer | null = null; showColorPicker = false; activeProperty: 'fill' | 'stroke' | null = null; showStrokeStylePicker = false; strokeStyles: Array<Layer['strokeStyle']> = ['solid', 'dashed', 'dotted']; ngOnInit(): void { this.sortLayers(); } sortLayers(): void { this.layers.sort((a, b) => a.order - b.order); } onDrop(event: CdkDragDrop<Layer[]>): void { moveItemInArray(this.layers, event.previousIndex, event.currentIndex); this.layers.forEach((layer, index) => { layer.order = index; }); this.layerOrderChange.emit(this.layers); } toggleVisibility(layer: Layer): void { layer.visible = !layer.visible; this.layerChange.emit(this.layers); } openColorPicker(layer: Layer, property: 'fill' | 'stroke'): void { this.selectedLayer = layer; this.activeProperty = property; this.showColorPicker = true; } openStrokeStylePicker(layer: Layer): void { this.selectedLayer = layer; this.showStrokeStylePicker = true; } onColorSelect(color: string): void { if (this.selectedLayer && this.activeProperty) { if (this.activeProperty === 'fill') { this.selectedLayer.fillColor = color; } else { this.selectedLayer.strokeColor = color; } this.layerChange.emit(this.layers); } } onStrokeStyleSelect(style: Layer['strokeStyle']): void { if (this.selectedLayer) { this.selectedLayer.strokeStyle = style; this.layerChange.emit(this.layers); this.closeStrokeStylePicker(); } } closeColorPicker(): void { this.showColorPicker = false; this.selectedLayer = null; this.activeProperty = null; } closeStrokeStylePicker(): void { this.showStrokeStylePicker = false; this.selectedLayer = null; } }
    |   |   --- ixt-layer-manager.index.ts: // ixt-layer-manager.index.ts export * from './ixt-layer-manager.component'; export * from './ixt-layer-manager.module'; export interface Layer { id: string; name: string; visible: boolean; fillColor: string; strokeColor: string; strokeStyle: 'solid' | 'dashed' | 'dotted'; order: number; }
    |   |   --- ixt-layer-manager.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { DragDropModule } from '@angular/cdk/drag-drop'; import { IxtLayerManagerComponent } from './ixt-layer-manager.component'; @NgModule({ declarations: [IxtLayerManagerComponent], imports: [ CommonModule, DragDropModule ], exports: [IxtLayerManagerComponent] }) export class IxtLayerManagerModule { }
    |   +-- ixt-map
    |   |   +-- models
    |   |   |   \-- sphere
    |   |   |       +-- types
    |   |   |       |   --- GeometryCollection.ts: <empty file>
    |   |   |       |   --- LineString.ts: <empty file>
    |   |   |       |   --- MultiLineString.ts: <empty file>
    |   |   |       |   --- MultiPoint.ts: <empty file>
    |   |   |       |   --- MultiPolygon.ts: <empty file>
    |   |   |       |   --- Point.ts: <empty file>
    |   |   |       |   --- Polygon.ts: <empty file>
    |   |   |       --- Angle.ts: <empty file>
    |   |   |       --- Arc.ts: <empty file>
    |   |   |       --- Azimuth.ts: <empty file>
    |   |   |       --- Bearing.ts: <empty file>
    |   |   |       --- Collection.ts: <empty file>
    |   |   |       --- Coordinate.ts: <empty file>
    |   |   |       --- Geodesic.ts: <empty file>
    |   |   |       --- GreatCircle.ts: <empty file>
    |   |   |       --- Horizon.ts: <empty file>
    |   |   |       --- Luxodrome.ts: <empty file>
    |   |   |       --- Nadir.ts: <empty file>
    |   |   |       --- Point.ts: <empty file>
    |   |   |       --- Polygon.ts: <empty file>
    |   |   |       --- Rhumb.ts: <empty file>
    |   |   |       --- SmallCircle.ts: <empty file>
    |   |   |       --- Sphere.ts: <empty file>
    |   |   |       --- Triangle.ts: <empty file>
    |   |   |       --- Zenith.ts: <empty file>
    |   |   +-- types
    |   |   |   +-- azimuthal
    |   |   |   |   +-- gnomic
    |   |   |   |   |   --- gnomic.projection.ts: <empty file>
    |   |   |   |   +-- orthographic
    |   |   |   |   |   --- orthographic.projection.ts: <empty file>
    |   |   |   |   +-- perspective
    |   |   |   |   |   --- perspective.projection.ts: <empty file>
    |   |   |   |   --- azimuthal.projection.ts: <empty file>
    |   |   |   +-- conical
    |   |   |   |   \-- lambert
    |   |   |   |       --- lambert.projection.ts: <empty file>
    |   |   |   \-- cylindrical
    |   |   |       \-- utm
    |   |   |           --- utm.projection.ts: <empty file>
    |   |   --- geo-processing.service.ts: // Create the GeoJSON processing service (geo-processing.service.ts) import { Injectable } from '@angular/core'; import { Feature, LineString, GeoJsonProperties, Geometry } from 'geojson'; import * as d3 from 'd3'; import { GeoFeatureProperties, GeoProcessingOptions } from './geo.types'; @Injectable({ providedIn: 'root' }) export class GeoProcessingService { processFeatures(features: Feature[], options: GeoProcessingOptions = {}): Feature[] { let processedFeatures = [...features]; // Apply route interpolation if needed if (options.interpolateRoutes) { processedFeatures = this.interpolateRoutes(processedFeatures, { pointsPerRoute: options.pointsPerRoute, minPoints: options.minPointsPerRoute }); } // Apply filtering if expression provided if (options.filterExpression) { processedFeatures = this.filterFeatures(processedFeatures, options.filterExpression); } return processedFeatures; } private interpolateRoutes( features: Feature[], options: { pointsPerRoute?: number; minPoints?: number } = {} ): Feature[] { const minPoints = options.minPoints || 5; return features.map(feature => { if (feature.geometry.type !== 'LineString') { return feature; } const line = feature.geometry as LineString; const coordinates = line.coordinates; if (coordinates.length !== 2) { return feature; } const start = coordinates[0] as [number, number]; const end = coordinates[1] as [number, number]; const route = d3.geoInterpolate(start, end); // Calculate distance and points const distance = d3.geoDistance(start, end) * 3959; // Earth radius in miles const pointsPer5Miles = Math.ceil(distance / 5); const numPoints = Math.max(minPoints, options.pointsPerRoute || pointsPer5Miles); const newCoordinates = Array.from({ length: numPoints }, (_, i) => { const t = i / (numPoints - 1); return route(t); }); return { ...feature, geometry: { ...line, coordinates: newCoordinates } }; }); } private filterFeatures(features: Feature[], expression: string): Feature[] { const filterFn = this.createFilterFunction(expression); return features.filter(feature => { try { return filterFn ? filterFn(feature) : true; } catch (e) { console.error('Error applying filter to feature:', e); return true; } }); } private createFilterFunction(expression: string): Function | null { if (!expression) return null; try { return new Function('feature', ` try { const properties = feature.properties; return ${expression}; } catch (e) { console.error('Filter expression error:', e); return true; } `); } catch (e) { console.error('Error creating filter function:', e); return null; } } // private createFilterFunction(): Function | null { // if (!this.filterExpression) return null; // console.log('Creating filter with expression:', this.filterExpression); // return new Function('feature', ` // try { // const properties = feature.properties; // //console.log('Evaluating:', properties); // return ${this.filterExpression}; // } catch (e) { // console.error('Filter expression error:', e); // return true; // If there's an error, include the feature // } // `); // } }
    |   |   --- geo.types.ts: // First, let's create the interfaces (geo.types.ts) export interface GeoFeatureProperties { [key: string]: any; } export interface GeoProcessingOptions { interpolateRoutes?: boolean; pointsPerRoute?: number; minPointsPerRoute?: number; filterExpression?: string; }
    |   |   --- ixt-layer.component.ts: import { Component, Input, Output, EventEmitter, ElementRef, Host, ChangeDetectionStrategy, ChangeDetectorRef, SimpleChanges } from '@angular/core'; import * as d3 from 'd3'; import { IxtMapComponent } from './ixt-map.component'; import { GeoProcessingService } from './geo-processing.service'; import { LayerRenderService } from './layer-render.service'; import { LayerEventHandlers, LayerEventService } from './layer-event.service'; import { LayerStateService } from './layer-state.service'; import { Feature } from 'geojson'; @Component({ selector: 'ixt-layer', template: ` <svg:g> <ng-content></ng-content> </svg:g> `, changeDetection: ChangeDetectionStrategy.OnPush }) export class IxtLayerComponent { @Input() src: string = ''; @Input() stroke: string = 'black'; @Input() fill: string = 'none'; @Output() click = new EventEmitter<MouseEvent>(); @Output() hover = new EventEmitter<MouseEvent>(); private initialized = false; private pathGenerator!: d3.GeoPath; private filterExpression: string = ''; constructor( @Host() private mapComponent: IxtMapComponent, private elementRef: ElementRef, private cdr: ChangeDetectorRef, private geoProcessingService: GeoProcessingService, private layerRenderService: LayerRenderService, private layerEventService: LayerEventService, private layerStateService: LayerStateService ) { } ngOnChanges(changes: SimpleChanges) { if ((changes['src'] || changes['stroke'] || changes['fill']) && this.initialized) { this.initializeLayer(); } } ngAfterContentInit() { const content = this.elementRef.nativeElement.textContent?.trim(); if (content) { this.filterExpression = content; } } setProjection(pathGenerator: d3.GeoPath): void { this.pathGenerator = pathGenerator; this.initializeLayer(); } async initializeLayer(): Promise<void> { if (this.initialized) return; if (!this.validateContainer()) return; try { const features = await this.loadGeoJsonData(); const handlers = this.createEventHandlers(); this.renderLayer(features, handlers); this.initialized = true; } catch (error) { console.error('Layer initialization failed:', error); } } private validateContainer(): boolean { const container = this.mapComponent.getContainer(); if (!container || !this.pathGenerator) { console.error('Map container or projection not ready'); return false; } return true; } private async loadGeoJsonData(): Promise<Feature[]> { const data = await d3.json(this.src) as { features: Feature[] }; return this.geoProcessingService.processFeatures(data.features, { interpolateRoutes: true, filterExpression: this.filterExpression }); } private async renderLayer(features: any, handlers: any): Promise<void> { const container = this.mapComponent.getContainer(); const selection = this.layerRenderService.createLayer( d3.select(container.nativeElement), features, { stroke: this.stroke, fill: this.fill }, handlers ); this.layerStateService.addSelection(selection); this.cdr.markForCheck(); } private createEventHandlers(): LayerEventHandlers { return { onClick: (event: MouseEvent, datum: any) => { this.layerEventService.handleClick(event, this.mapComponent); this.click.emit(event); }, onMouseOver: (event: MouseEvent) => { this.layerEventService.handleMouseOver(event, this.mapComponent); this.hover.emit(event); }, onMouseOut: () => this.layerEventService.handleMouseOut(), onMouseMove: (event: MouseEvent) => event.stopPropagation() }; } ngOnDestroy(): void { this.layerStateService.clearSelections(); } }
    |   |   --- ixt-layer.module.ts: // src/components/ixt-map/layer/ixt-layer.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtLayerComponent } from './ixt-layer.component'; @NgModule({ declarations: [ IxtLayerComponent ], imports: [ CommonModule ], exports: [ IxtLayerComponent ] }) export class IxtLayerModule { }
    |   |   --- ixt-map.component.ts: import { Component, Input, ViewChild, ElementRef, ContentChildren, QueryList, AfterContentInit, OnDestroy, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core'; import * as d3 from 'd3'; import { IxtLayerComponent } from './ixt-layer.component'; import { GeoProjection, GeoPath } from 'd3'; import { BehaviorSubject, Subscription } from 'rxjs'; import { MapService } from './map.service'; import { MapDimensions, MapSelection, PathSelection, MapContainer } from './map.types'; @Component({ selector: 'ixt-map', template: ` <svg #mapSvg [attr.width]="width" [attr.height]="height" [attr.viewBox]="getViewBox()" style="display: block; background: lightgray;"> <g #mapGroup> <ng-content></ng-content> </g> </svg> `, styles: [` :host { display: block; } svg { display: block; } `], changeDetection: ChangeDetectionStrategy.OnPush }) export class IxtMapComponent implements AfterContentInit, OnDestroy { @Input() width: string | number = 800; @Input() height: string | number = 600; @Input() scale: string | number = 1; @Input() translate: string = '0,0'; @ViewChild('mapSvg') mapSvg!: ElementRef<SVGSVGElement>; @ViewChild('mapGroup') mapGroup!: MapContainer; @ContentChildren(IxtLayerComponent) layers!: QueryList<IxtLayerComponent>; private projection!: GeoProjection; private pathGenerator!: GeoPath; private selectedElement: SVGPathElement | null = null; private mapSubscriptions = new Subscription(); private projectionReady = new BehaviorSubject<boolean>(false); projectionReady$ = this.projectionReady.asObservable(); constructor( private cdr: ChangeDetectorRef, private mapService: MapService ) {} private getDimensions(): MapDimensions { return { width: this.mapService.getBaseDimension(this.width), height: this.mapService.getBaseDimension(this.height), scale: Number(this.scale), translate: this.translate }; } getViewBox(): string { const { width, height } = this.getDimensions(); return `0 0 ${width} ${height}`; } private initializeMap(): void { const dimensions = this.getDimensions(); const { projection, pathGenerator } = this.mapService.initializeProjection( dimensions.width, dimensions.height ); this.projection = projection; this.pathGenerator = pathGenerator; this.projectionReady.next(true); if (this.mapGroup) { const mapSelection = d3.select<SVGGElement, unknown>(this.mapGroup.nativeElement); mapSelection.on('click', () => this.clearSelection()); } setTimeout(() => { this.layers.forEach(layer => { layer.setProjection(this.pathGenerator); }); }); } getContainer(): MapContainer { return this.mapGroup; } getPathGenerator(): GeoPath { return this.pathGenerator; } clearSelection(): void { if (this.selectedElement) { d3.select<SVGPathElement, unknown>(this.selectedElement) .attr('stroke', function(this: SVGPathElement) { return this.getAttribute('data-original-stroke') || ''; }) .attr('stroke-width', '1'); this.selectedElement = null; this.cdr.markForCheck(); } } setSelection(element: SVGPathElement | null): void { this.clearSelection(); if (element) { this.selectedElement = element; this.cdr.markForCheck(); } } ngAfterContentInit(): void { this.initializeMap(); this.mapSubscriptions.add( this.layers.changes.subscribe(() => { this.initializeMap(); this.cdr.markForCheck(); }) ); } ngOnDestroy(): void { this.mapSubscriptions.unsubscribe(); this.selectedElement = null; this.projection = null as any; this.pathGenerator = null as any; } }
    |   |   --- ixt-map.index.ts: // Export all public components from the ixt-map module export * from './ixt-map.component'; export * from './ixt-layer.component'; // Include any additional exports, such as services or interfaces, if they are part of the module
    |   |   --- ixt-map.module.ts: // src/components/ixt-map/ixt-map.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtMapComponent } from './ixt-map.component'; import { IxtLayerModule } from './ixt-layer.module'; @NgModule({ declarations: [ IxtMapComponent ], imports: [ CommonModule, IxtLayerModule ], exports: [ IxtMapComponent, IxtLayerModule ] }) export class IxtMapModule { }
    |   |   --- layer-event.service.ts: // layer-event.service.ts import { Injectable } from '@angular/core'; import { MapService } from './map.service'; import * as d3 from 'd3'; export interface LayerEventHandlers { onClick: (event: MouseEvent, datum: any) => void; onMouseOver: (event: MouseEvent) => void; onMouseOut: () => void; onMouseMove: (event: MouseEvent) => void; } @Injectable({ providedIn: 'root' }) export class LayerEventService { private hoveredElement: SVGPathElement | null = null; constructor(private mapService: MapService) {} handleClick(event: MouseEvent, mapRef: any): void { event.stopPropagation(); const clickedPath = event.currentTarget as SVGPathElement; if (clickedPath === mapRef['selectedElement']) { mapRef.setSelection(null); this.applyHoverEffect(clickedPath, false); } else { if (mapRef['selectedElement']) { this.applyHoverEffect(mapRef['selectedElement'], false); } mapRef.setSelection(clickedPath); this.applyHoverEffect(clickedPath, true); } } handleMouseOver(event: MouseEvent, mapRef: any): void { event.stopPropagation(); const currentPath = event.currentTarget as SVGPathElement; if (currentPath !== mapRef['selectedElement']) { this.applyHoverEffect(currentPath, true); this.hoveredElement = currentPath; } } handleMouseOut(): void { if (this.hoveredElement) { this.clearHoverState(this.hoveredElement); this.hoveredElement = null; } } private applyHoverEffect(element: SVGPathElement, isHover: boolean): void { const d3Element = d3.select(element); const currentFill = element.getAttribute('data-original-fill'); if (currentFill && currentFill !== 'none') { d3Element .attr('fill', currentFill) .attr('stroke-width', isHover ? '2' : '1'); } else { d3Element.attr('stroke-width', isHover ? '2' : '1'); } } private clearHoverState(element: SVGPathElement): void { const d3Element = d3.select(element); const originalFill = element.getAttribute('data-original-fill'); d3Element .attr('fill', originalFill) .attr('stroke-width', '1'); } }
    |   |   --- layer-render.service.ts: // layer-render.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { Feature, GeoJsonProperties, Geometry } from 'geojson'; import { MapService } from './map.service'; export interface LayerRenderOptions { stroke: string; fill: string; } @Injectable({ providedIn: 'root' }) export class LayerRenderService { constructor(private mapService: MapService) {} createLayer( container: d3.Selection<any, any, any, any>, features: Feature[], options: LayerRenderOptions, eventHandlers: { onClick: (event: MouseEvent, datum: any) => void; onMouseOver: (event: MouseEvent) => void; onMouseOut: (event: MouseEvent) => void; onMouseMove: (event: MouseEvent) => void; } ): d3.Selection<any, any, any, any> { const layerGroup = container .append('g') .attr('class', 'map-layer'); return layerGroup .selectAll('path') .data(features) .enter() .append('path') .attr('d', (datum) => this.mapService.getPathGenerator()(datum) || '') .attr('stroke', options.stroke) .attr('fill', options.fill) .attr('stroke-width', '1') .attr('data-original-fill', options.fill) .attr('data-original-stroke', options.stroke) .attr('vector-effect', 'non-scaling-stroke') .style('cursor', 'pointer') .on('click', eventHandlers.onClick) .on('mouseover', eventHandlers.onMouseOver) .on('mouseout', eventHandlers.onMouseOut) .on('mousemove', eventHandlers.onMouseMove); } }
    |   |   --- layer-state.service.ts: // layer-state.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; export interface LayerState { hoveredElement: SVGPathElement | null; selections: d3.Selection<any, any, any, any>[]; } @Injectable({ providedIn: 'root' }) export class LayerStateService { private state = new BehaviorSubject<LayerState>({ hoveredElement: null, selections: [] }); state$ = this.state.asObservable(); setHoveredElement(element: SVGPathElement | null): void { this.updateState({ hoveredElement: element }); } addSelection(selection: d3.Selection<any, any, any, any>): void { const currentState = this.state.value; this.updateState({ selections: [...currentState.selections, selection] }); } clearSelections(): void { const currentState = this.state.value; currentState.selections.forEach(selection => { if (selection && !selection.empty()) { selection.remove(); } }); this.updateState({ selections: [] }); } private updateState(partialState: Partial<LayerState>): void { this.state.next({ ...this.state.value, ...partialState }); } ngOnDestroy(): void { this.clearSelections(); this.state.complete(); } }
    |   |   --- map-error.service.ts: // map-error.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; export interface MapError { code: MapErrorCode; message: string; timestamp: Date; context?: any; } export enum MapErrorCode { INITIALIZATION_FAILED = 'INIT_FAILED', PROJECTION_FAILED = 'PROJ_FAILED', DATA_LOAD_FAILED = 'DATA_LOAD_FAILED', SELECTION_FAILED = 'SELECT_FAILED', INVALID_DIMENSIONS = 'INVALID_DIMS' } @Injectable({ providedIn: 'root' }) export class MapErrorService { private errorSubject = new BehaviorSubject<MapError | null>(null); private retryAttemptsMap = new Map<string, number>(); readonly maxRetryAttempts = 3; readonly errors$ = this.errorSubject.asObservable(); reportError(code: MapErrorCode, message: string, context?: any): void { const error: MapError = { code, message, timestamp: new Date(), context }; this.errorSubject.next(error); console.error(`Map Error [${code}]:`, message, context); } clearError(): void { this.errorSubject.next(null); } shouldRetry(operationKey: string): boolean { const attempts = this.retryAttemptsMap.get(operationKey) || 0; if (attempts < this.maxRetryAttempts) { this.retryAttemptsMap.set(operationKey, attempts + 1); return true; } return false; } resetRetryCount(operationKey: string): void { this.retryAttemptsMap.delete(operationKey); } }
    |   |   --- map.service.ts: // map.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { GeoProjection, GeoPath } from 'd3'; import { BehaviorSubject, Observable } from 'rxjs'; import { MapError, MapErrorCode, MapErrorService } from './map-error.service'; export interface MapDimensions { width: number; height: number; } export interface MapState { projection: GeoProjection; pathGenerator: GeoPath; dimensions: MapDimensions; } @Injectable({ providedIn: 'root' }) export class MapService { private projection!: GeoProjection; private pathGenerator!: GeoPath; private selectedElementSource = new BehaviorSubject<SVGPathElement | null>(null); private dimensions = new BehaviorSubject<MapDimensions>({ width: 800, height: 600 }); readonly selectedElement$ = this.selectedElementSource.asObservable(); readonly dimensions$ = this.dimensions.asObservable(); private errorSubject = new BehaviorSubject<MapError | null>(null); private retryAttemptsMap = new Map<string, number>(); readonly maxRetryAttempts = 3; readonly errors$ = this.errorSubject.asObservable(); constructor(private errorService: MapErrorService) {} initializeProjection(width: number, height: number): { projection: GeoProjection; pathGenerator: d3.GeoPath } { try { if (width <= 0 || height <= 0) { throw new Error('Invalid dimensions'); } this.projection = d3.geoMercator() .fitSize([width, height], { type: 'Sphere' }); this.pathGenerator = d3.geoPath().projection(this.projection); return { projection: this.projection, pathGenerator: this.pathGenerator }; } catch (error) { this.errorService.reportError( MapErrorCode.INITIALIZATION_FAILED, 'Failed to initialize map projection', { width, height, error } ); throw error; } } getProjection(): GeoProjection { return this.projection; } getPathGenerator(): GeoPath { return this.pathGenerator; } getDimensions(): MapDimensions { return this.dimensions.value; } setSelection(element: SVGPathElement | null): void { const previousElement = this.selectedElementSource.value; if (previousElement) { d3.select(previousElement) .attr('stroke', d3.select(previousElement).attr('data-original-stroke')) .attr('stroke-width', '1'); } this.selectedElementSource.next(element); } clearSelection(): void { this.setSelection(null); } getBaseDimension(value: string | number): number { if (typeof value === 'number') return value; const num = parseFloat(value); return isNaN(num) ? 800 : num; } reportError(code: MapErrorCode, message: string, context?: any): void { const error: MapError = { code, message, timestamp: new Date(), context }; this.errorSubject.next(error); console.error(`Map Error [${code}]:`, message, context); } clearError(): void { this.errorSubject.next(null); } shouldRetry(operationKey: string): boolean { const attempts = this.retryAttemptsMap.get(operationKey) || 0; if (attempts < this.maxRetryAttempts) { this.retryAttemptsMap.set(operationKey, attempts + 1); return true; } return false; } resetRetryCount(operationKey: string): void { this.retryAttemptsMap.delete(operationKey); } }
    |   |   --- map.types.ts: // map.types.ts import { GeoProjection, GeoPath } from 'd3'; import { ElementRef } from '@angular/core'; export interface MapDimensions { width: number; height: number; scale: number; translate: string; } export interface MapState { projection: GeoProjection; pathGenerator: GeoPath; dimensions: MapDimensions; } export interface MapSelection extends d3.Selection<SVGGElement, unknown, null, undefined> {} export interface PathSelection extends d3.Selection<SVGPathElement, unknown, null, undefined> {} export interface MapContainer extends ElementRef<SVGGElement> {}
    |   |   --- route-processor.service.ts: // route-processor.service.ts import { Injectable } from '@angular/core'; import * as d3 from 'd3'; import { Feature, LineString, GeoJsonProperties } from 'geojson'; export interface RouteProcessingConfig { pointsPerMile?: number; minPoints?: number; earthRadiusMiles?: number; } const DEFAULT_CONFIG: RouteProcessingConfig = { pointsPerMile: 0.2, // 1 point every 5 miles minPoints: 5, earthRadiusMiles: 3959 }; @Injectable({ providedIn: 'root' }) export class RouteProcessorService { private config: RouteProcessingConfig; constructor() { this.config = DEFAULT_CONFIG; } setConfig(config: Partial<RouteProcessingConfig>): void { this.config = { ...DEFAULT_CONFIG, ...config }; } interpolateRoute(feature: Feature<LineString, GeoJsonProperties>): Feature<LineString, GeoJsonProperties> { const line = feature.geometry; const coordinates = line.coordinates; if (coordinates.length !== 2) { return feature; } const start = coordinates[0] as [number, number]; const end = coordinates[1] as [number, number]; const route = d3.geoInterpolate(start, end); const distance = d3.geoDistance(start, end) * this.config.earthRadiusMiles!; const numPoints = Math.max( this.config.minPoints!, Math.ceil(distance * this.config.pointsPerMile!) ); const newCoordinates = Array.from({ length: numPoints }, (_, i) => { const t = i / (numPoints - 1); return route(t); }); return { ...feature, geometry: { ...line, coordinates: newCoordinates } }; } calculateRouteDistance(coordinates: [number, number][]): number { if (coordinates.length < 2) return 0; return coordinates.reduce((total, coord, i) => { if (i === 0) return 0; const distance = d3.geoDistance(coordinates[i - 1], coord) * this.config.earthRadiusMiles!; return total + distance; }, 0); } }
    |   +-- ixt-splitpane
    |   |   --- index.ts: // public-api.ts (or index.ts) export * from './ixt-split-pane.component'; export * from './ixt-split-pane.module';
    |   |   --- ixt-split-pane.component.ts: import { Component, ElementRef, HostListener, Input, ViewChild } from '@angular/core'; @Component({ selector: 'ixt-split-pane', template: ` <div class="split-container"> <div class="first-panel" [style.flexBasis.%]="firstPanelSize"> <ng-content select=".left-pane"></ng-content> </div> <div #divider class="divider" (mousedown)="startResize($event)"> </div> <div class="second-panel" [style.flexBasis.%]="100 - firstPanelSize"> <ng-content select=".right-pane"></ng-content> </div> </div> `, styles: [` :host { display: flex; flex: 1; min-height: 0; min-width: 0; font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', Arial, sans-serif; font-size: 14px; color: #2c3e50; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } .split-container { display: flex; flex: 1; min-height: 0; min-width: 0; background: #ffffff; border: 1px solid #e0e4e8; border-radius: 4px; } .first-panel, .second-panel { display: flex; flex: 1; min-height: 0; min-width: 0; overflow: auto; background: white; padding: 16px; /* Table styles for your file list */ ::ng-deep { table { width: 100%; border-collapse: collapse; } th { text-align: left; font-weight: 500; color: #546e7a; padding: 8px 16px; border-bottom: 2px solid #e0e4e8; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px; } td { padding: 12px 16px; border-bottom: 1px solid #f0f2f5; color: #37474f; font-size: 14px; } tr:hover { background-color: #f8fafc; } } /* Scrollbar styling */ &::-webkit-scrollbar { width: 8px; height: 8px; } &::-webkit-scrollbar-track { background: #f5f6f8; border-radius: 4px; } &::-webkit-scrollbar-thumb { background: #dde1e6; border-radius: 4px; &:hover { background: #c7ccd1; } } } .divider { display: flex; justify-content: center; width: 16px; flex-shrink: 0; cursor: col-resize; background: transparent; transition: background-color 0.2s; &:hover { background: #f5f6f8; .divider-line { background: #c7ccd1; } } } .divider { width: 6px; background: #ccc; cursor: col-resize; flex-shrink: 0; border-left: 1px solid #b4b4b4; border-right: 1px solid #b4b4b4; &:hover { background: #999; } } `] }) export class IxtSplitPaneComponent { firstPanelSize = 50; // default size isDragging = false; startPosition = 0; startSize = 0; @ViewChild('divider') divider!: ElementRef; startResize(e: MouseEvent) { this.isDragging = true; this.startPosition = e.pageX; this.startSize = this.firstPanelSize; document.addEventListener('mousemove', this.resize.bind(this)); document.addEventListener('mouseup', this.stopResize.bind(this)); } @HostListener('window:mousemove', ['$event']) resize(e: MouseEvent) { if (!this.isDragging) return; const containerRect = this.divider.nativeElement.parentElement.getBoundingClientRect(); const difference = e.pageX - this.startPosition; let newSize = this.startSize + (difference / containerRect.width * 100); newSize = Math.max(0, Math.min(100, newSize)); this.firstPanelSize = newSize; } stopResize() { this.isDragging = false; document.removeEventListener('mousemove', this.resize.bind(this)); document.removeEventListener('mouseup', this.stopResize.bind(this)); } }
    |   |   --- ixt-split-pane.module.ts: // ixt-split-pane.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtSplitPaneComponent } from './ixt-split-pane.component'; @NgModule({ declarations: [ IxtSplitPaneComponent ], imports: [ CommonModule ], exports: [ IxtSplitPaneComponent ] }) export class IxtSplitPaneModule { }
    |   +-- ixt-table
    |   |   +-- editors
    |   |   |   +-- airport-code
    |   |   |   |   --- airport-code-editor.component.ts: import { Component, Input, forwardRef, OnInit, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { IxtDialogService } from '../../../ixt-dialog/ixt-dialog.service'; import { TableEditor, TableEditorConfig } from '../editor.interface'; @Component({ selector: 'airport-code-editor', template: ` <div class="editor-container"> <input type="text" [formControl]="inputControl" class="w-24 px-2 py-1 border rounded" [class.border-red-500]="hasError" [attr.maxlength]="config?.['maxLength'] || 3" (blur)="onTouched()" /> <div *ngIf="hasError" class="text-red-500 text-sm mt-1"> {{ errorMessage }} </div> </div> `, styles: [` .editor-container { position: relative; } `], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AirportCodeEditorComponent), multi: true } ] }) export class AirportCodeEditorComponent implements ControlValueAccessor, OnInit, TableEditor { @Input() config?: TableEditorConfig; @Input() existingCodes: string[] = []; @Input() field: string = 'code'; inputControl = new FormControl(''); hasError = false; errorMessage = ''; // TableEditor implementation component: Type<any> = AirportCodeEditorComponent; // ControlValueAccessor implementations public onChanged: (value: string) => void = () => {}; public onTouched: () => void = () => {}; constructor(private dialogService: IxtDialogService) {} ngOnInit() { this.setupValueChanges(); } // TableEditor methods getEditConfig(): TableEditorConfig { return { existingValues: this.existingCodes, maxLength: 3, pattern: /^[A-Z]+$/ }; } getDefaultValue(): string { return ''; } validate(value: any): boolean { if (!value) return false; const code = String(value).toUpperCase(); if (code.length !== 3) return false; if (!/^[A-Z]+$/.test(code)) return false; if (this.existingCodes.includes(code)) return false; return true; } format(value: any): string { return value ? String(value).toUpperCase() : ''; } private async setupValueChanges() { this.inputControl.valueChanges.subscribe(async value => { if (value !== null) { const upperValue = value.toUpperCase(); if (upperValue !== value) { this.inputControl.setValue(upperValue, { emitEvent: false }); } if (await this.validateValue(upperValue)) { console.log('Editor emitting code change:', upperValue); this.onChanged(upperValue); } } }); } private async validateValue(value: string): Promise<boolean> { this.hasError = false; this.errorMessage = ''; if (!value) return false; if (value.length !== (this.config?.['maxLength'] || 3)) { this.hasError = true; this.errorMessage = `Code must be exactly ${this.config?.['maxLength'] || 3} characters`; return false; } const pattern = this.config?.['pattern'] || /^[A-Z]+$/; if (!pattern.test(value)) { this.hasError = true; this.errorMessage = 'Only letters are allowed'; return false; } if (this.config?.existingValues?.includes(value)) { this.hasError = true; this.errorMessage = 'This code already exists'; // await this.dialogService.warning( // `The code "${value}" already exists. Please enter a different code.`, // 'Duplicate Code' // ); return false; } return true; } // ControlValueAccessor interface implementation writeValue(value: string): void { console.log('AirportCodeEditor writeValue:', value); this.inputControl.setValue(value, { emitEvent: false }); } registerOnChange(fn: (value: string) => void): void { console.log('AirportCodeEditor registerOnChange'); this.onChanged = fn; } registerOnTouched(fn: () => void): void { this.onTouched = fn; } setDisabledState(isDisabled: boolean): void { if (isDisabled) { this.inputControl.disable(); } else { this.inputControl.enable(); } } }
    |   |   |   +-- binary-editor
    |   |   |   |   --- binary-editor.component.ts: // src/components/ixt-table/table-editors/binary-editor/binary-editor.component.ts import { Component, Input, forwardRef, Output, EventEmitter, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { TableEditor, TableEditorConfig } from '../editor.interface'; interface BinaryConfig extends TableEditorConfig { trueValue?: any; falseValue?: any; trueDisplay?: string; falseDisplay?: string; rowData?: any; rowIndex?: number; } interface SelectionEvent { selected: boolean; rowData?: any; rowIndex?: number; } @Component({ selector: 'binary-editor', template: ` <div class="editor-container"> <input type="checkbox" [formControl]="inputControl" [checked]="isChecked" (change)="onCheckboxChange($event)" class="w-4 h-4 rounded border-gray-300" /> <span *ngIf="showLabel" class="ml-2"> {{ isChecked ? config.trueDisplay : config.falseDisplay }} </span> </div> `, providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => BinaryEditorComponent), multi: true } ] }) export class BinaryEditorComponent implements ControlValueAccessor, TableEditor { @Input() config: BinaryConfig = {}; @Output() selectionChange = new EventEmitter<SelectionEvent>(); inputControl = new FormControl<boolean | null>(false); component: Type<any> = BinaryEditorComponent; showLabel = false; isChecked = false; private onChange: (value: any) => void = () => { }; private onTouch: () => void = () => { }; constructor() { this.setupDefaults(); this.isChecked = false; } ngOnInit() { this.setupDefaults(); this.setupValueChanges(); } private setupDefaults() { this.config = { trueValue: true, falseValue: false, trueDisplay: 'True', falseDisplay: 'False', ...this.config }; } private setupValueChanges(): void { this.inputControl.valueChanges.subscribe((checked: boolean | null) => { if (checked !== null) { const value = checked ? this.config.trueValue : this.config.falseValue; this.isChecked = checked; this.onChange(value); this.selectionChange.emit({ selected: checked, rowData: this.config.rowData, rowIndex: this.config.rowIndex }); } }); } onCheckboxChange(event: Event) { const checkbox = event.target as HTMLInputElement; this.inputControl.setValue(checkbox.checked); this.onTouch(); } getEditConfig(): BinaryConfig { return { trueValue: this.config.trueValue || true, falseValue: this.config.falseValue || false, trueDisplay: this.config.trueDisplay || 'True', falseDisplay: this.config.falseDisplay || 'False' }; } writeValue(value: any): void { const checked = value === this.config.trueValue; this.isChecked = checked; this.inputControl.setValue(checked, { emitEvent: false }); } registerOnChange(fn: any): void { this.onChange = fn; } registerOnTouched(fn: any): void { this.onTouch = fn; } setDisabledState(isDisabled: boolean): void { if (isDisabled) { this.inputControl.disable(); } else { this.inputControl.enable(); } } }
    |   |   |   +-- coordinate
    |   |   |   |   --- coordinate-editor.component.ts: // src/components/ixt-table/table-editors/coordinate/coordinate-editor.component.ts import { Component, Input, forwardRef, OnInit, Type } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms'; import { IxtDialogService } from '../../../ixt-dialog/ixt-dialog.service'; import { TableEditor, TableEditorConfig } from '../editor.interface'; @Component({ selector: 'coordinate-editor', template: ` <div class="editor-container"> <input type="number" step="any" [min]="config?.['type'] === 'lat' ? -90 : -180" [max]="config?.['type'] === 'lat' ? 90 : 180" [formControl]="inputControl" class="w-24 px-2 py-1 border rounded" [class.border-red-500]="hasError" [placeholder]="config?.['type'] === 'lat' ? '(-90 to 90)' : '(-180 to 180)'" (blur)="onBlur()" /> <div *ngIf="hasError" class="text-red-500 text-sm mt-1"> {{ errorMessage }} </div> </div>`, providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => CoordinateEditorComponent), multi: true } ] }) export class CoordinateEditorComponent implements ControlValueAccessor, OnInit, TableEditor { @Input() config?: TableEditorConfig; inputControl = new FormControl(''); hasError = false; errorMessage = ''; // TableEditor implementation component: Type<any> = CoordinateEditorComponent; private onChange: (value: number) => void = () => { }; private onTouch: () => void = () => { }; constructor(private dialogService: IxtDialogService) { } ngOnInit() { this.setupValueChanges(); } getEditConfig(): TableEditorConfig { return { type: this.config?.['type'] || 'lat' }; } validate(value: any): boolean { const num = Number(value); const isLat = this.config?.['type'] === 'lat'; return isLat ? (num >= -90 && num <= 90) : (num >= -180 && num <= 180); } // private setupValueChanges() { // this.inputControl.valueChanges.subscribe(value => { // if (value !== null) { // // Convert string to number for validation // const numValue = Number(value); // if (this.validateValue(numValue)) { // this.onChange(numValue); // } // } // }); // } setupValueChanges() { this.inputControl.valueChanges.subscribe(value => { if (value !== null) { const numValue = Number(value); if (!isNaN(numValue) && this.validateValue(numValue)) { this.onChange(numValue); } else { // Reset to last valid value or empty this.inputControl.setValue('', {emitEvent: false}); } } }); } private validateValue(value: number): boolean { this.hasError = false; this.errorMessage = ''; if (isNaN(value)) { this.hasError = true; this.errorMessage = 'Must be a valid number'; return false; } const isLat = this.config?.['type'] === 'lat'; const min = isLat ? -90 : -180; const max = isLat ? 90 : 180; if (value < min || value > max) { this.hasError = true; this.errorMessage = `Must be between ${min} and ${max}`; return false; } return true; } // ControlValueAccessor methods writeValue(value: number): void { this.inputControl.setValue(value?.toString() || '', { emitEvent: false }); } registerOnChange(fn: any): void { this.onChange = fn; } registerOnTouched(fn: any): void { this.onTouch = fn; } onBlur(): void { this.onTouch(); } }
    |   |   |   --- editor.interface.ts: import { Type } from "@angular/core"; export interface TableEditorConfig { existingValues?: any[]; validators?: any[]; field?: string; [key: string]: any; } export interface TableEditor { component: Type<any>; getEditConfig(): any; validate?(value: any): boolean; format?(value: any): string; getDefaultValue?(): any; }
    |   |   +-- services
    |   |   |   +-- edit
    |   |   |   |   --- edit.model.ts: // src/components/ixt-table/services/edit/edit.model.ts import { FormControl } from '@angular/forms'; export interface RowChanges { [key: string]: any; } export interface EditState { editingRows: Set<number>; newRows: any[]; rowChanges: Map<number, RowChanges>; editControls: Map<string, FormControl>; } export interface EditEvent { rowIndex: number; field: string; value: any; }
    |   |   |   |   --- edit.service.ts: // src/components/ixt-table/services/edit/edit.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { FormControl } from '@angular/forms'; import { ColumnConfig } from '../../ixt-table.interfaces'; import { EditEvent, EditState, RowChanges } from './edit.model'; @Injectable({ providedIn: 'root' }) export class EditService { private readonly initialState: EditState = { editingRows: new Set<number>(), newRows: [], rowChanges: new Map<number, RowChanges>(), editControls: new Map<string, FormControl>() }; private state = new BehaviorSubject<EditState>(this.initialState); public state$ = this.state.asObservable(); private getDefaultValueForType(type: string | any): any { switch (type) { case 'number': return 0; case 'enum': return ''; case 'text': default: return ''; } } public addNewRow(columnConfigs: Record<string, ColumnConfig>): void { const newRow: any = {}; if (columnConfigs) { Object.entries(columnConfigs).forEach(([field, config]) => { newRow[field] = this.getDefaultValueForType(config.type); }); } const currentState = this.state.getValue(); const newRows = [...currentState.newRows]; newRows.unshift(newRow); // Start editing the new row const editingRows = new Set(currentState.editingRows); editingRows.add(-newRows.length); this.state.next({ ...currentState, newRows, editingRows }); } public startEditing(rowIndex: number): void { const currentState = this.state.getValue(); const editingRows = new Set(currentState.editingRows); editingRows.add(rowIndex); this.state.next({ ...currentState, editingRows }); } public cancelEditing(rowIndex: number): void { const currentState = this.state.getValue(); const editingRows = new Set(currentState.editingRows); const rowChanges = new Map(currentState.rowChanges); editingRows.delete(rowIndex); rowChanges.delete(rowIndex); this.state.next({ ...currentState, editingRows, rowChanges }); } public onValueChange(event: EditEvent): void { const { rowIndex, field, value } = event; const currentState = this.state.getValue(); const rowChanges = new Map(currentState.rowChanges); let changes = rowChanges.get(rowIndex) || {}; changes = { ...changes, [field]: value }; rowChanges.set(rowIndex, changes); this.state.next({ ...currentState, rowChanges }); } public getEditControl(rowIndex: number, field: string): FormControl { const key = `${rowIndex}-${field}`; const currentState = this.state.getValue(); let control = currentState.editControls.get(key); if (!control) { control = new FormControl(''); const editControls = new Map(currentState.editControls); editControls.set(key, control); this.state.next({ ...currentState, editControls }); } return control; } public saveChanges(data: any[]): any[] { const currentState = this.state.getValue(); const updatedData = [...data]; // Apply changes to existing rows currentState.rowChanges.forEach((changes, rowIndex) => { if (rowIndex >= 0) { updatedData[rowIndex] = { ...updatedData[rowIndex], ...changes }; } }); // Add new rows if (currentState.newRows.length) { // Apply any changes to new rows const processedNewRows = currentState.newRows.map((row, index) => { const changes = currentState.rowChanges.get(-index - 1); return changes ? { ...row, ...changes } : row; }); updatedData.unshift(...processedNewRows); } // Reset state this.state.next(this.initialState); return updatedData; } public isNewRow(index: number): boolean { return index < this.state.getValue().newRows.length; } public isEditing(rowIndex: number): boolean { return this.state.getValue().editingRows.has(rowIndex); } public hasChanges(): boolean { const currentState = this.state.getValue(); return currentState.rowChanges.size > 0 || currentState.newRows.length > 0; } public getNewRows(): any[] { return this.state.getValue().newRows; } public getRowChanges(rowIndex: number): RowChanges | undefined { return this.state.getValue().rowChanges.get(rowIndex); } public getRowIndex(displayIndex: number): number { return displayIndex - this.state.getValue().newRows.length; } public clearEditing(): void { this.state.next(this.initialState); } }
    |   |   |   +-- filter
    |   |   |   |   --- filter.model.ts: // 3. filter.model.ts import { FormControl } from '@angular/forms'; export type FilterOperator = 'equals' | 'startsWith' | 'contains' | 'between' | '>' | '<' | '>=' | '<=' | '!='; export interface FilterState { field: string; operator: FilterOperator; value: any; secondaryValue?: any; } export interface FilterControls { value: FormControl; operator?: FormControl<string>; }
    |   |   |   |   --- filter.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; import { FormControl } from '@angular/forms'; import { FilterState, FilterOperator, FilterControls } from './filter.model'; import { ColumnConfig } from '../../ixt-table.interfaces'; @Injectable({ providedIn: 'root' }) export class FilterService { private activeFilters = new Map<string, FilterState>(); private filterControls = new Map<string, FilterControls>(); private activeFilterColumn?: string; private showFilters = false; private filtersChanged = new BehaviorSubject<Map<string, FilterState>>(new Map()); public filtersChanged$ = this.filtersChanged.asObservable(); public initializeFilter(field: string, config: ColumnConfig): void { const controls: FilterControls = { value: new FormControl('') }; if (config.type === 'number') { // Fix: Explicitly type the FormControl controls.operator = new FormControl<string>('=', { nonNullable: true }); } this.filterControls.set(field, controls); } public getFilterControl(field: string): FormControl | undefined { return this.filterControls.get(field)?.value; } public getOperatorControl(field: string): FormControl<string> | undefined { return this.filterControls.get(field)?.operator; } public onFilterChange(field: string, value: any, config?: ColumnConfig): void { if (value || value === 0) { const defaultOperator: FilterOperator = config?.type === 'number' ? 'equals' : 'contains'; const operator = this.getOperatorControl(field)?.value || defaultOperator; this.activeFilters.set(field, { field, operator: operator as FilterOperator, value: config?.type === 'number' ? Number(value) : value }); } else { this.activeFilters.delete(field); } this.filtersChanged.next(this.activeFilters); } public onOperatorChange(field: string): void { const currentValue = this.getFilterControl(field)?.value; if (currentValue || currentValue === 0) { this.onFilterChange(field, currentValue); } } public clearAllFilters(): void { this.activeFilters.clear(); this.filterControls.forEach(controls => { controls.value.reset(); controls.operator?.reset('='); }); this.filtersChanged.next(this.activeFilters); } public toggleFilters(column: string): void { if (this.activeFilterColumn === column) { this.activeFilterColumn = undefined; this.showFilters = false; } else { this.activeFilterColumn = column; this.showFilters = true; } } public matchesFilter(item: any, filter: FilterState): boolean { if (item === undefined || item === null) return false; // Handle numeric comparisons if (typeof item === 'number' || !isNaN(Number(item))) { const numValue = Number(item); const numFilterValue = Number(filter.value); return this.handleNumericComparison(numValue, numFilterValue, filter.operator); } // String handling const itemValue = String(item).toLowerCase(); const filterValue = String(filter.value).toLowerCase(); switch (filter.operator) { case 'startsWith': return itemValue.startsWith(filterValue); case 'equals': return itemValue === filterValue; case '!=': return itemValue !== filterValue; default: return itemValue.includes(filterValue); } } private handleNumericComparison(numValue: number, numFilterValue: number, operator: FilterOperator): boolean { switch (operator) { case '>': return numValue > numFilterValue; case '<': return numValue < numFilterValue; case '>=': return numValue >= numFilterValue; case '<=': return numValue <= numFilterValue; case '!=': return numValue !== numFilterValue; case 'equals': return numValue === numFilterValue; default: return false; } } public get isShowingFilters(): boolean { return this.showFilters; } public get activeColumn(): string | undefined { return this.activeFilterColumn; } public getActiveFilters(): Map<string, FilterState> { return this.activeFilters; } public hasActiveFilters(): boolean { return this.activeFilters.size > 0; } }
    |   |   |   +-- selection
    |   |   |   |   --- selection.model.ts: // src/components/ixt-table/services/selection/selection.model.ts export interface SelectionState { selectedRows: Set<number>; allSelected: boolean; }
    |   |   |   |   --- selection.service.ts: // src/components/ixt-table/services/selection/selection.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { SelectionState } from './selection.model'; @Injectable({ providedIn: 'root' }) export class SelectionService { private state = new BehaviorSubject<SelectionState>({ selectedRows: new Set<number>(), allSelected: false }); public state$ = this.state.asObservable(); public selectRow(index: number, selected: boolean = true): void { const currentState = this.state.getValue(); const newSelectedRows = new Set(currentState.selectedRows); if (selected) { newSelectedRows.add(index); } else { newSelectedRows.delete(index); } this.state.next({ selectedRows: newSelectedRows, allSelected: currentState.allSelected }); } public toggleAllRows(selected: boolean, totalRows: number): void { const newSelectedRows = new Set<number>(); if (selected) { // Add all row indices for (let i = 0; i < totalRows; i++) { newSelectedRows.add(i); } } this.state.next({ selectedRows: newSelectedRows, allSelected: selected }); } public clearSelection(): void { this.state.next({ selectedRows: new Set<number>(), allSelected: false }); } public getSelectedRows(): Set<number> { return this.state.getValue().selectedRows; } public isSelected(index: number): boolean { return this.state.getValue().selectedRows.has(index); } public isAllSelected(): boolean { return this.state.getValue().allSelected; } public getSelectedCount(): number { return this.state.getValue().selectedRows.size; } public setSelectedRows(indices: number[]): void { const newSelectedRows = new Set(indices); this.state.next({ selectedRows: newSelectedRows, allSelected: false // Reset all selected state when manually setting rows }); } public isPartiallySelected(totalRows: number): boolean { const selectedCount = this.getSelectedCount(); return selectedCount > 0 && selectedCount < totalRows; } }
    |   |   |   +-- sort
    |   |   |   |   --- sort.model.ts: // src/components/ixt-table/services/sort/sort.model.ts export type SortDirection = 'asc' | 'desc' | null; export interface SortState { column: string | null; direction: SortDirection; }
    |   |   |   |   --- sort.service.ts: // src/components/ixt-table/services/sort/sort.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject } from 'rxjs'; import { SortState, SortDirection } from './sort.model'; @Injectable({ providedIn: 'root' }) export class SortService { private readonly initialState: SortState = { column: null, direction: null }; private state = new BehaviorSubject<SortState>(this.initialState); public state$ = this.state.asObservable(); public toggleSort(column: string): void { const currentState = this.state.getValue(); let newDirection: SortDirection = null; if (currentState.column === column) { // Cycle through: null -> asc -> desc -> null if (currentState.direction === null) { newDirection = 'asc'; } else if (currentState.direction === 'asc') { newDirection = 'desc'; } else { newDirection = null; } } else { // New column, start with ascending newDirection = 'asc'; } this.state.next({ column: newDirection ? column : null, direction: newDirection }); } public getSortIcon(column: string): string { const { column: sortColumn, direction } = this.state.getValue(); if (sortColumn !== column) { return 'unfold_more'; } return direction === 'asc' ? 'arrow_upward' : 'arrow_downward'; } public sortData<T>(data: T[]): T[] { const { column, direction } = this.state.getValue(); if (!column || !direction) { return data; } return [...data].sort((a, b) => { const aVal = a[column as keyof T]; const bVal = b[column as keyof T]; if (aVal == null) return 1; if (bVal == null) return -1; let comparison: number; if (typeof aVal === 'string') { comparison = String(aVal).toLowerCase().localeCompare(String(bVal).toLowerCase()); } else { comparison = aVal < bVal ? -1 : (aVal > bVal ? 1 : 0); } return direction === 'asc' ? comparison : -comparison; }); } public clearSort(): void { this.state.next(this.initialState); } public getCurrentSort(): SortState { return this.state.getValue(); } public isColumnSorted(column: string): boolean { return this.state.getValue().column === column; } public getSortDirection(column: string): SortDirection { const { column: sortColumn, direction } = this.state.getValue(); return sortColumn === column ? direction : null; } }
    |   |   |   --- pagination.model.ts: // src/components/ixt-table/services/pagination/pagination.model.ts export interface PaginationState { currentPage: number; pageSize: number | 'all'; totalItems: number; } export interface PageSize { value: number | 'all'; label: string; }
    |   |   |   --- pagination.service.ts: // src/components/ixt-table/services/pagination/pagination.service.ts import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs'; import { PageSize, PaginationState } from './pagination.model'; @Injectable({ providedIn: 'root' }) export class PaginationService { private readonly DEFAULT_PAGE_SIZES: PageSize[] = [ { value: 10, label: '10' }, { value: 100, label: '100' }, { value: 'all', label: 'All' } ]; private readonly MINIMUM_ROWS_FOR_PAGINATION = 50; private state = new BehaviorSubject<PaginationState>({ currentPage: 1, pageSize: 10, totalItems: 0 }); public state$ = this.state.asObservable(); public initialize(totalItems: number): void { this.updateState({ currentPage: 1, pageSize: 10, totalItems }); } public shouldShowPagination(): boolean { return this.state.getValue().totalItems > this.MINIMUM_ROWS_FOR_PAGINATION; } public getCurrentPage(): number { return this.state.getValue().currentPage; } public getPageSize(): number | 'all' { return this.state.getValue().pageSize; } public getPageSizes(): PageSize[] { return this.DEFAULT_PAGE_SIZES; } public getTotalPages(): number { const { totalItems, pageSize } = this.state.getValue(); if (pageSize === 'all' || totalItems <= this.MINIMUM_ROWS_FOR_PAGINATION) { return 1; } return Math.ceil(totalItems / +pageSize); } public getVisiblePages(): number[] { const totalPages = this.getTotalPages(); const currentPage = this.getCurrentPage(); if (totalPages <= 1) return []; const pages: number[] = [1]; const WINDOW_SIZE = 4; let start = Math.max(2, currentPage - WINDOW_SIZE); let end = Math.min(totalPages - 1, currentPage + WINDOW_SIZE); if (start > 2) { pages.push(-1); } for (let i = start; i <= end; i++) { pages.push(i); } if (end < totalPages - 1) { pages.push(-1); } if (totalPages > 1) { pages.push(totalPages); } return pages; } public onPageChange(page: number): void { const totalPages = this.getTotalPages(); if (page >= 1 && page <= totalPages) { this.updateState({ ...this.state.getValue(), currentPage: page }); } } public onPageSizeChange(newSize: number | 'all'): void { this.updateState({ ...this.state.getValue(), pageSize: newSize, currentPage: 1 }); } public getPaginatedData<T>(data: T[]): T[] { const { pageSize, currentPage } = this.state.getValue(); if (pageSize === 'all' || data.length <= this.MINIMUM_ROWS_FOR_PAGINATION) { return data; } const start = (currentPage - 1) * (+pageSize); const end = start + (+pageSize); return data.slice(start, end); } private updateState(newState: Partial<PaginationState>): void { this.state.next({ ...this.state.getValue(), ...newState }); } }
    |   |   --- ixt-table.component.ts: import { ChangeDetectorRef, Component, Input, OnInit, TemplateRef, ViewChild, Type } from '@angular/core'; import { FormControl } from '@angular/forms'; import { ColumnConfig, TableNode} from './ixt-table.interfaces'; import { debounceTime, distinctUntilChanged } from 'rxjs/operators'; import { IxtDialogService } from '../ixt-dialog/ixt-dialog.index'; import { PaginationService } from './services/pagination.service'; import { FilterService } from './services/filter/filter.service'; import { SortService } from './services/sort/sort.service'; import { SelectionService } from './services/selection/selection.service'; import { EditService } from './services/edit/edit.service'; import { TableEditor } from './editors/editor.interface'; import { AirportCodeEditorComponent, CoordinateEditorComponent, PageSize } from './ixt-table.index'; @Component({ selector: 'ixt-table', templateUrl: './ixt-table.component.html', styleUrls: ['./ixt-table.component.scss'] }) export class IxtTableComponent implements OnInit { @Input() data: TableNode[] = []; @Input() columnConfigs?: Record<string, ColumnConfig>; @ViewChild('noData') noDataTemplate!: TemplateRef<any>; @ViewChild('customEditorTpl') customEditorTpl!: TemplateRef<any>; columns: string[] = []; pageSizeControl = new FormControl<number | 'all'>(10); readonly AirportCodeEditorComponent = AirportCodeEditorComponent; readonly CoordinateEditorComponent = CoordinateEditorComponent; constructor( private dialogService: IxtDialogService, private changeDetectorRef: ChangeDetectorRef, private paginationService: PaginationService, private filterService: FilterService, private sortService: SortService, private selectionService: SelectionService, private editService: EditService ) { } ngOnInit() { this.columns = this.getColumns(this.data); // Initialize pagination this.paginationService.initialize(this.data.length); // Initialize filters if (this.columnConfigs) { Object.entries(this.columnConfigs).forEach(([field, config]) => { this.filterService.initializeFilter(field, config); // Get the control from service and subscribe to changes const control = this.filterService.getFilterControl(field); if (control) { control.valueChanges.pipe( debounceTime(config.debounceTime || 300), distinctUntilChanged() ).subscribe(value => { this.filterService.onFilterChange(field, value, config); }); } }); } // Subscribe to filter changes this.filterService.filtersChanged$.subscribe(() => { this.changeDetectorRef.markForCheck(); }); // Subscribe to pagination changes this.paginationService.state$.subscribe(() => { this.changeDetectorRef.markForCheck(); }); // Subscribe to page size changes this.pageSizeControl.valueChanges.subscribe(value => { if (value) { this.paginationService.onPageSizeChange(value); } }); } // edit logic start addNewRow(): void { this.editService.addNewRow(this.columnConfigs || {}); } cancelEditing(rowIndex: number): void { this.editService.cancelEditing(rowIndex); } getEditorComponent(type: any): TableEditor | null { console.log('getEditorComponent called with:', { type, isCoordinate: type === CoordinateEditorComponent, isAirport: type === AirportCodeEditorComponent }); if (type === AirportCodeEditorComponent) { return new AirportCodeEditorComponent(this.dialogService); } if (type === CoordinateEditorComponent) { return new CoordinateEditorComponent(this.dialogService); } return null; } getEditorType(type: any): string { console.log('getEditorType called with:', { type, isString: typeof type === 'string', isCoordinate: type === CoordinateEditorComponent, isAirport: type === AirportCodeEditorComponent }); if (typeof type === 'string') { return type; } if (type === AirportCodeEditorComponent || type === CoordinateEditorComponent) { console.log('Returning custom for editor type'); return 'custom'; } console.log('Falling back to text type'); return 'text'; } getEditControl(rowIndex: number, field: string): FormControl { return this.editService.getEditControl(rowIndex, field); } getRowIndex(displayIndex: number): number { return this.editService.getRowIndex(displayIndex); } get hasChanges(): boolean { return this.editService.hasChanges(); } isEditing(index: number): boolean { return this.editService.isEditing(index); } isNewRow(displayIndex: number): boolean { return this.editService.isNewRow(displayIndex); } get newRowsLength(): number { return this.editService.getNewRows().length; } onValueChange(rowIndex: number, field: string, value: any): void { this.editService.onValueChange({ rowIndex, field, value }); } saveChanges(): void { this.data = this.editService.saveChanges(this.data); this.changeDetectorRef.markForCheck(); } startEditing(rowIndex: number): void { this.editService.startEditing(rowIndex); } // edit logic end // filter logic start get activeFilterColumn(): string | undefined { return this.filterService.activeColumn; } getFilterControl(col: string): FormControl<any> { return this.filterService.getFilterControl(col)!; } getOperatorControl(col: string): FormControl<string> { return this.filterService.getOperatorControl(col)!; } onOperatorChange(field: string): void { this.filterService.onOperatorChange(field); } get showFilters(): boolean { return this.filterService.isShowingFilters; } toggleFilters(col: string): void { this.filterService.toggleFilters(col); } // filter logic end // pagination logic start get currentPage(): number { return this.paginationService.getCurrentPage(); } onPageChange(page: number): void { this.paginationService.onPageChange(page); } onPageSizeChange(size: number | 'all'): void { this.paginationService.onPageSizeChange(size); } get paginatedData(): TableNode[] { // Start with combined data let allData = [...this.editService.getNewRows(), ...this.data]; // Apply filters if (this.filterService.hasActiveFilters()) { const activeFilters = this.filterService.getActiveFilters(); const filteredExisting = this.data.filter(item => Array.from(activeFilters.values()).every(filter => this.filterService.matchesFilter(item[filter.field], filter) ) ); allData = [...this.editService.getNewRows(), ...filteredExisting]; } // Apply sorting allData = this.sortService.sortData(allData); // Apply pagination return this.paginationService.getPaginatedData(allData); } get pageSizes(): PageSize[] { return this.paginationService.getPageSizes(); } get showPagination(): boolean { return this.paginationService.shouldShowPagination(); } get totalPages(): number { return this.paginationService.getTotalPages(); } get visiblePages(): number[] { return this.paginationService.getVisiblePages(); } // pagination logic end // selection logic start get allSelected(): boolean { return this.selectionService.isAllSelected(); } set allSelected(value: boolean) { this.selectionService.toggleAllRows(value, this.data.length); } getSelectedRows(): TableNode[] { return Array.from(this.selectionService.getSelectedRows()) .map(index => this.data[index]) .filter(row => row !== undefined); } get hasSelectedRows(): boolean { return this.selectionService.getSelectedCount() > 0; } isRowSelected(index: number): boolean { return this.selectionService.isSelected(index); } selectRow(index: number, selected = true): void { this.selectionService.selectRow(index, selected); } setSelectedRows(indices: number[]): void { this.selectionService.setSelectedRows(indices); } toggleAllRows(selected: boolean): void { this.selectionService.toggleAllRows(selected, this.data.length); } // selection logic end // sort logic start getSortIcon(column: string): string { return this.sortService.getSortIcon(column); } toggleSort(column: string): void { this.sortService.toggleSort(column); } // sort logic end // i/o logic start formatCoordinate(value: number): string { return value.toFixed(1); } getCodes(data: TableNode[]): string[] { if (!data) return []; return data.map(row => row['code']?.toString() || ''); } // i/o logic end // config logic start getColumns(data: TableNode[]): string[] { if (!data?.length) return []; const firstRow = data[0]; return Object.keys(firstRow); } get hasData(): boolean { return !!this.data?.length; } // config logic end }
    |   |   --- ixt-table.index.ts: // ixt-table.index.ts // Core export * from './ixt-table.component'; export * from './ixt-table.interfaces'; export * from './ixt-table.module'; export * from './ixt-table.type'; // Editors export * from './editors/editor.interface'; export * from './editors/airport-code/airport-code-editor.component'; export * from './editors/binary-editor/binary-editor.component'; export * from './editors/coordinate/coordinate-editor.component'; // Services and Models export * from './services/edit/edit.model'; export * from './services/edit/edit.service'; export * from './services/filter/filter.model'; export * from './services/filter/filter.service'; export * from './services/sort/sort.model'; export * from './services/sort/sort.service'; export * from './services/selection/selection.model'; export * from './services/selection/selection.service'; export * from './services/pagination.model'; export * from './services/pagination.service';
    |   |   --- ixt-table.interfaces.ts: // 1. ixt-table.interfaces.ts - Keep only core table interfaces import { Type } from "@angular/core"; import { TableEditor } from "./editors/editor.interface"; import { FilterOperator } from "./services/filter/filter.model"; export interface ColumnConfig { type: 'text' | 'number' | 'enum' | Type<TableEditor> | TableEditor; field: string; label?: string; operator?: FilterOperator; enumValues?: { value: any, label: string }[]; placeholder?: string; debounceTime?: number; editable?: boolean; config?: any; } export type ColumnConfigs = Record<string, ColumnConfig>; export interface TableNode { code?: string; [key: string]: any; }
    |   |   --- ixt-table.module.ts: import { NgModule } from '@angular/core'; import { CommonModule, DatePipe } from '@angular/common'; import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { MatIconModule } from '@angular/material/icon'; import { MatAutocompleteModule } from '@angular/material/autocomplete'; // Components import { IxtTableComponent } from './ixt-table.component'; import { AirportCodeEditorComponent } from './editors/airport-code/airport-code-editor.component'; import { CoordinateEditorComponent } from './editors/coordinate/coordinate-editor.component'; import { BinaryEditorComponent } from './editors/binary-editor/binary-editor.component'; // Services import { EditService } from './services/edit/edit.service'; import { FilterService } from './services/filter/filter.service'; import { SortService } from './services/sort/sort.service'; import { SelectionService } from './services/selection/selection.service'; import { PaginationService } from './services/pagination.service'; import { TableDataService } from './ixt-table.service'; const COMPONENTS = [ IxtTableComponent, AirportCodeEditorComponent, CoordinateEditorComponent, BinaryEditorComponent ]; const SERVICES = [ EditService, FilterService, SortService, SelectionService, PaginationService, TableDataService ]; @NgModule({ declarations: [ ...COMPONENTS ], imports: [ CommonModule, FormsModule, ReactiveFormsModule, MatIconModule, MatAutocompleteModule ], providers: [ ...SERVICES, DatePipe ], exports: [ ...COMPONENTS ] }) export class IxtTableModule { }
    |   |   --- ixt-table.service.ts: import { Injectable } from '@angular/core'; import { BehaviorSubject, combineLatest, Observable } from 'rxjs'; import { map } from 'rxjs/operators'; import { PageSize } from './ixt-table.index'; import { TableRow } from './ixt-table.type'; export interface PaginationState { currentPage: number; pageSize: number | 'all'; totalPages: number; } @Injectable({ providedIn: 'root' }) export class TableDataService { private dataSubject = new BehaviorSubject<TableRow[]>([]); private newRowsSubject = new BehaviorSubject<TableRow[]>([]); private paginationStateSubject = new BehaviorSubject<PaginationState>({ currentPage: 1, pageSize: 10, totalPages: 1 }); readonly pageSizes: PageSize[] = [ { value: 10, label: '10' }, { value: 100, label: '100' }, { value: 'all', label: 'All' } ]; constructor() { } // Data operations setData(data: TableRow[]): void { this.dataSubject.next(data); this.updateTotalPages(); } getData(): Observable<TableRow[]> { return this.dataSubject.asObservable(); } // New rows operations addNewRow(row: TableRow): void { const currentNewRows = this.newRowsSubject.value; this.newRowsSubject.next([row, ...currentNewRows]); } getNewRows(): Observable<TableRow[]> { return this.newRowsSubject.asObservable(); } commitNewRows(): void { const currentData = this.dataSubject.value; const newRows = this.newRowsSubject.value; this.dataSubject.next([...newRows, ...currentData]); this.newRowsSubject.next([]); this.updateTotalPages(); } // Pagination operations setPaginationState(state: Partial<PaginationState>): void { const currentState = this.paginationStateSubject.value; this.paginationStateSubject.next({ ...currentState, ...state }); this.updateTotalPages(); } getPaginationState(): Observable<PaginationState> { return this.paginationStateSubject.asObservable(); } getPaginatedData(): Observable<TableRow[]> { return this.combineData().pipe( map(allData => this.paginateData(allData)) ); } private combineData(): Observable<TableRow[]> { return combineLatest([ this.dataSubject, this.newRowsSubject ]).pipe( map(([data, newRows]) => [...newRows, ...data]) ); } private paginateData(data: TableRow[]): TableRow[] { const state = this.paginationStateSubject.value; if (state.pageSize === 'all' || data.length <= 50) { return data; } const start = (state.currentPage - 1) * (+state.pageSize); const end = start + (+state.pageSize); return data.slice(start, end); } private updateTotalPages(): void { const currentState = this.paginationStateSubject.value; const totalItems = this.dataSubject.value.length + this.newRowsSubject.value.length; const totalPages = currentState.pageSize === 'all' || totalItems <= 50 ? 1 : Math.ceil(totalItems / +currentState.pageSize); this.paginationStateSubject.next({ ...currentState, totalPages }); } }
    |   |   --- ixt-table.type.ts: export interface TableRow { [key: string]: any; }
    |   +-- ixt-tabset
    |   |   --- ixt-tab.component.ts: import { Component, Input, TemplateRef, ViewChild } from '@angular/core'; @Component({ selector: 'ixt-tab', templateUrl: './ixt-tab.component.html', styleUrls: ['./ixt-tab.component.scss'] }) export class IxtTabComponent { @Input() title: string = ''; @ViewChild(TemplateRef, { static: true }) implicitContent!: TemplateRef<any>; }
    |   |   --- ixt-tabset.component.ts: import { Component, ContentChildren, QueryList, AfterContentInit } from '@angular/core'; import { IxtTabComponent } from './ixt-tab.component'; @Component({ selector: 'ixt-tabset', templateUrl: './ixt-tabset.component.html', styleUrls: ['./ixt-tabset.component.scss'] }) export class IxtTabsetComponent implements AfterContentInit { @ContentChildren(IxtTabComponent) tabs!: QueryList<IxtTabComponent>; selectedIndex: number = 0; notificationText: string = 'Content Band Icons or Info'; ngAfterContentInit() { // Set initial active tab if there are tabs if (this.tabs?.first) { this.selectTab(this.tabs.first); } // Listen for dynamic tab changes this.tabs?.changes.subscribe(() => { if (this.tabs.length && this.selectedIndex >= this.tabs.length) { this.selectTab(this.tabs.last); } }); } selectTab(tab: IxtTabComponent) { this.selectedIndex = this.tabs.toArray().indexOf(tab); } }
    |   |   --- ixt-tabset.index.ts: export * from './ixt-tabset.component'; export * from './ixt-tab.component'; // Updated path export * from './ixt-tabset.interfaces'; export * from './ixt-tabset.module';
    |   |   --- ixt-tabset.interfaces.ts: export interface ITabContent { id: string; title: string; content: string; active: boolean; } export interface ITabsetConfig { notificationText?: string; showNotificationBand?: boolean; animationDuration?: number; }
    |   |   --- ixt-tabset.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { IxtTabsetComponent } from './ixt-tabset.component'; import { IxtTabComponent } from './ixt-tab.component'; // Updated path @NgModule({ declarations: [ IxtTabsetComponent, IxtTabComponent ], imports: [ CommonModule ], exports: [ IxtTabsetComponent, IxtTabComponent ] }) export class IxtTabsetModule { }
    |   +-- ixt-textra
    |   |   --- ixt-textra.component.ts: // ixt-progress-template.ts export const PROGRESS_TEMPLATE = ` <div role="progressbar"> <p>{{message}}</p> <progress [value]="current" [max]="total"></progress> </div> `;
    |   \-- theme
    |       +-- styles
    |       |   \-- themes
    |       --- index.ts: // src/components/theme/index.ts export * from './theme.types'; export * from './theme.colors';
    |       --- theme.colors.ts: import { ThemeColors } from "./theme.types"; // src/app/theme/theme.colors.ts export const baseThemeColors: ThemeColors = { primary: { base: '#4169E1', // Royal Blue hover: '#2850c9', active: '#1e40af', text: '#ffffff' }, secondary: { base: '#6c757d', hover: '#5c636a', active: '#4d5154', text: '#ffffff' }, tertiary: { base: '#003057', // Rhapsody Blue (Pantone 289) hover: '#002649', // Darker shade for hover state active: '#001C3B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, success: { base: '#28a745', hover: '#218838', active: '#1e7e34', text: '#ffffff' }, danger: { base: '#dc3545', hover: '#c82333', active: '#bd2130', text: '#ffffff' }, warning: { base: '#ffc107', hover: '#e0a800', active: '#d39e00', text: '#000000' }, info: { base: '#17a2b8', hover: '#138496', active: '#117a8b', text: '#ffffff' }, light: { base: '#f8f9fa', hover: '#e2e6ea', active: '#dae0e5', text: '#000000' }, dark: { base: '#343a40', hover: '#23272b', active: '#1d2124', text: '#ffffff' }, default: { base: '#ffffff', hover: '#f8f9fa', active: '#e9ecef', text: '#000000' } }; // src/app/theme/theme.colors.ts export const unitedThemeColors: ThemeColors = { primary: { base: '#0033A0', // United Blue hover: '#00297A', // Darker shade for hover state active: '#002060', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, secondary: { base: '#6D2077', // Atlantic Amethyst hover: '#5A1A63', // Darker shade for hover state active: '#48154F', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, tertiary: { base: '#003057', // Rhapsody Blue (Pantone 289) hover: '#002649', // Darker shade for hover state active: '#001C3B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, success: { base: '#4CAF50', // Subtle green hover: '#43A047', // Darker shade for hover state active: '#388E3C', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, warning: { base: '#FF9800', // Warm yellow-orange hover: '#FB8C00', // Darker shade for hover state active: '#F57C00', // Even darker shade for active state text: '#000000' // Black text for readability }, danger: { base: '#E53935', // Tomato red hover: '#D32F2F', // Darker shade for hover state active: '#C62828', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, info: { base: '#17A2B8', // Standard info blue hover: '#138496', // Darker shade for hover state active: '#117A8B', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, light: { base: '#F8F9FA', // Light gray hover: '#E2E6EA', // Darker shade for hover state active: '#DAE0E5', // Even darker shade for active state text: '#000000' // Black text for readability }, dark: { base: '#343A40', // Dark gray hover: '#23272B', // Darker shade for hover state active: '#1D2124', // Even darker shade for active state text: '#FFFFFF' // White text for contrast }, default: { base: '#FFFFFF', // White hover: '#F8F9FA', // Light gray for hover state active: '#E9ECEF', // Darker gray for active state text: '#000000' // Black text for readability } };
    |       --- theme.colors.united.ts: <empty file>
    |       --- theme.module.ts: // src/components/theme/theme.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [CommonModule], exports: [] }) export class ThemeModule {}
    |       --- theme.types.ts: // src/app/theme/theme.types.ts export type ThemeVariant = | 'primary' // Main brand color, key actions | 'secondary' // Supporting color | 'tertiary' | 'success' // Positive actions/states | 'danger' // Errors, destructive actions | 'warning' // Caution states | 'info' // Informational states | 'light' // Light backgrounds | 'dark' // Dark text/backgrounds | 'default'; // Default state export interface ThemeColor { base: string; hover: string; active: string; text: string; } export type ThemeColors = Record<ThemeVariant, ThemeColor>;
    +-- services
    |   --- breadcrumb.service.ts: import { Injectable } from '@angular/core'; import { Router, NavigationEnd, ActivatedRoute } from '@angular/router'; import { filter, map } from 'rxjs/operators'; import { Observable } from 'rxjs'; export interface Breadcrumb { label: string; url: string; } @Injectable({ providedIn: 'root' }) export class BreadcrumbService { breadcrumbs$: Observable<Breadcrumb[]>; constructor(private router: Router, private activatedRoute: ActivatedRoute) { this.breadcrumbs$ = this.router.events.pipe( filter(event => event instanceof NavigationEnd), map(event => { const root = this.activatedRoute.root; return this.createBreadcrumbs(root); }) ); } private createBreadcrumbs(route: ActivatedRoute, url: string = '', breadcrumbs: Breadcrumb[] = []): Breadcrumb[] { const children: ActivatedRoute[] = route.children; if (children.length === 0) { return breadcrumbs; } for (const child of children) { const routeURL: string = child.snapshot.url.map(segment => segment.path).join('/'); if (routeURL !== '') { url += `/${routeURL}`; } const label = child.snapshot.data['breadcrumb']; if (label) { breadcrumbs.push({ label, url }); } return this.createBreadcrumbs(child, url, breadcrumbs); } return breadcrumbs; } }
    --- index.ts: // src/index.ts export * from './public-api';
    --- main.ts: import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module'; platformBrowserDynamic().bootstrapModule(AppModule) .catch(err => console.error(err));
    --- public-api.ts: // public-api.ts //---------------------------------- Core Components & Services ---------------------------------- export { IxtTableModule, IxtTableComponent, AirportCodeEditorComponent, CoordinateEditorComponent, BinaryEditorComponent, TableEditor, ColumnConfigs, EditService, FilterService, SortService, SelectionService, PaginationService } from './components/ixt-table/ixt-table.index'; export { IxtDialogModule, IxtDialogComponent, IxtDialogService } from './components/ixt-dialog/ixt-dialog.index'; export { IxtTabsetModule, IxtTabComponent, IxtTabsetComponent, ITabContent, ITabsetConfig } from './components/ixt-tabset/ixt-tabset.index'; //------------------------------------ Basic UI Components ------------------------------------- export { IxtButtonModule } from './components/ixt-button/ixt-button.index'; export { IxtPanelModule } from './components/ixt-panel/ixt-panel.index'; export { IxtMenuModule } from './components/ixt-menu/ixt-menu.index'; export { IxtTreeModule } from './components/ixt-tree/ixt-tree.index'; export { IxtAccordianModule } from './components/ixt-accordian/ixt-accordian.index'; // //--------------------------------- Canvas & View Components ---------------------------------- // export { // IxtCanvasModule, // IxtViewportModule // } from './components/ixt-canvas/ixt-viewport.index'; // //------------------------------------ Form Components --------------------------------------- // export { // IxtExpressionBuilderModule // } from './components/ixt-expression-builder/ixt-expression-builder.index'; // //----------------------------------- Diagram Components ------------------------------------ // export { // IxtDiagramModule // } from './components/ixt-diagram/ixt-diagram.index'; // export { // IxtClazzModule // } from './components/ixt-diagram/types/clazz/ixt-clazz.index'; // export { // IxtDeploymentModule // } from './components/ixt-diagram/types/deployment/ixt-deployment.index'; // export { // IxtEbnfModule // } from './components/ixt-diagram/types/EBNF/ixt-ebnf.index'; // export { // IxtFlowModule // } from './components/ixt-diagram/types/flow/ixt-flow.index'; // export { // IxtGanntModule // } from './components/ixt-diagram/types/gannt/gannt.index'; // export { // IxtNetworkModule // } from './components/ixt-diagram/types/network/ixt-network.index'; // export { // IxtSankeyModule // } from './components/ixt-diagram/types/sankey/ixt-sankey.index'; // export { // IxtWireframeModule // } from './components/ixt-diagram/types/wireframe/ixt-wireframe.index'; // //-------------------------------- Map & Layer Components ---------------------------------- // export { // IxtMapModule // } from './components/ixt-map/ixt-map.index'; // export { // IxtLayerManagerModule // } from './components/ixt-layer-manager/ixt-layer-manager.index'; //----------------------------- Utility & Layout Components -------------------------------- // export { // IxtSplitPaneModule, // IxtSplitPaneComponent // } from './components/ixt-splitpane/index'; // export { // IxtCalendarModule // } from './components/ixt-calendar/ixt-calendar.index'; // //------------------------------------ Theme Exports -------------------------------------- // export { // ThemeVariant, // ThemeColor, // ThemeColors // } from './components/theme/theme.types'; // export { // baseThemeColors, // unitedThemeColors // } from './components/theme/theme.colors';
